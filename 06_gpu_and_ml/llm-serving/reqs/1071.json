{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"untitled\":\n```diff\n@@ -83,7 +83,7 @@\n - [ ] Linux-wayland (64)              https://github.com/zed-industries/zed/issues?q=is%3Aopen%20label%3Alinux-wayland%20no%3Atype%20%20\n - [ ] Linux not:x11,wayland (159)     https://github.com/zed-industries/zed/issues?q=is%3Aopen%20-label%3Alinux-wayland%20-label%3Alinux-x11%20label%3Alinux%20no%3Atype%20%20%20\n - [ ] AI (168)                        https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3Aai%20no%3Atype\n-- [ ] [joseph] https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22\n+- [ ] [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22\n - \n \n ### \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -83,7 +83,7 @@\n - [ ] Linux-wayland (64)              https://github.com/zed-industries/zed/issues?q=is%3Aopen%20label%3Alinux-wayland%20no%3Atype%20%20\n - [ ] Linux not:x11,wayland (159)     https://github.com/zed-industries/zed/issues?q=is%3Aopen%20-label%3Alinux-wayland%20-label%3Alinux-x11%20label%3Alinux%20no%3Atype%20%20%20\n - [ ] AI (168)                        https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3Aai%20no%3Atype\n-- [ ] [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22\n+- [ ] [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22 (65 -> )\n - \n \n ### \n\n```\n\n\n\nUser edited \"untitled\":\n```diff\n@@ -84,6 +84,7 @@\n - [ ] Linux not:x11,wayland (159)     https://github.com/zed-industries/zed/issues?q=is%3Aopen%20-label%3Alinux-wayland%20-label%3Alinux-x11%20label%3Alinux%20no%3Atype%20%20%20\n - [ ] AI (168)                        https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3Aai%20no%3Atype\n - [ ] [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22 (65 -> )\n+- [ ] [joseph] https://github.com/zed-industries/zed/issues?q=state%3Aopen%20label%3A%22awaiting%20info%22\n - \n \n ### \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -83,7 +83,7 @@\n - [ ] Linux-wayland (64)              https://github.com/zed-industries/zed/issues?q=is%3Aopen%20label%3Alinux-wayland%20no%3Atype%20%20\n - [ ] Linux not:x11,wayland (159)     https://github.com/zed-industries/zed/issues?q=is%3Aopen%20-label%3Alinux-wayland%20-label%3Alinux-x11%20label%3Alinux%20no%3Atype%20%20%20\n - [ ] AI (168)                        https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3Aai%20no%3Atype\n-- [ ] [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22 (65 -> )\n+- [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22 (65 -> )\n - [ ] [joseph] https://github.com/zed-industries/zed/issues?q=state%3Aopen%20label%3A%22awaiting%20info%22\n - \n \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -84,7 +84,7 @@\n - [ ] Linux not:x11,wayland (159)     https://github.com/zed-industries/zed/issues?q=is%3Aopen%20-label%3Alinux-wayland%20-label%3Alinux-x11%20label%3Alinux%20no%3Atype%20%20%20\n - [ ] AI (168)                        https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3Aai%20no%3Atype\n - [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22 (65 -> )\n-- [ ] [joseph] https://github.com/zed-industries/zed/issues?q=state%3Aopen%20label%3A%22awaiting%20info%22\n+- [joseph] https://github.com/zed-industries/zed/issues?q=state%3Aopen%20label%3A%22awaiting%20info%22\n - \n \n ### \n\n```\n\n### Input:\n```crates/cli/src/main.rs\n<|editable_region_start|>\n<|user_cursor_is_here|>#![cfg_attr(\n    any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"windows\"),\n    allow(dead_code)\n)]\n\nuse anyhow::{Context as _, Result};\nuse clap::Parser;\nuse cli::{ipc::IpcOneShotServer, CliRequest, CliResponse, IpcHandshake};\nuse collections::HashMap;\nuse parking_lot::Mutex;\nuse std::{\n    env, fs, io,\n    path::{Path, PathBuf},\n    process::ExitStatus,\n    sync::Arc,\n    thread::{self, JoinHandle},\n};\nuse tempfile::NamedTempFile;\nuse util::paths::PathWithPosition;\n\n#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\nuse std::io::IsTerminal;\n\nstruct Detect;\n\ntrait InstalledApp {\n    fn zed_version_string(&self) -> String;\n    fn launch(&self, ipc_url: String) -> anyhow::Result<()>;\n    fn run_foreground(&self, ipc_url: String) -> io::Result<ExitStatus>;\n}\n\n#[derive(Parser, Debug)]\n#[command(\n    name = \"zed\",\n    disable_version_flag = true,\n    after_help = \"To read from stdin, append '-' (e.g. 'ps axf | zed -')\"\n)]\nstruct Args {\n    /// Wait for all of the given paths to be opened/closed before exiting.\n    #[arg(short, long)]\n    wait: bool,\n    /// Add files to the currently open workspace\n    #[arg(short, long, overrides_with = \"new\")]\n    add: bool,\n    /// Create a new workspace\n    #[arg(short, long, overrides_with = \"add\")]\n    new: bool,\n    /// A sequence of space-separated paths that you want to open.\n    ///\n    /// Use `path:line:row` syntax to open a file at a specific location.\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    paths_with_position: Vec<String>,\n    /// Print Zed's version and the app path.\n    #[arg(short, long)]\n    version: bool,\n    /// Run zed in the foreground (useful for debugging)\n    #[arg(long)]\n    foreground: bool,\n    /// Custom path to Zed.app or the zed binary\n    #[arg(long)]\n    zed: Option<PathBuf>,\n    /// Run zed in dev-server mode\n    #[arg(long)]\n    dev_server_token: Option<String>,\n    /// Uninstall Zed from user system\n    #[cfg(all(\n        any(target_os = \"linux\", target_os = \"macos\"),\n        not(feature = \"no-bundled-uninstall\")\n    ))]\n    #[arg(long)]\n    uninstall: bool,\n}\n\nfn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n    let canonicalized = match Path::new(argument_str).canonicalize() {\n        Ok(existing_path) => PathWithPosition::from_path(existing_path),\n        Err(_) => {\n            let path = PathWithPosition::parse_str(argument_str);\n            let curdir = env::current_dir().context(\"retrieving current directory\")?;\n            path.map_path(|path| match fs::canonicalize(&path) {\n                Ok(path) => Ok(path),\n                Err(e) => {\n                    if let Some(mut parent) = path.parent() {\n                        if parent == Path::new(\"\") {\n                            parent = &curdir\n                        }\n                        match fs::canonicalize(parent) {\n                            Ok(parent) => Ok(parent.join(path.file_name().unwrap())),\n                            Err(_) => Err(e),\n                        }\n                    } else {\n                        Err(e)\n                    }\n                }\n            })\n        }\n        .with_context(|| format!(\"parsing as path with position {argument_str}\"))?,\n    };\n    Ok(canonicalized.to_string(|path| path.to_string_lossy().to_string()))\n}\n\nfn main() -> Result<()> {\n    // Exit flatpak sandbox if needed\n    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n    {\n        flatpak::try_restart_to_host();\n        flatpak::ld_extra_libs();\n    }\n\n    // Intercept version designators\n    #[cfg(target_os = \"macos\")]\n    if let Some(channel) = std::env::args().nth(1).filter(|arg| arg.starts_with(\"--\")) {\n        // When the first argument is a name of a release channel, we're gonna spawn off a cli of that version, with trailing args passed along.\n        use std::str::FromStr as _;\n\n        if let Ok(channel) = release_channel::ReleaseChannel::from_str(&channel[2..]) {\n            return mac_os::spawn_channel_cli(channel, std::env::args().skip(2).collect());\n<|editable_region_end|>\n        if let Ok(channel) = release_channel::ReleaseChannel::from_str(&channel[2..]) {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/cli/src/main.rs\n<|editable_region_start|>\n<|user_cursor_is_here|>#![cfg_attr(\n    any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"windows\"),\n    allow(dead_code)\n)]\n\nuse anyhow::{Context as _, Result};\nuse clap::Parser;\nuse cli::{ipc::IpcOneShotServer, CliRequest, CliResponse, IpcHandshake};\nuse collections::HashMap;\nuse parking_lot::Mutex;\nuse std::{\n    env, fs, io,\n    path::{Path, PathBuf},\n    process::ExitStatus,\n    sync::Arc,\n    thread::{self, JoinHandle},\n};\nuse tempfile::NamedTempFile;\nuse util::paths::PathWithPosition;\n\n#[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\nuse std::io::IsTerminal;\n\nstruct Detect;\n\ntrait InstalledApp {\n    fn zed_version_string(&self) -> String;\n    fn launch(&self, ipc_url: String) -> anyhow::Result<()>;\n    fn run_foreground(&self, ipc_url: String) -> io::Result<ExitStatus>;\n}\n\n#[derive(Parser, Debug)]\n#[command(\n    name = \"zed\",\n    disable_version_flag = true,\n    after_help = \"To read from stdin, append '-' (e.g. 'ps axf | zed -')\"\n)]\nstruct Args {\n    /// Wait for all of the given paths to be opened/closed before exiting.\n    #[arg(short, long)]\n    wait: bool,\n    /// Add files to the currently open workspace\n    #[arg(short, long, overrides_with = \"new\")]\n    add: bool,\n    /// Create a new workspace\n    #[arg(short, long, overrides_with = \"add\")]\n    new: bool,\n    /// A sequence of space-separated paths that you want to open.\n    ///\n    /// Use `path:line:row` syntax to open a file at a specific location.\n    /// Non-existing paths and directories will ignore `:line:row` suffix.\n    paths_with_position: Vec<String>,\n    /// Print Zed's version and the app path.\n    #[arg(short, long)]\n    version: bool,\n    /// Run zed in the foreground (useful for debugging)\n    #[arg(long)]\n    foreground: bool,\n    /// Custom path to Zed.app or the zed binary\n    #[arg(long)]\n    zed: Option<PathBuf>,\n    /// Run zed in dev-server mode\n    #[arg(long)]\n    dev_server_token: Option<String>,\n    /// Uninstall Zed from user system\n    #[cfg(all(\n        any(target_os = \"linux\", target_os = \"macos\"),\n        not(feature = \"no-bundled-uninstall\")\n    ))]\n    #[arg(long)]\n    uninstall: bool,\n}\n\nfn parse_path_with_position(argument_str: &str) -> anyhow::Result<String> {\n    let canonicalized = match Path::new(argument_str).canonicalize() {\n        Ok(existing_path) => PathWithPosition::from_path(existing_path),\n        Err(_) => {\n            let path = PathWithPosition::parse_str(argument_str);\n            let curdir = env::current_dir().context(\"retrieving current directory\")?;\n            path.map_path(|path| match fs::canonicalize(&path) {\n                Ok(path) => Ok(path),\n                Err(e) => {\n                    if let Some(mut parent) = path.parent() {\n                        if parent == Path::new(\"\") {\n                            parent = &curdir\n                        }\n                        match fs::canonicalize(parent) {\n                            Ok(parent) => Ok(parent.join(path.file_name().unwrap())),\n                            Err(_) => Err(e),\n                        }\n                    } else {\n                        Err(e)\n                    }\n                }\n            })\n        }\n        .with_context(|| format!(\"parsing as path with position {argument_str}\"))?,\n    };\n    Ok(canonicalized.to_string(|path| path.to_string_lossy().to_string()))\n}\n\nfn main() -> Result<()> {\n    // Exit flatpak sandbox if needed\n    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n    {\n        flatpak::try_restart_to_host();\n        flatpak::ld_extra_libs();\n    }\n\n    // Intercept version designators\n    #[cfg(target_os = \"macos\")]\n    if let Some(channel) = std::env::args().nth(1).filter(|arg| arg.starts_with(\"--\")) {\n        // When the first argument is a name of a release channel, we're gonna spawn off a cli of that version, with trailing args passed along.\n        use std::str::FromStr as _;\n\n        if let Ok(channel) = release_channel::ReleaseChannel::from_str(&channel[2..]) {\n            return mac_os::spawn_channel_cli(channel, std::env::args().skip(2).collect());\n<|editable_region_end|>\n        if let Ok(channel) = release_channel::ReleaseChannel::from_str(&channel[2..]) {\n```"
  },
  "max_tokens": 1024
}