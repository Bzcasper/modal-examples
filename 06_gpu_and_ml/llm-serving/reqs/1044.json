{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"untitled\":\n```diff\n@@ -47,6 +47,7 @@\n   \n - Enhancements:\n   - Thanks for the idea! This is likely something we should talk through in the discussions. \n+  Thanks for the idea! It shouldn't be too hard if you want to send a PR, or I'm happy to pair on this https://cal.com/conradirwin/pairing\n   - Nice, a few people have requested something like this. We're tracking all the things we could pull from [Sublime] in a discussion,\n     (list of possible discussions, inlcuding editor specific ones: https://github.com/zed-industries/zed/discussions)\n   - This would be great! That said, I think we should hold off until we have better extension support and build it as an extension.\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -47,7 +47,7 @@\n   \n - Enhancements:\n   - Thanks for the idea! This is likely something we should talk through in the discussions. \n-  Thanks for the idea! It shouldn't be too hard if you want to send a PR, or I'm happy to pair on this https://cal.com/conradirwin/pairing\n+  - Thanks for the idea! It shouldn't be too hard if you want to send a PR, or I'm happy to pair on this https://cal.com/conradirwin/pairing\n   - Nice, a few people have requested something like this. We're tracking all the things we could pull from [Sublime] in a discussion,\n     (list of possible discussions, inlcuding editor specific ones: https://github.com/zed-industries/zed/discussions)\n   - This would be great! That said, I think we should hold off until we have better extension support and build it as an extension.\n\n```\n\n\n\n\n\nUser edited \"untitled\":\n```diff\n@@ -147,7 +147,7 @@\n - [ ] [ ] [2024 Week 52](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-12-29%20created%3A%3C2025-01-05%20no%3Atype)\n - [ ] [ ] [2025 Week 01](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-05%20created%3A%3C2025-01-12%20no%3Atype)\n - [ ] [ ] [2025 Week 02](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-12%20created%3A%3C2025-01-19%20no%3Atype)\n-- [ ] [@michael] [2025 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-19%20created%3A%3C2025-01-26%20no%3Atype)\n+- [ ] [@michael @ben] [2025 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-19%20created%3A%3C2025-01-26%20no%3Atype)\n \n \n  \n\n```\n\n### Input:\n```crates/collab/src/tests/editor_tests.rs\n    active_call_b\n<|editable_region_start|>\n        .update(cx_b, |call, cx| {\n            call.invite(client_a.user_id().unwrap(), None, cx)\n        })\n        .await\n        .unwrap();\n    cx_a.background_executor.run_until_parked();\n    active_call_a\n        .update(cx_a, |call, cx| call.accept_incoming(cx))\n        .await\n        .unwrap();\n\n    active_call_a\n        .update(cx_a, |call, cx| call.share_project(project_a.clone(), cx))\n        .await\n        .unwrap();\n\n    // Drop client A's connection again. We should still unshare it successfully.\n    server.forbid_connections();\n    server.disconnect_client(client_a.peer_id().unwrap());\n    cx_a.background_executor\n        .advance_clock(RECEIVE_TIMEOUT + RECONNECT_TIMEOUT);\n\n    project_a.read_with(cx_a, |project, _| assert!(!project.is_shared()));\n}\n\n#[gpui::test]\nasync fn test_newline_above_or_below_does_not_move_guest_cursor(\n    cx_a: &mut TestAppContext,\n    cx_b: &mut TestAppContext,\n) {\n    let mut server = TestServer::start(cx_a.executor()).await;\n    let client_a = server.create_client(cx_a, \"user_a\").await;\n    let client_b = server.create_client(cx_b, \"user_b\").await;\n    let executor = cx_a.executor();\n    server\n        .create_room(&mut [(&client_a, cx_a), (&client_b, cx_b)])\n        .await;\n    let active_call_a = cx_a.read(ActiveCall::global);\n\n    client_a\n        .fs()\n        .insert_tree(\"/dir\", json!({ \"a.txt\": \"Some text\\n\" }))\n        .await;\n    let (project_a, worktree_id) = client_a.build_local_project(\"/dir\", cx_a).await;\n    let project_id = active_call_a\n        .update(cx_a, |call, cx| call.share_project(project_a.clone(), cx))\n        .await\n        .unwrap();\n\n    let project_b = client_b.join_remote_project(project_id, cx_b).await;\n\n    // Open a buffer as client A\n    let buffer_a = project_a\n        .update(cx_a, |p, cx| p.open_buffer((worktree_id, \"a.txt\"), cx))\n        .await\n        .unwrap();\n    let cx_a = cx_a.add_empty_window();\n    let editor_a = cx_a\n        .new_window_entity(|window, cx| Editor::for_buffer(buffer_a, Some(project_a), window, cx));\n\n    let mut editor_cx_a = EditorTestContext {\n        cx: cx_a.clone(),\n        window: cx_a.window_handle(),\n        editor: editor_a,\n        assertion_cx: AssertionContextManager:<|user_cursor_is_here|>:new(),\n    };\n\n    let cx_b = cx_b.add_empty_window();\n    // Open a buffer as client B\n    let buffer_b = project_b\n        .update(cx_b, |p, cx| p.open_buffer((worktree_id, \"a.txt\"), cx))\n        .await\n        .unwrap();\n    let editor_b = cx_b\n        .new_window_entity(|window, cx| Editor::for_buffer(buffer_b, Some(project_b), window, cx));\n\n    let mut editor_cx_b = EditorTestContext {\n        cx: cx_b.clone(),\n        window: cx_b.window_handle(),\n        editor: editor_b,\n        assertion_cx: AssertionContextManager::new(),\n    };\n\n    // Test newline above\n    editor_cx_a.set_selections_state(indoc! {\"\n        Some textˇ\n    \"});\n    editor_cx_b.set_selections_state(indoc! {\"\n        Some textˇ\n    \"});\n    editor_cx_a.update_editor(|editor, window, cx| {\n        editor.newline_above(&editor::actions::NewlineAbove, window, cx)\n    });\n    executor.run_until_parked();\n    editor_cx_a.assert_editor_state(indoc! {\"\n        ˇ\n        Some text\n    \"});\n    editor_cx_b.assert_editor_state(indoc! {\"\n\n        Some textˇ\n    \"});\n\n    // Test newline below\n    editor_cx_a.set_selections_state(indoc! {\"\n\n        Some textˇ\n    \"});\n    editor_cx_b.set_selections_state(indoc! {\"\n\n        Some textˇ\n    \"});\n    editor_cx_a.update_editor(|editor, window, cx| {\n        editor.newline_below(&editor::actions::NewlineBelow, window, cx)\n    });\n    executor.run_until_parked();\n    editor_cx_a.assert_editor_state(indoc! {\"\n\n        Some text\n        ˇ\n    \"});\n    editor_cx_b.assert_editor_state(indoc! {\"\n\n        Some textˇ\n\n    \"});\n}\n\n#[gpui::test(iterations = 10)]\nasync fn test_collaborating_with_completion(cx_a: &mut TestAppContext, cx_b: &mut TestAppContext) {\n    let mut server = TestServer::start(cx_a.executor()).await;\n<|editable_region_end|>\nasync fn test_collaborating_with_completion(cx_a: &mut TestAppContext, cx_b: &mut TestAppContext) {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/collab/src/tests/editor_tests.rs\n    active_call_b\n<|editable_region_start|>\n        .update(cx_b, |call, cx| {\n            call.invite(client_a.user_id().unwrap(), None, cx)\n        })\n        .await\n        .unwrap();\n    cx_a.background_executor.run_until_parked();\n    active_call_a\n        .update(cx_a, |call, cx| call.accept_incoming(cx))\n        .await\n        .unwrap();\n\n    active_call_a\n        .update(cx_a, |call, cx| call.share_project(project_a.clone(), cx))\n        .await\n        .unwrap();\n\n    // Drop client A's connection again. We should still unshare it successfully.\n    server.forbid_connections();\n    server.disconnect_client(client_a.peer_id().unwrap());\n    cx_a.background_executor\n        .advance_clock(RECEIVE_TIMEOUT + RECONNECT_TIMEOUT);\n\n    project_a.read_with(cx_a, |project, _| assert!(!project.is_shared()));\n}\n\n#[gpui::test]\nasync fn test_newline_above_or_below_does_not_move_guest_cursor(\n    cx_a: &mut TestAppContext,\n    cx_b: &mut TestAppContext,\n) {\n    let mut server = TestServer::start(cx_a.executor()).await;\n    let client_a = server.create_client(cx_a, \"user_a\").await;\n    let client_b = server.create_client(cx_b, \"user_b\").await;\n    let executor = cx_a.executor();\n    server\n        .create_room(&mut [(&client_a, cx_a), (&client_b, cx_b)])\n        .await;\n    let active_call_a = cx_a.read(ActiveCall::global);\n\n    client_a\n        .fs()\n        .insert_tree(\"/dir\", json!({ \"a.txt\": \"Some text\\n\" }))\n        .await;\n    let (project_a, worktree_id) = client_a.build_local_project(\"/dir\", cx_a).await;\n    let project_id = active_call_a\n        .update(cx_a, |call, cx| call.share_project(project_a.clone(), cx))\n        .await\n        .unwrap();\n\n    let project_b = client_b.join_remote_project(project_id, cx_b).await;\n\n    // Open a buffer as client A\n    let buffer_a = project_a\n        .update(cx_a, |p, cx| p.open_buffer((worktree_id, \"a.txt\"), cx))\n        .await\n        .unwrap();\n    let cx_a = cx_a.add_empty_window();\n    let editor_a = cx_a\n        .new_window_entity(|window, cx| Editor::for_buffer(buffer_a, Some(project_a), window, cx));\n\n    let mut editor_cx_a = EditorTestContext {\n        cx: cx_a.clone(),\n        window: cx_a.window_handle(),\n        editor: editor_a,\n        assertion_cx: AssertionContextManager:<|user_cursor_is_here|>:new(),\n    };\n\n    let cx_b = cx_b.add_empty_window();\n    // Open a buffer as client B\n    let buffer_b = project_b\n        .update(cx_b, |p, cx| p.open_buffer((worktree_id, \"a.txt\"), cx))\n        .await\n        .unwrap();\n    let editor_b = cx_b\n        .new_window_entity(|window, cx| Editor::for_buffer(buffer_b, Some(project_b), window, cx));\n\n    let mut editor_cx_b = EditorTestContext {\n        cx: cx_b.clone(),\n        window: cx_b.window_handle(),\n        editor: editor_b,\n        assertion_cx: AssertionContextManager::new(),\n    };\n\n    // Test newline above\n    editor_cx_a.set_selections_state(indoc! {\"\n        Some textˇ\n    \"});\n    editor_cx_b.set_selections_state(indoc! {\"\n        Some textˇ\n    \"});\n    editor_cx_a.update_editor(|editor, window, cx| {\n        editor.newline_above(&editor::actions::NewlineAbove, window, cx)\n    });\n    executor.run_until_parked();\n    editor_cx_a.assert_editor_state(indoc! {\"\n        ˇ\n        Some text\n    \"});\n    editor_cx_b.assert_editor_state(indoc! {\"\n\n        Some textˇ\n    \"});\n\n    // Test newline below\n    editor_cx_a.set_selections_state(indoc! {\"\n\n        Some textˇ\n    \"});\n    editor_cx_b.set_selections_state(indoc! {\"\n\n        Some textˇ\n    \"});\n    editor_cx_a.update_editor(|editor, window, cx| {\n        editor.newline_below(&editor::actions::NewlineBelow, window, cx)\n    });\n    executor.run_until_parked();\n    editor_cx_a.assert_editor_state(indoc! {\"\n\n        Some text\n        ˇ\n    \"});\n    editor_cx_b.assert_editor_state(indoc! {\"\n\n        Some textˇ\n\n    \"});\n}\n\n#[gpui::test(iterations = 10)]\nasync fn test_collaborating_with_completion(cx_a: &mut TestAppContext, cx_b: &mut TestAppContext) {\n    let mut server = TestServer::start(cx_a.executor()).await;\n<|editable_region_end|>\nasync fn test_collaborating_with_completion(cx_a: &mut TestAppContext, cx_b: &mut TestAppContext) {\n```"
  },
  "max_tokens": 1024
}