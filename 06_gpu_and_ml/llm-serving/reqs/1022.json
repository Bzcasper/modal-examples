{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -144,14 +144,7 @@\n         languages: Arc<LanguageRegistry>,\n         cx: &mut App,\n     ) -> Entity<Self> {\n-        let _language_subscription = cx.subscribe(\n-            &languages,\n-            |this, _, event, _| {\n-                if event == &LanguageRegistryEvent::Changed {\n-                    this.restart_language_servers(cx);\n-                }\n-            },\n-        );\n+        let _language_subscription = languages.subscribe();\n         cx.new(|cx| Self {\n             _subscriptions: cx.subscribe(\n                 &project_tree,\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -156,6 +156,7 @@\n             instances: Default::default(),\n             attach_kind_cache: Default::default(),\n             languages,\n+            _language_subscription,\n         })\n     }\n     /// Memoize calls to attach_kind on LspAdapter (which might be a WASM extension, thus ~expensive to call).\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -44,7 +44,7 @@\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n     _subscriptions: Subscription,\n-    _language_subscription: Subscription,\n+    _language_subscription: watch::Receiver<()>,\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -23,6 +23,7 @@\n };\n use lsp::LanguageServerName;\n use once_cell::sync::OnceCell;\n+use postage::watch;\n use settings::{Settings, SettingsLocation, WorktreeId};\n use util::maybe;\n \n\n```\n\n\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -44,7 +44,6 @@\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n     _subscriptions: Subscription,\n-    _language_subscription: Subscription,\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -3363,6 +3363,7 @@\n                     if reload_count > prev_reload_count {\n                         prev_reload_count = reload_count;\n                         this.update(&mut cx, |this, cx| {\n+                            this.\n                             this.buffer_store.clone().update(cx, |buffer_store, cx| {\n                                 for buffer in buffer_store.buffers() {\n                                     if let Some(f) = File::from_dyn(buffer.read(cx).file()).cloned()\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -3363,7 +3363,7 @@\n                     if reload_count > prev_reload_count {\n                         prev_reload_count = reload_count;\n                         this.update(&mut cx, |this, cx| {\n-                            this.\n+                            this.lsp_t\n                             this.buffer_store.clone().update(cx, |buffer_store, cx| {\n                                 for buffer in buffer_store.buffers() {\n                                     if let Some(f) = File::from_dyn(buffer.read(cx).file()).cloned()\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -3363,7 +3363,7 @@\n                     if reload_count > prev_reload_count {\n                         prev_reload_count = reload_count;\n                         this.update(&mut cx, |this, cx| {\n-                            this.lsp_t\n+                            this.tree\n                             this.buffer_store.clone().update(cx, |buffer_store, cx| {\n                                 for buffer in buffer_store.buffers() {\n                                     if let Some(f) = File::from_dyn(buffer.read(cx).file()).cloned()\n\n```\n\n### Input:\n```crates/project/src/lsp_store.rs\n                let local = this.as_local_mut().unwrap();\n<|editable_region_start|>\n                if let Some(file) = File::from_dyn(buffer.read(cx).file()).cloned() {\n                    local.unregister_old_buffer_from_language_servers(&buffer, &file, cx);\n                }\n            })\n            .detach();\n        } else if let Some((upstream_client, upstream_project_id)) = self.upstream_client() {\n            let buffer_id = buffer.read(cx).remote_id().to_proto();\n            cx.background_executor()\n                .spawn(async move {\n                    upstream_client\n                        .request(proto::RegisterBufferWithLanguageServers {\n                            project_id: upstream_project_id,\n                            buffer_id,\n                        })\n                        .await\n                })\n                .detach();\n        } else {\n            panic!(\"oops!\");\n        }\n        handle\n    }\n\n    fn maintain_buffer_languages(\n        languages: Arc<LanguageRegistry>,\n        cx: &mut Context<Self>,\n    ) -> Task<()> {\n        let mut subscription = languages.subscribe();\n        let mut prev_reload_count = languages.reload_count();\n        cx.spawn(move |this, mut cx| async move {\n            while let Some(()) = subscription.next().await {\n                if let Some(this) = this.upgrade() {\n                    // If the language registry has been reloaded, then remove and\n                    // re-assign the languages on all open buffers.\n                    let reload_count = languages.reload_count();\n                    if reload_count > prev_reload_count {\n                        prev_reload_count = reload_count;\n                        this.update(&mut cx, |this, cx| {\n                            if let Some(local) = this.as_local_mut() {\n                                local.lsp_tree.up<|user_cursor_is_here|>\n                            }\n                            this.buffer_store.clone().update(cx, |buffer_store, cx| {\n                                for buffer in buffer_store.buffers() {\n                                    if let Some(f) = File::from_dyn(buffer.read(cx).file()).cloned()\n                                    {\n                                        buffer\n                                            .update(cx, |buffer, cx| buffer.set_language(None, cx));\n                                        if let Some(local) = this.as_local_mut() {\n                                            local.reset_buffer(&buffer, &f, cx);\n\n                                            local.unregister_old_buffer_from_language_servers(\n                                                &buffer, &f, cx,\n                                            );\n                                        }\n                                    }\n                                }\n                            });\n                        })\n                        .ok();\n                    }\n\n                    this.update(&mut cx, |this, cx| {\n                        let mut plain_text_buffers = Vec::new();\n                        let mut buffers_with_unknown_injections = Vec::new();\n                        for handle in this.buffer_store.read(cx).buffers() {\n                            let buffer = handle.read(cx);\n                            if buffer.language().is_none()\n                                || buffer.language() == Some(&*language::PLAIN_TEXT)\n                            {\n                                plain_text_buffers.push(handle);\n                            } else if buffer.contains_unknown_injections() {\n                                buffers_with_unknown_injections.push(handle);\n                            }\n                        }\n                        for buffer in plain_text_buffers {\n                            this.detect_language_for_buffer(&buffer, cx);\n                            if let Some(local) = this.as_local_mut() {\n                                local.initialize_buffer(&buffer, cx);\n                                local.register_buffer_with_language_servers(&buffer, cx);\n<|editable_region_end|>\n                                local.initialize_buffer(&buffer, cx);\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/lsp_store.rs\n                let local = this.as_local_mut().unwrap();\n<|editable_region_start|>\n                if let Some(file) = File::from_dyn(buffer.read(cx).file()).cloned() {\n                    local.unregister_old_buffer_from_language_servers(&buffer, &file, cx);\n                }\n            })\n            .detach();\n        } else if let Some((upstream_client, upstream_project_id)) = self.upstream_client() {\n            let buffer_id = buffer.read(cx).remote_id().to_proto();\n            cx.background_executor()\n                .spawn(async move {\n                    upstream_client\n                        .request(proto::RegisterBufferWithLanguageServers {\n                            project_id: upstream_project_id,\n                            buffer_id,\n                        })\n                        .await\n                })\n                .detach();\n        } else {\n            panic!(\"oops!\");\n        }\n        handle\n    }\n\n    fn maintain_buffer_languages(\n        languages: Arc<LanguageRegistry>,\n        cx: &mut Context<Self>,\n    ) -> Task<()> {\n        let mut subscription = languages.subscribe();\n        let mut prev_reload_count = languages.reload_count();\n        cx.spawn(move |this, mut cx| async move {\n            while let Some(()) = subscription.next().await {\n                if let Some(this) = this.upgrade() {\n                    // If the language registry has been reloaded, then remove and\n                    // re-assign the languages on all open buffers.\n                    let reload_count = languages.reload_count();\n                    if reload_count > prev_reload_count {\n                        prev_reload_count = reload_count;\n                        this.update(&mut cx, |this, cx| {\n                            if let Some(local) = this.as_local_mut() {\n                                local.lsp_tree.up<|user_cursor_is_here|>\n                            }\n                            this.buffer_store.clone().update(cx, |buffer_store, cx| {\n                                for buffer in buffer_store.buffers() {\n                                    if let Some(f) = File::from_dyn(buffer.read(cx).file()).cloned()\n                                    {\n                                        buffer\n                                            .update(cx, |buffer, cx| buffer.set_language(None, cx));\n                                        if let Some(local) = this.as_local_mut() {\n                                            local.reset_buffer(&buffer, &f, cx);\n\n                                            local.unregister_old_buffer_from_language_servers(\n                                                &buffer, &f, cx,\n                                            );\n                                        }\n                                    }\n                                }\n                            });\n                        })\n                        .ok();\n                    }\n\n                    this.update(&mut cx, |this, cx| {\n                        let mut plain_text_buffers = Vec::new();\n                        let mut buffers_with_unknown_injections = Vec::new();\n                        for handle in this.buffer_store.read(cx).buffers() {\n                            let buffer = handle.read(cx);\n                            if buffer.language().is_none()\n                                || buffer.language() == Some(&*language::PLAIN_TEXT)\n                            {\n                                plain_text_buffers.push(handle);\n                            } else if buffer.contains_unknown_injections() {\n                                buffers_with_unknown_injections.push(handle);\n                            }\n                        }\n                        for buffer in plain_text_buffers {\n                            this.detect_language_for_buffer(&buffer, cx);\n                            if let Some(local) = this.as_local_mut() {\n                                local.initialize_buffer(&buffer, cx);\n                                local.register_buffer_with_language_servers(&buffer, cx);\n<|editable_region_end|>\n                                local.initialize_buffer(&buffer, cx);\n```"
  },
  "max_tokens": 1024
}