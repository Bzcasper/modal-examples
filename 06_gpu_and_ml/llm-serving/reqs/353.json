{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -1,5 +1,5 @@\n use rope::Rope;\n-use std::{cmp, iter, ops::Range};\n+use std::{iter, ops::Range};\n use sum_tree::SumTree;\n use text::{Anchor, BufferSnapshot, OffsetRangeExt, Point};\n \n@@ -25,7 +25,7 @@\n }\n \n /// We store [`InternalDiffHunk`]s internally so we don't need to store the additional row range.\n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone)]\n struct InternalDiffHunk {\n     buffer_range: Range<Anchor>,\n     diff_base_byte_range: Range<usize>,\n@@ -188,69 +188,6 @@\n                 buffer_range: hunk.buffer_range.clone(),\n             })\n         })\n-    }\n-\n-    pub fn compare(&self, old: &Self, new_snapshot: &BufferSnapshot) -> Option<Range<Anchor>> {\n-        let mut new_cursor = self.tree.cursor::<()>(new_snapshot);\n-        let mut old_cursor = old.tree.cursor::<()>(new_snapshot);\n-        old_cursor.next(new_snapshot);\n-        new_cursor.next(new_snapshot);\n-        let mut start = None;\n-        let mut end = None;\n-\n-        loop {\n-            match (new_cursor.item(), old_cursor.item()) {\n-                (Some(new_hunk), Some(old_hunk)) => {\n-                    match new_hunk\n-                        .buffer_range\n-                        .start\n-                        .cmp(&old_hunk.buffer_range.start, new_snapshot)\n-                    {\n-                        cmp::Ordering::Less => {\n-                            start.get_or_insert(new_hunk.buffer_range.start);\n-                            end.replace(new_hunk.buffer_range.end);\n-                            new_cursor.next(new_snapshot);\n-                        }\n-                        cmp::Ordering::Equal => {\n-                            if new_hunk != old_hunk {\n-                                start.get_or_insert(new_hunk.buffer_range.start);\n-                                if old_hunk\n-                                    .buffer_range\n-                                    .end\n-                                    .cmp(&new_hunk.buffer_range.end, new_snapshot)\n-                                    .is_ge()\n-                                {\n-                                    end.replace(old_hunk.buffer_range.end);\n-                                } else {\n-                                    end.replace(new_hunk.buffer_range.end);\n-                                }\n-                            }\n-\n-                            new_cursor.next(new_snapshot);\n-                            old_cursor.next(new_snapshot);\n-                        }\n-                        cmp::Ordering::Greater => {\n-                            start.get_or_insert(old_hunk.buffer_range.start);\n-                            end.replace(old_hunk.buffer_range.end);\n-                            old_cursor.next(new_snapshot);\n-                        }\n-                    }\n-                }\n-                (Some(new_hunk), None) => {\n-                    start.get_or_insert(new_hunk.buffer_range.start);\n-                    end.replace(new_hunk.buffer_range.end);\n-                    new_cursor.next(new_snapshot);\n-                }\n-                (None, Some(old_hunk)) => {\n-                    start.get_or_insert(old_hunk.buffer_range.start);\n-                    end.replace(old_hunk.buffer_range.end);\n-                    old_cursor.next(new_snapshot);\n-                }\n-                (None, None) => break,\n-            }\n-        }\n-\n-        start.zip(end).map(|(start, end)| start..end)\n     }\n \n     #[cfg(test)]\n@@ -492,129 +429,5 @@\n                 (12..13, \"\", \"WORLD\\n\"),\n             ],\n         );\n-    }\n-\n-    #[test]\n-    fn test_buffer_diff_compare() {\n-        let base_text = \"\n-            zero\n-            one\n-            two\n-            three\n-            four\n-            five\n-            six\n-            seven\n-            eight\n-            nine\n-        \"\n-        .unindent();\n-\n-        let buffer_text_1 = \"\n-            one\n-            three\n-            four\n-            five\n-            SIX\n-            seven\n-            eight\n-            NINE\n-        \"\n-        .unindent();\n-\n-        let mut buffer = Buffer::new(0, BufferId::new(1).unwrap(), buffer_text_1);\n-\n-        let empty_diff = BufferDiff::new(&buffer);\n-        let diff_1 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_1.compare(&empty_diff, &buffer).unwrap();\n-        assert_eq!(range.to_point(&buffer), Point::new(0, 0)..Point::new(8, 0));\n-\n-        // Edit does not affect the diff.\n-        buffer.edit_via_marked_text(\n-            &\"\n-                one\n-                three\n-                four\n-                five\n-                «SIX.5»\n-                seven\n-                eight\n-                NINE\n-            \"\n-            .unindent(),\n-        );\n-        let diff_2 = BufferDiff::build(&base_text, &buffer);\n-        assert_eq!(None, diff_2.compare(&diff_1, &buffer));\n-\n-        // Edit turns a deletion hunk into a modification.\n-        buffer.edit_via_marked_text(\n-            &\"\n-                one\n-                «THREE»\n-                four\n-                five\n-                SIX.5\n-                seven\n-                eight\n-                NINE\n-            \"\n-            .unindent(),\n-        );\n-        let diff_3 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_3.compare(&diff_2, &buffer).unwrap();\n-        assert_eq!(range.to_point(&buffer), Point::new(1, 0)..Point::new(2, 0));\n-\n-        // Edit turns a modification hunk into a deletion.\n-        buffer.edit_via_marked_text(\n-            &\"\n-                one\n-                THREE\n-                four\n-                five«»\n-                seven\n-                eight\n-                NINE\n-            \"\n-            .unindent(),\n-        );\n-        let diff_4 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_4.compare(&diff_3, &buffer).unwrap();\n-        assert_eq!(range.to_point(&buffer), Point::new(3, 4)..Point::new(4, 0));\n-\n-        // Edit introduces a new insertion hunk.\n-        buffer.edit_via_marked_text(\n-            &\"\n-                one\n-                THREE\n-                four«\n-                FOUR.5\n-                »five\n-                seven\n-                eight\n-                NINE\n-            \"\n-            .unindent(),\n-        );\n-        let diff_5 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_5.compare(&diff_4, &buffer).unwrap();\n-        assert_eq!(range.to_point(&buffer), Point::new(3, 0)..Point::new(4, 0));\n-\n-        // Edit removes a hunk.\n-        buffer.edit_via_marked_text(\n-            &\"\n-                one\n-                THREE\n-                four\n-                FOUR.5\n-                five\n-                seven\n-                eight\n-                «nine»\n-            \"\n-            .unindent(),\n-        );\n-        let diff_6 = BufferDiff::build(&base_text, &buffer);\n-        let range = diff_6.compare(&diff_5, &buffer).unwrap();\n-        assert_eq!(range.to_point(&buffer), Point::new(7, 0)..Point::new(8, 0));\n     }\n }\n\n```\n\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -9,7 +9,6 @@\n pub mod lsp_store;\n pub mod prettier_store;\n pub mod project_settings;\n-mod project_tree;\n pub mod search;\n mod task_inventory;\n pub mod task_store;\n@@ -30,9 +29,7 @@\n use crate::git::GitState;\n use anyhow::{anyhow, Context as _, Result};\n use buffer_store::{BufferChangeSet, BufferStore, BufferStoreEvent};\n-use client::{\n-    proto, Client, Collaborator, PendingEntitySubscription, ProjectId, TypedEnvelope, UserStore,\n-};\n+use client::{proto, Client, Collaborator, PendingEntitySubscription, TypedEnvelope, UserStore};\n use clock::ReplicaId;\n use collections::{BTreeSet, HashMap, HashSet};\n use debounced_delay::DebouncedDelay;\n@@ -47,7 +44,7 @@\n \n use ::git::{\n     blame::Blame,\n-    repository::{Branch, GitRepository, RepoPath},\n+    repository::{Branch, GitRepository},\n     status::FileStatus,\n };\n use gpui::{\n@@ -284,7 +281,6 @@\n     RefreshInlayHints,\n     RevealInProjectPanel(ProjectEntryId),\n     SnippetEdit(BufferId, Vec<(lsp::Range, Snippet)>),\n-    ExpandedAllForEntry(WorktreeId, ProjectEntryId),\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, Hash, PartialOrd, Ord)]\n@@ -478,7 +474,6 @@\n pub struct Symbol {\n     pub language_server_name: LanguageServerName,\n     pub source_worktree_id: WorktreeId,\n-    pub source_language_server_id: LanguageServerId,\n     pub path: ProjectPath,\n     pub label: CodeLabel,\n     pub name: String,\n@@ -608,10 +603,6 @@\n         client.add_model_request_handler(Self::handle_open_new_buffer);\n         client.add_model_message_handler(Self::handle_create_buffer_for_peer);\n \n-        client.add_model_request_handler(Self::handle_stage);\n-        client.add_model_request_handler(Self::handle_unstage);\n-        client.add_model_request_handler(Self::handle_commit);\n-\n         WorktreeStore::init(&client);\n         BufferStore::init(&client);\n         LspStore::init(&client);\n@@ -701,9 +692,8 @@\n                 )\n             });\n \n-            let git_state = Some(\n-                cx.new(|cx| GitState::new(&worktree_store, languages.clone(), None, None, cx)),\n-            );\n+            let git_state =\n+                Some(cx.new(|cx| GitState::new(&worktree_store, languages.clone(), cx)));\n \n             cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n \n@@ -822,16 +812,6 @@\n                 )\n             });\n             cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n-\n-            let git_state = Some(cx.new(|cx| {\n-                GitState::new(\n-                    &worktree_store,\n-                    languages.clone(),\n-                    Some(ssh_proto.clone()),\n-                    Some(ProjectId(SSH_PROJECT_ID)),\n-                    cx,\n-                )\n-            }));\n \n             cx.subscribe(&ssh, Self::on_ssh_event).detach();\n             cx.observe(&ssh, |_, _, cx| cx.notify()).detach();\n@@ -845,7 +825,7 @@\n                 lsp_store,\n                 join_project_response_message_id: 0,\n                 client_state: ProjectClientState::Local,\n-                git_state,\n+                git_state: None,\n                 client_subscriptions: Vec::new(),\n                 _subscriptions: vec![\n                     cx.on_release(Self::release),\n@@ -888,7 +868,6 @@\n                 toolchain_store: Some(toolchain_store),\n             };\n \n-            // ssh -> local machine handlers\n             let ssh = ssh.read(cx);\n             ssh.subscribe_to_entity(SSH_PROJECT_ID, &cx.entity());\n             ssh.subscribe_to_entity(SSH_PROJECT_ID, &this.buffer_store);\n@@ -1029,17 +1008,6 @@\n             SettingsObserver::new_remote(worktree_store.clone(), task_store.clone(), cx)\n         })?;\n \n-        let git_state = Some(cx.new(|cx| {\n-            GitState::new(\n-                &worktree_store,\n-                languages.clone(),\n-                Some(client.clone().into()),\n-                Some(ProjectId(remote_id)),\n-                cx,\n-            )\n-        }))\n-        .transpose()?;\n-\n         let this = cx.new(|cx| {\n             let replica_id = response.payload.replica_id as ReplicaId;\n \n@@ -1090,7 +1058,7 @@\n                     remote_id,\n                     replica_id,\n                 },\n-                git_state,\n+                git_state: None,\n                 buffers_needing_diff: Default::default(),\n                 git_diff_debouncer: DebouncedDelay::new(),\n                 terminals: Terminals {\n@@ -1607,25 +1575,6 @@\n     ) -> Option<Task<Result<()>>> {\n         let worktree = self.worktree_for_id(worktree_id, cx)?;\n         worktree.update(cx, |worktree, cx| worktree.expand_entry(entry_id, cx))\n-    }\n-\n-    pub fn expand_all_for_entry(\n-        &mut self,\n-        worktree_id: WorktreeId,\n-        entry_id: ProjectEntryId,\n-        cx: &mut Context<Self>,\n-    ) -> Option<Task<Result<()>>> {\n-        let worktree = self.worktree_for_id(worktree_id, cx)?;\n-        let task = worktree.update(cx, |worktree, cx| {\n-            worktree.expand_all_for_entry(entry_id, cx)\n-        });\n-        Some(cx.spawn(|this, mut cx| async move {\n-            task.ok_or_else(|| anyhow!(\"no task\"))?.await?;\n-            this.update(&mut cx, |_, cx| {\n-                cx.emit(Event::ExpandedAllForEntry(worktree_id, entry_id));\n-            })?;\n-            Ok(())\n-        }))\n     }\n \n     pub fn shared(&mut self, project_id: u64, cx: &mut Context<Self>) -> Result<()> {\n@@ -1931,7 +1880,7 @@\n     pub fn open_buffer(\n         &mut self,\n         path: impl Into<ProjectPath>,\n-        cx: &mut App,\n+        cx: &mut Context<Self>,\n     ) -> Task<Result<Entity<Buffer>>> {\n         if self.is_disconnected(cx) {\n             return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n@@ -1946,11 +1895,11 @@\n     pub fn open_buffer_with_lsp(\n         &mut self,\n         path: impl Into<ProjectPath>,\n-        cx: &mut App,\n+        cx: &mut Context<Self>,\n     ) -> Task<Result<(Entity<Buffer>, lsp_store::OpenLspBufferHandle)>> {\n         let buffer = self.open_buffer(path, cx);\n         let lsp_store = self.lsp_store().clone();\n-        cx.spawn(|mut cx| async move {\n+        cx.spawn(|_, mut cx| async move {\n             let buffer = buffer.await?;\n             let handle = lsp_store.update(&mut cx, |lsp_store, cx| {\n                 lsp_store.register_buffer_with_language_servers(&buffer, cx)\n@@ -2618,7 +2567,7 @@\n         language_name: LanguageName,\n     ) -> Option<SharedString> {\n         languages\n-            .language_for_name(language_name.as_ref())\n+            .language_for_name(&language_name.0)\n             .await\n             .ok()?\n             .toolchain_lister()\n@@ -3982,124 +3931,7 @@\n \n         Project::respond_to_open_buffer_request(this, buffer, peer_id, &mut cx)\n     }\n-\n-    async fn handle_stage(\n-        this: Entity<Self>,\n-        envelope: TypedEnvelope<proto::Stage>,\n-        mut cx: AsyncApp,\n-    ) -> Result<proto::Ack> {\n-        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n-        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n-        let repository_handle = this.update(&mut cx, |project, cx| {\n-            let repository_handle = project\n-                .git_state()\n-                .context(\"missing git state\")?\n-                .read(cx)\n-                .all_repositories()\n-                .into_iter()\n-                .find(|repository_handle| {\n-                    repository_handle.worktree_id == worktree_id\n-                        && repository_handle.repository_entry.work_directory_id()\n-                            == work_directory_id\n-                })\n-                .context(\"missing repository handle\")?;\n-            anyhow::Ok(repository_handle)\n-        })??;\n \n-        let entries = envelope\n-            .payload\n-            .paths\n-            .into_iter()\n-            .map(PathBuf::from)\n-            .map(RepoPath::new)\n-            .collect();\n-        let (err_sender, mut err_receiver) = mpsc::channel(1);\n-        repository_handle\n-            .stage_entries(entries, err_sender)\n-            .context(\"staging entries\")?;\n-        if let Some(error) = err_receiver.next().await {\n-            Err(error.context(\"error during staging\"))\n-        } else {\n-            Ok(proto::Ack {})\n-        }\n-    }\n-\n-    async fn handle_unstage(\n-        this: Entity<Self>,\n-        envelope: TypedEnvelope<proto::Unstage>,\n-        mut cx: AsyncApp,\n-    ) -> Result<proto::Ack> {\n-        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n-        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n-        let repository_handle = this.update(&mut cx, |project, cx| {\n-            let repository_handle = project\n-                .git_state()\n-                .context(\"missing git state\")?\n-                .read(cx)\n-                .all_repositories()\n-                .into_iter()\n-                .find(|repository_handle| {\n-                    repository_handle.worktree_id == worktree_id\n-                        && repository_handle.repository_entry.work_directory_id()\n-                            == work_directory_id\n-                })\n-                .context(\"missing repository handle\")?;\n-            anyhow::Ok(repository_handle)\n-        })??;\n-\n-        let entries = envelope\n-            .payload\n-            .paths\n-            .into_iter()\n-            .map(PathBuf::from)\n-            .map(RepoPath::new)\n-            .collect();\n-        let (err_sender, mut err_receiver) = mpsc::channel(1);\n-        repository_handle\n-            .unstage_entries(entries, err_sender)\n-            .context(\"unstaging entries\")?;\n-        if let Some(error) = err_receiver.next().await {\n-            Err(error.context(\"error during unstaging\"))\n-        } else {\n-            Ok(proto::Ack {})\n-        }\n-    }\n-\n-    async fn handle_commit(\n-        this: Entity<Self>,\n-        envelope: TypedEnvelope<proto::Commit>,\n-        mut cx: AsyncApp,\n-    ) -> Result<proto::Ack> {\n-        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n-        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n-        let repository_handle = this.update(&mut cx, |project, cx| {\n-            let repository_handle = project\n-                .git_state()\n-                .context(\"missing git state\")?\n-                .read(cx)\n-                .all_repositories()\n-                .into_iter()\n-                .find(|repository_handle| {\n-                    repository_handle.worktree_id == worktree_id\n-                        && repository_handle.repository_entry.work_directory_id()\n-                            == work_directory_id\n-                })\n-                .context(\"missing repository handle\")?;\n-            anyhow::Ok(repository_handle)\n-        })??;\n-\n-        let commit_message = envelope.payload.message;\n-        let (err_sender, mut err_receiver) = mpsc::channel(1);\n-        repository_handle\n-            .commit_with_message(commit_message, err_sender)\n-            .context(\"unstaging entries\")?;\n-        if let Some(error) = err_receiver.next().await {\n-            Err(error.context(\"error during unstaging\"))\n-        } else {\n-            Ok(proto::Ack {})\n-        }\n-    }\n-\n     fn respond_to_open_buffer_request(\n         this: Entity<Self>,\n         buffer: Entity<Buffer>,\n@@ -4287,25 +4119,14 @@\n         self.lsp_store.read(cx).supplementary_language_servers()\n     }\n \n-    pub fn language_server_for_id(\n-        &self,\n-        id: LanguageServerId,\n-        cx: &App,\n-    ) -> Option<Arc<LanguageServer>> {\n-        self.lsp_store.read(cx).language_server_for_id(id)\n-    }\n-\n-    pub fn for_language_servers_for_local_buffer<R: 'static>(\n-        &self,\n-        buffer: &Buffer,\n-        callback: impl FnOnce(\n-            Box<dyn Iterator<Item = (&Arc<CachedLspAdapter>, &Arc<LanguageServer>)> + '_>,\n-        ) -> R,\n-        cx: &mut App,\n-    ) -> R {\n-        self.lsp_store.update(cx, |this, cx| {\n-            callback(Box::new(this.language_servers_for_local_buffer(buffer, cx)))\n-        })\n+    pub fn language_servers_for_local_buffer<'a>(\n+        &'a self,\n+        buffer: &'a Buffer,\n+        cx: &'a App,\n+    ) -> impl Iterator<Item = (&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n+        self.lsp_store\n+            .read(cx)\n+            .language_servers_for_local_buffer(buffer, cx)\n     }\n \n     pub fn buffer_store(&self) -> &Entity<BufferStore> {\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -21,7 +21,7 @@\n     TextDimension, TextObject, ToOffset as _, ToPoint as _, TransactionId, TreeSitterOptions,\n     Unclipped,\n };\n-use project::buffer_store::{BufferChangeSet, BufferChangeSetEvent};\n+use project::buffer_store::BufferChangeSet;\n use rope::DimensionPair;\n use smallvec::SmallVec;\n use smol::future::yield_now;\n@@ -91,7 +91,6 @@\n     ExcerptsEdited {\n         ids: Vec<ExcerptId>,\n     },\n-    DiffHunksToggled,\n     Edited {\n         singleton_buffer_edited: bool,\n         edited_buffer: Option<Entity<Buffer>>,\n@@ -435,6 +434,7 @@\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum DiffChangeKind {\n     BufferEdited,\n+    ExcerptsChanged,\n     DiffUpdated { base_changed: bool },\n     ExpandOrCollapseHunks { expand: bool },\n }\n@@ -546,14 +546,8 @@\n             diff_bases.insert(\n                 *buffer_id,\n                 ChangeSetState {\n-                    _subscription: new_cx.subscribe(\n-                        &change_set_state.change_set,\n-                        |this, change_set, event, cx| match event {\n-                            BufferChangeSetEvent::DiffChanged { changed_range } => {\n-                                this.buffer_diff_changed(change_set, changed_range.clone(), cx)\n-                            }\n-                        },\n-                    ),\n+                    _subscription: new_cx\n+                        .observe(&change_set_state.change_set, Self::buffer_diff_changed),\n                     change_set: change_set_state.change_set.clone(),\n                 },\n             );\n@@ -1609,7 +1603,7 @@\n                 old: edit_start..edit_start,\n                 new: edit_start..edit_end,\n             }],\n-            DiffChangeKind::BufferEdited,\n+            DiffChangeKind::ExcerptsChanged,\n         );\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n@@ -1642,7 +1636,7 @@\n                 old: start..prev_len,\n                 new: start..start,\n             }],\n-            DiffChangeKind::BufferEdited,\n+            DiffChangeKind::ExcerptsChanged,\n         );\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n@@ -1915,7 +1909,7 @@\n             snapshot.trailing_excerpt_update_count += 1;\n         }\n \n-        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::BufferEdited);\n+        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::ExcerptsChanged);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2004,26 +1998,22 @@\n         });\n     }\n \n-    fn buffer_diff_changed(\n-        &mut self,\n-        change_set: Entity<BufferChangeSet>,\n-        range: Range<text::Anchor>,\n-        cx: &mut Context<Self>,\n-    ) {\n+    fn buffer_diff_changed(&mut self, change_set: Entity<BufferChangeSet>, cx: &mut Context<Self>) {\n         let change_set = change_set.read(cx);\n         let buffer_id = change_set.buffer_id;\n         let diff = change_set.diff_to_buffer.clone();\n         let base_text = change_set.base_text.clone();\n         self.sync(cx);\n         let mut snapshot = self.snapshot.borrow_mut();\n-        let base_text_changed = snapshot\n-            .diffs\n-            .get(&buffer_id)\n-            .map_or(true, |diff_snapshot| {\n-                change_set.base_text.as_ref().map_or(true, |base_text| {\n-                    base_text.remote_id() != diff_snapshot.base_text.remote_id()\n-                })\n-            });\n+        let base_text_version_changed =\n+            snapshot\n+                .diffs\n+                .get(&buffer_id)\n+                .map_or(true, |diff_snapshot| {\n+                    change_set.base_text.as_ref().map_or(true, |base_text| {\n+                        base_text.remote_id() != diff_snapshot.base_text.remote_id()\n+                    })\n+                });\n \n         if let Some(base_text) = base_text {\n             snapshot.diffs.insert(\n@@ -2036,44 +2026,26 @@\n         } else {\n             snapshot.diffs.remove(&buffer_id);\n         }\n-        let buffers = self.buffers.borrow();\n-        let Some(buffer_state) = buffers.get(&buffer_id) else {\n-            return;\n-        };\n \n-        let diff_change_range = range.to_offset(buffer_state.buffer.read(cx));\n-\n         let mut excerpt_edits = Vec::new();\n-        for locator in &buffer_state.excerpts {\n+        for locator in self\n+            .buffers\n+            .borrow()\n+            .get(&buffer_id)\n+            .map(|state| &state.excerpts)\n+            .into_iter()\n+            .flatten()\n+        {\n             let mut cursor = snapshot\n                 .excerpts\n                 .cursor::<(Option<&Locator>, ExcerptOffset)>(&());\n             cursor.seek_forward(&Some(locator), Bias::Left, &());\n             if let Some(excerpt) = cursor.item() {\n                 if excerpt.locator == *locator {\n-                    let excerpt_buffer_range = excerpt.range.context.to_offset(&excerpt.buffer);\n-                    if diff_change_range.end < excerpt_buffer_range.start\n-                        || diff_change_range.start > excerpt_buffer_range.end\n-                    {\n-                        continue;\n-                    }\n-                    let excerpt_start = cursor.start().1;\n-                    let excerpt_len = ExcerptOffset::new(excerpt.text_summary.len);\n-                    let diff_change_start_in_excerpt = ExcerptOffset::new(\n-                        diff_change_range\n-                            .start\n-                            .saturating_sub(excerpt_buffer_range.start),\n-                    );\n-                    let diff_change_end_in_excerpt = ExcerptOffset::new(\n-                        diff_change_range\n-                            .end\n-                            .saturating_sub(excerpt_buffer_range.start),\n-                    );\n-                    let edit_start = excerpt_start + diff_change_start_in_excerpt.min(excerpt_len);\n-                    let edit_end = excerpt_start + diff_change_end_in_excerpt.min(excerpt_len);\n+                    let excerpt_range = cursor.start().1..cursor.end(&()).1;\n                     excerpt_edits.push(Edit {\n-                        old: edit_start..edit_end,\n-                        new: edit_start..edit_end,\n+                        old: excerpt_range.clone(),\n+                        new: excerpt_range.clone(),\n                     });\n                 }\n             }\n@@ -2083,7 +2055,7 @@\n             snapshot,\n             excerpt_edits,\n             DiffChangeKind::DiffUpdated {\n-                base_changed: base_text_changed,\n+                base_changed: base_text_version_changed,\n             },\n         );\n         cx.emit(Event::Edited {\n@@ -2173,18 +2145,11 @@\n \n     pub fn add_change_set(&mut self, change_set: Entity<BufferChangeSet>, cx: &mut Context<Self>) {\n         let buffer_id = change_set.read(cx).buffer_id;\n-        self.buffer_diff_changed(change_set.clone(), text::Anchor::MIN..text::Anchor::MAX, cx);\n+        self.buffer_diff_changed(change_set.clone(), cx);\n         self.diff_bases.insert(\n             buffer_id,\n             ChangeSetState {\n-                _subscription: cx.subscribe(\n-                    &change_set,\n-                    |this, change_set, event, cx| match event {\n-                        BufferChangeSetEvent::DiffChanged { changed_range } => {\n-                            this.buffer_diff_changed(change_set, changed_range.clone(), cx);\n-                        }\n-                    },\n-                ),\n+                _subscription: cx.observe(&change_set, Self::buffer_diff_changed),\n                 change_set,\n             },\n         );\n@@ -2253,34 +2218,46 @@\n         let snapshot = self.snapshot.borrow_mut();\n         let mut excerpt_edits = Vec::new();\n         for range in ranges.iter() {\n-            let end_excerpt_id = range.end.excerpt_id;\n             let range = range.to_point(&snapshot);\n-            let mut peek_end = range.end;\n-            if range.end.row < snapshot.max_row().0 {\n-                peek_end = Point::new(range.end.row + 1, 0);\n+\n+            let mut start = snapshot.anchor_before(Point::new(range.start.row, 0));\n+            let mut end = snapshot.anchor_before(Point::new(\n+                range.end.row,\n+                snapshot.line_len(MultiBufferRow(range.end.row)),\n+            ));\n+            let peek_end = if range.end.row < snapshot.max_row().0 {\n+                Point::new(range.end.row + 1, 0)\n+            } else {\n+                range.end\n             };\n \n             for diff_hunk in snapshot.diff_hunks_in_range(range.start..peek_end) {\n-                if diff_hunk.excerpt_id.cmp(&end_excerpt_id, &snapshot).is_gt() {\n-                    continue;\n+                if diff_hunk.row_range.start.0 <= range.start.row\n+                    && diff_hunk.row_range.end.0 >= range.start.row\n+                    && diff_hunk.excerpt_id == start.excerpt_id\n+                {\n+                    start = Anchor::in_buffer(\n+                        diff_hunk.excerpt_id,\n+                        diff_hunk.buffer_id,\n+                        diff_hunk.buffer_range.start,\n+                    );\n                 }\n-                let start = Anchor::in_buffer(\n-                    diff_hunk.excerpt_id,\n-                    diff_hunk.buffer_id,\n-                    diff_hunk.buffer_range.start,\n-                );\n-                let end = Anchor::in_buffer(\n-                    diff_hunk.excerpt_id,\n-                    diff_hunk.buffer_id,\n-                    diff_hunk.buffer_range.end,\n-                );\n-                let start = snapshot.excerpt_offset_for_anchor(&start);\n-                let end = snapshot.excerpt_offset_for_anchor(&end);\n-                excerpt_edits.push(text::Edit {\n-                    old: start..end,\n-                    new: start..end,\n-                });\n+                if diff_hunk.row_range.start.0 <= peek_end.row\n+                    && diff_hunk.excerpt_id == end.excerpt_id\n+                {\n+                    end = Anchor::in_buffer(\n+                        diff_hunk.excerpt_id,\n+                        diff_hunk.buffer_id,\n+                        diff_hunk.buffer_range.end,\n+                    );\n+                }\n             }\n+            let start = snapshot.excerpt_offset_for_anchor(&start);\n+            let end = snapshot.excerpt_offset_for_anchor(&end);\n+            excerpt_edits.push(text::Edit {\n+                old: start..end,\n+                new: start..end,\n+            });\n         }\n \n         self.sync_diff_transforms(\n@@ -2288,7 +2265,6 @@\n             excerpt_edits,\n             DiffChangeKind::ExpandOrCollapseHunks { expand },\n         );\n-        cx.emit(Event::DiffHunksToggled);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2353,7 +2329,7 @@\n         drop(cursor);\n         snapshot.excerpts = new_excerpts;\n \n-        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::BufferEdited);\n+        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::ExcerptsChanged);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2454,7 +2430,7 @@\n         drop(cursor);\n         snapshot.excerpts = new_excerpts;\n \n-        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::BufferEdited);\n+        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::ExcerptsChanged);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2619,52 +2595,63 @@\n             let edit_old_start = old_diff_transforms.start().1 + edit_start_overshoot;\n             let edit_new_start = (edit_old_start as isize + output_delta) as usize;\n \n-            let changed_diff_hunks = self.recompute_diff_transforms_for_edit(\n-                &edit,\n-                &mut excerpts,\n-                &mut old_diff_transforms,\n-                &mut new_diff_transforms,\n-                &mut end_of_current_insert,\n-                &mut old_expanded_hunks,\n+            if change_kind == DiffChangeKind::BufferEdited {\n+                self.interpolate_diff_transforms_for_edit(\n+                    &edit,\n+                    &excerpts,\n+                    &mut old_diff_transforms,\n+                    &mut new_diff_transforms,\n+                    &mut end_of_current_insert,\n+                );\n+            } else {\n+                self.recompute_diff_transforms_for_edit(\n+                    &edit,\n+                    &mut excerpts,\n+                    &mut old_diff_transforms,\n+                    &mut new_diff_transforms,\n+                    &mut end_of_current_insert,\n+                    &mut old_expanded_hunks,\n+                    &snapshot,\n+                    change_kind,\n+                );\n+            }\n+\n+            self.push_buffer_content_transform(\n                 &snapshot,\n-                change_kind,\n+                &mut new_diff_transforms,\n+                edit.new.end,\n+                end_of_current_insert,\n             );\n \n             // Compute the end of the edit in output coordinates.\n-            let edit_old_end_overshoot = edit.old.end - old_diff_transforms.start().0;\n-            let edit_new_end_overshoot = edit.new.end - new_diff_transforms.summary().excerpt_len();\n-            let edit_old_end = old_diff_transforms.start().1 + edit_old_end_overshoot.value;\n-            let edit_new_end =\n-                new_diff_transforms.summary().output.len + edit_new_end_overshoot.value;\n+            let edit_end_overshoot = (edit.old.end - old_diff_transforms.start().0).value;\n+            let edit_old_end = old_diff_transforms.start().1 + edit_end_overshoot;\n+            let edit_new_end = new_diff_transforms.summary().output.len;\n             let output_edit = Edit {\n                 old: edit_old_start..edit_old_end,\n                 new: edit_new_start..edit_new_end,\n             };\n \n-            output_delta += (output_edit.new.end - output_edit.new.start) as isize;\n-            output_delta -= (output_edit.old.end - output_edit.old.start) as isize;\n-            if changed_diff_hunks || matches!(change_kind, DiffChangeKind::BufferEdited) {\n-                output_edits.push(output_edit);\n-            }\n+            output_delta += (output_edit.new.end - output_edit.new.start) as isize\n+                - (output_edit.old.end - output_edit.old.start) as isize;\n+            output_edits.push(output_edit);\n \n             // If this is the last edit that intersects the current diff transform,\n-            // then recreate the content up to the end of this transform, to prepare\n-            // for reusing additional slices of the old transforms.\n+            // then preserve a suffix of the this diff transform.\n             if excerpt_edits.peek().map_or(true, |next_edit| {\n                 next_edit.old.start >= old_diff_transforms.end(&()).0\n             }) {\n-                let mut excerpt_offset = edit.new.end;\n                 if old_diff_transforms.start().0 < edit.old.end {\n-                    excerpt_offset += old_diff_transforms.end(&()).0 - edit.old.end;\n+                    let suffix = old_diff_transforms.end(&()).0 - edit.old.end;\n+                    let transform_end = new_diff_transforms.summary().excerpt_len() + suffix;\n+                    self.push_buffer_content_transform(\n+                        &snapshot,\n+                        &mut new_diff_transforms,\n+                        transform_end,\n+                        end_of_current_insert,\n+                    );\n                     old_diff_transforms.next(&());\n                 }\n-                old_expanded_hunks.clear();\n-                self.push_buffer_content_transform(\n-                    &snapshot,\n-                    &mut new_diff_transforms,\n-                    excerpt_offset,\n-                    end_of_current_insert,\n-                );\n                 at_transform_boundary = true;\n             }\n         }\n@@ -2704,7 +2691,7 @@\n         old_expanded_hunks: &mut HashSet<(ExcerptId, text::Anchor)>,\n         snapshot: &MultiBufferSnapshot,\n         change_kind: DiffChangeKind,\n-    ) -> bool {\n+    ) {\n         log::trace!(\n             \"recomputing diff transform for edit {:?} => {:?}\",\n             edit.old.start.value..edit.old.end.value,\n@@ -2712,7 +2699,11 @@\n         );\n \n         // Record which hunks were previously expanded.\n+        old_expanded_hunks.clear();\n         while let Some(item) = old_diff_transforms.item() {\n+            if old_diff_transforms.end(&()).0 > edit.old.end {\n+                break;\n+            }\n             if let Some(hunk_anchor) = item.hunk_anchor() {\n                 log::trace!(\n                     \"previously expanded hunk at {}\",\n@@ -2720,22 +2711,10 @@\n                 );\n                 old_expanded_hunks.insert(hunk_anchor);\n             }\n-            if old_diff_transforms.end(&()).0 > edit.old.end {\n-                break;\n-            }\n             old_diff_transforms.next(&());\n         }\n \n-        // Avoid querying diff hunks if there's no possibility of hunks being expanded.\n-        if old_expanded_hunks.is_empty()\n-            && change_kind == DiffChangeKind::BufferEdited\n-            && !self.all_diff_hunks_expanded\n-        {\n-            return false;\n-        }\n-\n         // Visit each excerpt that intersects the edit.\n-        let mut did_expand_hunks = false;\n         while let Some(excerpt) = excerpts.item() {\n             if excerpt.text_summary.len == 0 {\n                 if excerpts.end(&()) <= edit.new.end {\n@@ -2775,10 +2754,8 @@\n                         + ExcerptOffset::new(\n                             hunk_buffer_range.start.saturating_sub(excerpt_buffer_start),\n                         );\n-                    let hunk_excerpt_end = excerpt_end.min(\n-                        excerpt_start\n-                            + ExcerptOffset::new(hunk_buffer_range.end - excerpt_buffer_start),\n-                    );\n+                    let hunk_excerpt_end = excerpt_start\n+                        + ExcerptOffset::new(hunk_buffer_range.end - excerpt_buffer_start);\n \n                     self.push_buffer_content_transform(\n                         snapshot,\n@@ -2810,11 +2787,7 @@\n                     };\n \n                     if should_expand_hunk {\n-                        did_expand_hunks = true;\n-                        log::trace!(\n-                            \"expanding hunk {:?}\",\n-                            hunk_excerpt_start.value..hunk_excerpt_end.value,\n-                        );\n+                        log::trace!(\"expanding hunk at {}\", hunk_excerpt_start.value);\n \n                         if !hunk.diff_base_byte_range.is_empty()\n                             && hunk_buffer_range.start >= edit_buffer_start\n@@ -2860,8 +2833,68 @@\n                 break;\n             }\n         }\n+    }\n+\n+    fn interpolate_diff_transforms_for_edit(\n+        &self,\n+        edit: &Edit<TypedOffset<Excerpt>>,\n+        excerpts: &Cursor<Excerpt, TypedOffset<Excerpt>>,\n+        old_diff_transforms: &mut Cursor<DiffTransform, (TypedOffset<Excerpt>, usize)>,\n+        new_diff_transforms: &mut SumTree<DiffTransform>,\n+        end_of_current_insert: &mut Option<(TypedOffset<Excerpt>, ExcerptId, text::Anchor)>,\n+    ) {\n+        log::trace!(\n+            \"interpolating diff transform for edit {:?} => {:?}\",\n+            edit.old.start.value..edit.old.end.value,\n+            edit.new.start.value..edit.new.end.value\n+        );\n+\n+        // Preserve deleted hunks immediately preceding edits.\n+        if let Some(transform) = old_diff_transforms.item() {\n+            if old_diff_transforms.start().0 == edit.old.start {\n+                if let DiffTransform::DeletedHunk { hunk_anchor, .. } = transform {\n+                    if excerpts\n+                        .item()\n+                        .map_or(false, |excerpt| hunk_anchor.1.is_valid(&excerpt.buffer))\n+                    {\n+                        self.push_diff_transform(new_diff_transforms, transform.clone());\n+                        old_diff_transforms.next(&());\n+                    }\n+                }\n+            }\n+        }\n+\n+        let edit_start_transform = old_diff_transforms.item();\n+\n+        // When an edit starts within an inserted hunks, extend the hunk\n+        // to include the lines of the edit.\n+        if let Some((\n+            DiffTransform::BufferContent {\n+                inserted_hunk_anchor: Some(inserted_hunk_anchor),\n+                ..\n+            },\n+            excerpt,\n+        )) = edit_start_transform.zip(excerpts.item())\n+        {\n+            let buffer = &excerpt.buffer;\n+            if inserted_hunk_anchor.1.is_valid(buffer) {\n+                let excerpt_start = *excerpts.start();\n+                let excerpt_end = excerpt_start + ExcerptOffset::new(excerpt.text_summary.len);\n+                let excerpt_buffer_start = excerpt.range.context.start.to_offset(buffer);\n+                let edit_buffer_end =\n+                    excerpt_buffer_start + edit.new.end.value.saturating_sub(excerpt_start.value);\n+                let edit_buffer_end_point = buffer.offset_to_point(edit_buffer_end);\n+                let edited_buffer_line_end =\n+                    buffer.point_to_offset(edit_buffer_end_point + Point::new(1, 0));\n+                let edited_line_end = excerpt_start\n+                    + ExcerptOffset::new(edited_buffer_line_end - excerpt_buffer_start);\n+                let hunk_end = edited_line_end.min(excerpt_end);\n+                *end_of_current_insert =\n+                    Some((hunk_end, inserted_hunk_anchor.0, inserted_hunk_anchor.1));\n+            }\n+        }\n \n-        did_expand_hunks || !old_expanded_hunks.is_empty()\n+        old_diff_transforms.seek_forward(&edit.old.end, Bias::Right, &());\n     }\n \n     fn append_diff_transforms(\n@@ -3374,49 +3407,6 @@\n             cursor.next();\n         }\n         result\n-    }\n-\n-    pub fn range_to_buffer_ranges_with_deleted_hunks<T: ToOffset>(\n-        &self,\n-        range: Range<T>,\n-    ) -> impl Iterator<Item = (&BufferSnapshot, Range<usize>, ExcerptId, Option<Anchor>)> + '_ {\n-        let start = range.start.to_offset(&self);\n-        let end = range.end.to_offset(&self);\n-\n-        let mut cursor = self.cursor::<usize>();\n-        cursor.seek(&start);\n-\n-        std::iter::from_fn(move || {\n-            let region = cursor.region()?;\n-            if region.range.start > end {\n-                return None;\n-            }\n-            let start_overshoot = start.saturating_sub(region.range.start);\n-            let end_overshoot = end.saturating_sub(region.range.start);\n-            let start = region\n-                .buffer_range\n-                .end\n-                .min(region.buffer_range.start + start_overshoot);\n-            let end = region\n-                .buffer_range\n-                .end\n-                .min(region.buffer_range.start + end_overshoot);\n-\n-            let region_excerpt_id = region.excerpt.id;\n-            let deleted_hunk_anchor = if region.is_main_buffer {\n-                None\n-            } else {\n-                Some(self.anchor_before(region.range.start))\n-            };\n-            let result = (\n-                region.buffer,\n-                start..end,\n-                region_excerpt_id,\n-                deleted_hunk_anchor,\n-            );\n-            cursor.next();\n-            Some(result)\n-        })\n     }\n \n     /// Retrieves buffer metadata for the given range, and converts it into multi-buffer\n@@ -3451,8 +3441,10 @@\n         while let Some(region) = cursor.region() {\n             if region.is_main_buffer {\n                 let mut buffer_end = region.buffer_range.start.key;\n-                let overshoot = range.end.saturating_sub(region.range.start.key);\n-                buffer_end.add_assign(&overshoot);\n+                if region.is_main_buffer {\n+                    let overshoot = range.end.saturating_sub(region.range.start.key);\n+                    buffer_end.add_assign(&overshoot);\n+                }\n                 range_end = Some((region.excerpt.id, buffer_end));\n                 break;\n             }\n@@ -3463,10 +3455,6 @@\n             key: range.start,\n             value: None,\n         });\n-\n-        if cursor.region().is_some_and(|region| !region.is_main_buffer) {\n-            cursor.prev();\n-        }\n \n         iter::from_fn(move || loop {\n             let excerpt = cursor.excerpt()?;\n@@ -3510,9 +3498,8 @@\n                 // the metadata item's range.\n                 if range.start > D::default() {\n                     while let Some(region) = cursor.region() {\n-                        if !region.is_main_buffer\n-                            || region.buffer.remote_id() == excerpt.buffer_id\n-                                && region.buffer_range.end.value.unwrap() < range.start\n+                        if region.buffer.remote_id() == excerpt.buffer_id\n+                            && region.buffer_range.end.value.unwrap() < range.start\n                         {\n                             cursor.next();\n                         } else {\n@@ -4248,7 +4235,36 @@\n     where\n         D: TextDimension + Ord + Sub<D, Output = D>,\n     {\n-        self.summaries_for_anchors([anchor])[0]\n+        let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n+        let locator = self.excerpt_locator_for_id(anchor.excerpt_id);\n+\n+        cursor.seek(locator, Bias::Left, &());\n+        if cursor.item().is_none() {\n+            cursor.next(&());\n+        }\n+\n+        let mut excerpt_position = D::from_text_summary(&cursor.start().text);\n+        if let Some(excerpt) = cursor.item() {\n+            if excerpt.id == anchor.excerpt_id {\n+                let excerpt_buffer_start =\n+                    excerpt.range.context.start.summary::<D>(&excerpt.buffer);\n+                let excerpt_buffer_end = excerpt.range.context.end.summary::<D>(&excerpt.buffer);\n+                let buffer_position = cmp::min(\n+                    excerpt_buffer_end,\n+                    anchor.text_anchor.summary::<D>(&excerpt.buffer),\n+                );\n+                if buffer_position > excerpt_buffer_start {\n+                    excerpt_position.add_assign(&(buffer_position - excerpt_buffer_start));\n+                }\n+            }\n+        }\n+\n+        let mut diff_transforms_cursor = self\n+            .diff_transforms\n+            .cursor::<(ExcerptDimension<D>, OutputDimension<D>)>(&());\n+        diff_transforms_cursor.seek(&ExcerptDimension(excerpt_position), Bias::Left, &());\n+\n+        self.resolve_summary_for_anchor(anchor, excerpt_position, &mut diff_transforms_cursor)\n     }\n \n     fn resolve_summary_for_anchor<D>(\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11111,7 +11111,6 @@\n         0,\n         \"Should not restart LSP server on an unrelated LSP settings change\"\n     );\n-\n     update_test_project_settings(cx, |project_settings| {\n         project_settings.lsp.insert(\n             language_server_name.into(),\n@@ -14393,8 +14392,17 @@\n \n         editor.buffer().update(cx, |multibuffer, cx| {\n             let buffer = multibuffer.as_singleton().unwrap();\n+<<<<<<< HEAD\n             let change_set =\n                 cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n+=======\n+            let change_set = cx.new(|cx| {\n+                let mut change_set = BufferChangeSet::new(&buffer, cx);\n+                let _ =\n+                    change_set.set_base_text(base_text.into(), buffer.read(cx).text_snapshot(), cx);\n+                change_set\n+            });\n+>>>>>>> origin/main\n \n             multibuffer.set_all_diff_hunks_expanded(cx);\n             multibuffer.add_change_set(change_set, cx);\n@@ -14402,6 +14410,7 @@\n             buffer.read(cx).remote_id()\n         })\n     });\n+    cx.run_until_parked();\n \n     cx.assert_state_with_diff(\n         indoc! { \"\n\n```\n\nUser edited \"crates/git/src/diff.rs\":\n```diff\n@@ -1,5 +1,5 @@\n use rope::Rope;\n-use std::{iter, ops::Range};\n+use std::{cmp, iter, ops::Range};\n use sum_tree::SumTree;\n use text::{Anchor, BufferSnapshot, OffsetRangeExt, Point};\n \n@@ -25,7 +25,7 @@\n }\n \n /// We store [`InternalDiffHunk`]s internally so we don't need to store the additional row range.\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n struct InternalDiffHunk {\n     buffer_range: Range<Anchor>,\n     diff_base_byte_range: Range<usize>,\n@@ -190,6 +190,69 @@\n         })\n     }\n \n+    pub fn compare(&self, old: &Self, new_snapshot: &BufferSnapshot) -> Option<Range<Anchor>> {\n+        let mut new_cursor = self.tree.cursor::<()>(new_snapshot);\n+        let mut old_cursor = old.tree.cursor::<()>(new_snapshot);\n+        old_cursor.next(new_snapshot);\n+        new_cursor.next(new_snapshot);\n+        let mut start = None;\n+        let mut end = None;\n+\n+        loop {\n+            match (new_cursor.item(), old_cursor.item()) {\n+                (Some(new_hunk), Some(old_hunk)) => {\n+                    match new_hunk\n+                        .buffer_range\n+                        .start\n+                        .cmp(&old_hunk.buffer_range.start, new_snapshot)\n+                    {\n+                        cmp::Ordering::Less => {\n+                            start.get_or_insert(new_hunk.buffer_range.start);\n+                            end.replace(new_hunk.buffer_range.end);\n+                            new_cursor.next(new_snapshot);\n+                        }\n+                        cmp::Ordering::Equal => {\n+                            if new_hunk != old_hunk {\n+                                start.get_or_insert(new_hunk.buffer_range.start);\n+                                if old_hunk\n+                                    .buffer_range\n+                                    .end\n+                                    .cmp(&new_hunk.buffer_range.end, new_snapshot)\n+                                    .is_ge()\n+                                {\n+                                    end.replace(old_hunk.buffer_range.end);\n+                                } else {\n+                                    end.replace(new_hunk.buffer_range.end);\n+                                }\n+                            }\n+\n+                            new_cursor.next(new_snapshot);\n+                            old_cursor.next(new_snapshot);\n+                        }\n+                        cmp::Ordering::Greater => {\n+                            start.get_or_insert(old_hunk.buffer_range.start);\n+                            end.replace(old_hunk.buffer_range.end);\n+                            old_cursor.next(new_snapshot);\n+                        }\n+                    }\n+                }\n+                (Some(new_hunk), None) => {\n+                    start.get_or_insert(new_hunk.buffer_range.start);\n+                    end.replace(new_hunk.buffer_range.end);\n+                    new_cursor.next(new_snapshot);\n+                }\n+                (None, Some(old_hunk)) => {\n+                    start.get_or_insert(old_hunk.buffer_range.start);\n+                    end.replace(old_hunk.buffer_range.end);\n+                    old_cursor.next(new_snapshot);\n+                }\n+                (None, None) => break,\n+            }\n+        }\n+\n+        start.zip(end).map(|(start, end)| start..end)\n+    }\n+\n     #[cfg(test)]\n     fn clear(&mut self, buffer: &text::BufferSnapshot) {\n         self.tree = SumTree::new(buffer);\n@@ -430,4 +493,128 @@\n             ],\n         );\n     }\n+\n+    #[test]\n+    fn test_buffer_diff_compare() {\n+        let base_text = \"\n+            zero\n+            one\n+            two\n+            three\n+            four\n+            five\n+            six\n+            seven\n+            eight\n+            nine\n+        \"\n+        .unindent();\n+\n+        let buffer_text_1 = \"\n+            one\n+            three\n+            four\n+            five\n+            SIX\n+            seven\n+            eight\n+            NINE\n+        \"\n+        .unindent();\n+\n+        let mut buffer = Buffer::new(0, BufferId::new(1).unwrap(), buffer_text_1);\n+\n+        let empty_diff = BufferDiff::new(&buffer);\n+        let diff_1 = BufferDiff::build(&base_text, &buffer);\n+        let range = diff_1.compare(&empty_diff, &buffer).unwrap();\n+        assert_eq!(range.to_point(&buffer), Point::new(0, 0)..Point::new(8, 0));\n+\n+        // Edit does not affect the diff.\n+        buffer.edit_via_marked_text(\n+            &\"\n+                one\n+                three\n+                four\n+                five\n+                «SIX.5»\n+                seven\n+                eight\n+                NINE\n+            \"\n+            .unindent(),\n+        );\n+        let diff_2 = BufferDiff::build(&base_text, &buffer);\n+        assert_eq!(None, diff_2.compare(&diff_1, &buffer));\n+\n+        // Edit turns a deletion hunk into a modification.\n+        buffer.edit_via_marked_text(\n+            &\"\n+                one\n+                «THREE»\n+                four\n+                five\n+                SIX.5\n+                seven\n+                eight\n+                NINE\n+            \"\n+            .unindent(),\n+        );\n+        let diff_3 = BufferDiff::build(&base_text, &buffer);\n+        let range = diff_3.compare(&diff_2, &buffer).unwrap();\n+        assert_eq!(range.to_point(&buffer), Point::new(1, 0)..Point::new(2, 0));\n+\n+        // Edit turns a modification hunk into a deletion.\n+        buffer.edit_via_marked_text(\n+            &\"\n+                one\n+                THREE\n+                four\n+                five«»\n+                seven\n+                eight\n+                NINE\n+            \"\n+            .unindent(),\n+        );\n+        let diff_4 = BufferDiff::build(&base_text, &buffer);\n+        let range = diff_4.compare(&diff_3, &buffer).unwrap();\n+        assert_eq!(range.to_point(&buffer), Point::new(3, 4)..Point::new(4, 0));\n+\n+        // Edit introduces a new insertion hunk.\n+        buffer.edit_via_marked_text(\n+            &\"\n+                one\n+                THREE\n+                four«\n+                FOUR.5\n+                »five\n+                seven\n+                eight\n+                NINE\n+            \"\n+            .unindent(),\n+        );\n+        let diff_5 = BufferDiff::build(&base_text, &buffer);\n+        let range = diff_5.compare(&diff_4, &buffer).unwrap();\n+        assert_eq!(range.to_point(&buffer), Point::new(3, 0)..Point::new(4, 0));\n+\n+        // Edit removes a hunk.\n+        buffer.edit_via_marked_text(\n+            &\"\n+                one\n+                THREE\n+                four\n+                FOUR.5\n+                five\n+                seven\n+                eight\n+                «nine»\n+            \"\n+            .unindent(),\n+        );\n+        let diff_6 = BufferDiff::build(&base_text, &buffer);\n+        let range = diff_6.compare(&diff_5, &buffer).unwrap();\n+        assert_eq!(range.to_point(&buffer), Point::new(7, 0)..Point::new(8, 0));\n+    }\n }\n\n```\n\nUser edited \"crates/project/src/project_tests.rs\":\n```diff\n@@ -1749,6 +1749,12 @@\n             });\n         })\n     });\n+    let _rs_buffer = project\n+        .update(cx, |project, cx| {\n+            project.open_local_buffer_with_lsp(\"/dir/a.rs\", cx)\n+        })\n+        .await\n+        .unwrap();\n     let mut fake_rust_server_2 = fake_rust_servers.next().await.unwrap();\n     assert_eq!(\n         fake_rust_server_2\n@@ -2573,25 +2579,28 @@\n     fs.insert_tree(\n         \"/dir\",\n         json!({\n-            \"a.rs\": \"const fn a() { A }\",\n             \"b.rs\": \"const y: i32 = crate::a()\",\n         }),\n     )\n     .await;\n+    fs.insert_tree(\n+        \"/another_dir\",\n+        json!({\n+        \"a.rs\": \"const fn a() { A }\"}),\n+    )\n+    .await;\n \n-    let project = Project::test(fs, [\"/dir/b.rs\".as_ref()], cx).await;\n+    let project = Project::test(fs, [\"/dir\".as_ref()], cx).await;\n \n     let language_registry = project.read_with(cx, |project, _| project.languages().clone());\n     language_registry.add(rust_lang());\n     let mut fake_servers = language_registry.register_fake_lsp(\"Rust\", FakeLspAdapter::default());\n-\n     let (buffer, _handle) = project\n         .update(cx, |project, cx| {\n             project.open_local_buffer_with_lsp(\"/dir/b.rs\", cx)\n         })\n         .await\n         .unwrap();\n-\n     let fake_server = fake_servers.next().await.unwrap();\n     fake_server.handle_request::<lsp::request::GotoDefinition, _, _>(|params, _| async move {\n         let params = params.text_document_position_params;\n@@ -2603,12 +2612,11 @@\n \n         Ok(Some(lsp::GotoDefinitionResponse::Scalar(\n             lsp::Location::new(\n-                lsp::Url::from_file_path(\"/dir/a.rs\").unwrap(),\n+                lsp::Url::from_file_path(\"/another_dir/a.rs\").unwrap(),\n                 lsp::Range::new(lsp::Position::new(0, 9), lsp::Position::new(0, 10)),\n             ),\n         )))\n     });\n-\n     let mut definitions = project\n         .update(cx, |project, cx| project.definition(&buffer, 22, cx))\n         .await\n@@ -2629,18 +2637,21 @@\n                 .as_local()\n                 .unwrap()\n                 .abs_path(cx),\n-            Path::new(\"/dir/a.rs\"),\n+            Path::new(\"/another_dir/a.rs\"),\n         );\n         assert_eq!(definition.target.range.to_offset(target_buffer), 9..10);\n         assert_eq!(\n             list_worktrees(&project, cx),\n-            [(\"/dir/a.rs\".as_ref(), false), (\"/dir/b.rs\".as_ref(), true)],\n+            [\n+                (\"/another_dir/a.rs\".as_ref(), false),\n+                (\"/dir\".as_ref(), true)\n+            ],\n         );\n \n         drop(definition);\n     });\n     cx.update(|cx| {\n-        assert_eq!(list_worktrees(&project, cx), [(\"/dir/b.rs\".as_ref(), true)]);\n+        assert_eq!(list_worktrees(&project, cx), [(\"/dir\".as_ref(), true)]);\n     });\n \n     fn list_worktrees<'a>(project: &'a Entity<Project>, cx: &'a App) -> Vec<(&'a Path, bool)> {\n\n```\n\nUser edited \"crates/project/src/buffer_store.rs\":\n```diff\n@@ -377,6 +377,10 @@\n     pub staged_diff: Option<BufferDiff>,\n }\n \n+pub enum BufferChangeSetEvent {\n+    DiffChanged { changed_range: Range<text::Anchor> },\n+}\n+\n enum BufferStoreState {\n     Local(LocalBufferStore),\n     Remote(RemoteBufferStore),\n@@ -2758,6 +2762,8 @@\n     }\n }\n \n+impl EventEmitter<BufferChangeSetEvent> for BufferChangeSet {}\n+\n impl BufferChangeSet {\n     pub fn diff_hunks_intersecting_range<'a>(\n         &'a self,\n@@ -2826,6 +2832,7 @@\n         }\n     }\n \n+<<<<<<< HEAD\n     #[cfg(any(test, feature = \"test-support\"))]\n     pub fn new_with_base_text(base_text: &str, buffer: &Entity<Buffer>, cx: &mut App) -> Self {\n         let diff_to_buffer = BufferDiff::build(Some(base_text), &buffer.read(cx).text_snapshot());\n@@ -2848,6 +2855,76 @@\n                 .as_deref(),\n             &snapshot,\n         );\n+=======\n+    pub fn recalculate_diff(\n+        &mut self,\n+        buffer_snapshot: text::BufferSnapshot,\n+        cx: &mut Context<Self>,\n+    ) -> oneshot::Receiver<()> {\n+        if let Some(base_text) = self.base_text.clone() {\n+            self.recalculate_diff_internal(base_text.text(), buffer_snapshot, false, cx)\n+        } else {\n+            oneshot::channel().1\n+        }\n+    }\n+\n+    fn recalculate_diff_internal(\n+        &mut self,\n+        base_text: String,\n+        buffer_snapshot: text::BufferSnapshot,\n+        base_text_changed: bool,\n+        cx: &mut Context<Self>,\n+    ) -> oneshot::Receiver<()> {\n+        let (tx, rx) = oneshot::channel();\n+        self.diff_updated_futures.push(tx);\n+        self.recalculate_diff_task = Some(cx.spawn(|this, mut cx| async move {\n+            let (old_diff, new_base_text) = this.update(&mut cx, |this, cx| {\n+                let new_base_text = if base_text_changed {\n+                    let base_text_rope: Rope = base_text.as_str().into();\n+                    let snapshot = language::Buffer::build_snapshot(\n+                        base_text_rope,\n+                        this.language.clone(),\n+                        this.language_registry.clone(),\n+                        cx,\n+                    );\n+                    cx.background_executor()\n+                        .spawn(async move { Some(snapshot.await) })\n+                } else {\n+                    Task::ready(None)\n+                };\n+                (this.diff_to_buffer.clone(), new_base_text)\n+            })?;\n+\n+            let diff = cx.background_executor().spawn(async move {\n+                let new_diff = BufferDiff::build(&base_text, &buffer_snapshot);\n+                let changed_range = if base_text_changed {\n+                    Some(text::Anchor::MIN..text::Anchor::MAX)\n+                } else {\n+                    new_diff.compare(&old_diff, &buffer_snapshot)\n+                };\n+                (new_diff, changed_range)\n+            });\n+\n+            let (new_base_text, (diff, changed_range)) = futures::join!(new_base_text, diff);\n+\n+            this.update(&mut cx, |this, cx| {\n+                if let Some(new_base_text) = new_base_text {\n+                    this.base_text = Some(new_base_text)\n+                }\n+                this.diff_to_buffer = diff;\n+\n+                this.recalculate_diff_task.take();\n+                for tx in this.diff_updated_futures.drain(..) {\n+                    tx.send(()).ok();\n+                }\n+                if let Some(changed_range) = changed_range {\n+                    cx.emit(BufferChangeSetEvent::DiffChanged { changed_range });\n+                }\n+            })?;\n+            Ok(())\n+        }));\n+        rx\n+>>>>>>> origin/main\n     }\n }\n \n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer_tests.rs\":\n```diff\n@@ -354,11 +354,21 @@\n }\n \n #[gpui::test]\n-fn test_diff_boundary_anchors(cx: &mut App) {\n+fn test_diff_boundary_anchors(cx: &mut TestAppContext) {\n     let base_text = \"one\\ntwo\\nthree\\n\";\n     let text = \"one\\nthree\\n\";\n     let buffer = cx.new(|cx| Buffer::local(text, cx));\n+<<<<<<< HEAD\n     let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n+=======\n+    let snapshot = buffer.read_with(cx, |buffer, _| buffer.snapshot());\n+    let change_set = cx.new(|cx| {\n+        let mut change_set = BufferChangeSet::new(&buffer, cx);\n+        let _ = change_set.set_base_text(base_text.into(), snapshot.text, cx);\n+        change_set\n+    });\n+    cx.run_until_parked();\n+>>>>>>> origin/main\n     let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n     multibuffer.update(cx, |multibuffer, cx| {\n         multibuffer.add_change_set(change_set, cx)\n@@ -370,9 +380,9 @@\n         multibuffer.set_all_diff_hunks_expanded(cx);\n         (before, after)\n     });\n-    cx.background_executor().run_until_parked();\n+    cx.run_until_parked();\n \n-    let snapshot = multibuffer.read(cx).snapshot(cx);\n+    let snapshot = multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n     let actual_text = snapshot.text();\n     let actual_row_infos = snapshot.row_infos(MultiBufferRow(0)).collect::<Vec<_>>();\n     let actual_diff = format_diff(&actual_text, &actual_row_infos, &Default::default());\n@@ -402,7 +412,17 @@\n     let base_text = \"one\\ntwo\\nthree\\nfour\\nfive\\nsix\\nseven\\neight\\n\";\n     let text = \"one\\nfour\\nseven\\n\";\n     let buffer = cx.new(|cx| Buffer::local(text, cx));\n+<<<<<<< HEAD\n     let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n+=======\n+    let change_set = cx.new(|cx| {\n+        let mut change_set = BufferChangeSet::new(&buffer, cx);\n+        let snapshot = buffer.read(cx).snapshot();\n+        let _ = change_set.set_base_text(base_text.into(), snapshot.text, cx);\n+        change_set\n+    });\n+    cx.run_until_parked();\n+>>>>>>> origin/main\n     let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n     let (mut snapshot, mut subscription) = multibuffer.update(cx, |multibuffer, cx| {\n         (multibuffer.snapshot(cx), multibuffer.subscribe())\n@@ -495,7 +515,17 @@\n     let base_text = \"one\\ntwo\\nfour\\nfive\\nsix\\nseven\\n\";\n     let text = \"one\\ntwo\\nTHREE\\nfour\\nfive\\nseven\\n\";\n     let buffer = cx.new(|cx| Buffer::local(text, cx));\n+<<<<<<< HEAD\n     let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(&base_text, &buffer, cx));\n+=======\n+    let change_set = cx.new(|cx| {\n+        let mut change_set = BufferChangeSet::new(&buffer, cx);\n+        let snapshot = buffer.read(cx).text_snapshot();\n+        let _ = change_set.set_base_text(base_text.into(), snapshot, cx);\n+        change_set\n+    });\n+    cx.run_until_parked();\n+>>>>>>> origin/main\n     let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer.clone(), cx));\n \n     let (mut snapshot, mut subscription) = multibuffer.update(cx, |multibuffer, cx| {\n@@ -571,9 +601,12 @@\n     );\n \n     multibuffer.update(cx, |multibuffer, cx| multibuffer.undo(cx));\n+<<<<<<< HEAD\n     change_set.update(cx, |change_set, cx| {\n         change_set.recalculate_diff_sync(buffer.read(cx).text_snapshot());\n     });\n+=======\n+>>>>>>> origin/main\n     assert_new_snapshot(\n         &multibuffer,\n         &mut snapshot,\n@@ -1837,7 +1870,7 @@\n                 .buffer_range\n                 .end\n                 .cmp(&excerpt.range.start, &buffer)\n-                .is_le();\n+                .is_lt();\n             let hunk_follows_excerpt = hunk\n                 .buffer_range\n                 .start\n@@ -2040,7 +2073,7 @@\n }\n \n #[gpui::test(iterations = 100)]\n-fn test_random_multibuffer(cx: &mut App, mut rng: StdRng) {\n+async fn test_random_multibuffer(cx: &mut TestAppContext, mut rng: StdRng) {\n     let operations = env::var(\"OPERATIONS\")\n         .map(|i| i.parse().expect(\"invalid `OPERATIONS` variable\"))\n         .unwrap_or(10);\n@@ -2061,7 +2094,7 @@\n                     buf.randomly_edit(&mut rng, edit_count, cx);\n                     needs_diff_calculation = true;\n                 });\n-                reference.diffs_updated(cx);\n+                cx.update(|cx| reference.diffs_updated(cx));\n             }\n             15..=19 if !reference.excerpts.is_empty() => {\n                 multibuffer.update(cx, |multibuffer, cx| {\n@@ -2095,10 +2128,11 @@\n                         break;\n                     };\n                     let id = excerpt.id;\n-                    reference.remove_excerpt(id, cx);\n+                    cx.update(|cx| reference.remove_excerpt(id, cx));\n                     ids_to_remove.push(id);\n                 }\n-                let snapshot = multibuffer.read(cx).read(cx);\n+                let snapshot =\n+                    multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n                 ids_to_remove.sort_unstable_by(|a, b| a.cmp(b, &snapshot));\n                 drop(snapshot);\n                 multibuffer.update(cx, |multibuffer, cx| {\n@@ -2106,7 +2140,8 @@\n                 });\n             }\n             30..=39 if !reference.excerpts.is_empty() => {\n-                let multibuffer = multibuffer.read(cx).read(cx);\n+                let multibuffer =\n+                    multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n                 let offset =\n                     multibuffer.clip_offset(rng.gen_range(0..=multibuffer.len()), Bias::Left);\n                 let bias = if rng.gen() { Bias::Left } else { Bias::Right };\n@@ -2115,7 +2150,8 @@\n                 anchors.sort_by(|a, b| a.cmp(b, &multibuffer));\n             }\n             40..=44 if !anchors.is_empty() => {\n-                let multibuffer = multibuffer.read(cx).read(cx);\n+                let multibuffer =\n+                    multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n                 let prev_len = anchors.len();\n                 anchors = multibuffer\n                     .refresh_anchors(&anchors)\n@@ -2165,7 +2201,11 @@\n                                     \"recalculating diff for buffer {:?}\",\n                                     snapshot.remote_id(),\n                                 );\n+<<<<<<< HEAD\n                                 change_set.recalculate_diff_sync(snapshot.text);\n+=======\n+                                change_set.recalculate_diff(snapshot.text, cx)\n+>>>>>>> origin/main\n                             });\n                     }\n                     reference.diffs_updated(cx);\n@@ -2179,11 +2219,22 @@\n                         .collect::<String>();\n \n                     let buffer = cx.new(|cx| Buffer::local(base_text.clone(), cx));\n+<<<<<<< HEAD\n                     let change_set =\n                         cx.new(|cx| BufferChangeSet::new_with_base_text(&base_text, &buffer, cx));\n+=======\n+                    let change_set = cx.new(|cx| BufferChangeSet::new(&buffer, cx));\n+                    change_set\n+                        .update(cx, |change_set, cx| {\n+                            let snapshot = buffer.read(cx).snapshot();\n+                            change_set.set_base_text(base_text, snapshot.text, cx)\n+                        })\n+                        .await\n+                        .unwrap();\n+>>>>>>> origin/main\n \n-                    reference.add_change_set(change_set.clone(), cx);\n                     multibuffer.update(cx, |multibuffer, cx| {\n+                        reference.add_change_set(change_set.clone(), cx);\n                         multibuffer.add_change_set(change_set, cx)\n                     });\n                     buffers.push(buffer);\n@@ -2192,12 +2243,6 @@\n                     buffers.choose(&mut rng).unwrap()\n                 };\n \n-                let buffer = buffer_handle.read(cx);\n-                let end_row = rng.gen_range(0..=buffer.max_point().row);\n-                let start_row = rng.gen_range(0..=end_row);\n-                let end_ix = buffer.point_to_offset(Point::new(end_row, 0));\n-                let start_ix = buffer.point_to_offset(Point::new(start_row, 0));\n-                let anchor_range = buffer.anchor_before(start_ix)..buffer.anchor_after(end_ix);\n                 let prev_excerpt_ix = rng.gen_range(0..=reference.excerpts.len());\n                 let prev_excerpt_id = reference\n                     .excerpts\n@@ -2205,23 +2250,33 @@\n                     .map_or(ExcerptId::max(), |e| e.id);\n                 let excerpt_ix = (prev_excerpt_ix + 1).min(reference.excerpts.len());\n \n-                log::info!(\n-                    \"Inserting excerpt at {} of {} for buffer {}: {:?}[{:?}] = {:?}\",\n-                    excerpt_ix,\n-                    reference.excerpts.len(),\n-                    buffer_handle.read(cx).remote_id(),\n-                    buffer.text(),\n-                    start_ix..end_ix,\n-                    &buffer.text()[start_ix..end_ix]\n-                );\n+                let (range, anchor_range) = buffer_handle.read_with(cx, |buffer, _| {\n+                    let end_row = rng.gen_range(0..=buffer.max_point().row);\n+                    let start_row = rng.gen_range(0..=end_row);\n+                    let end_ix = buffer.point_to_offset(Point::new(end_row, 0));\n+                    let start_ix = buffer.point_to_offset(Point::new(start_row, 0));\n+                    let anchor_range = buffer.anchor_before(start_ix)..buffer.anchor_after(end_ix);\n+\n+                    log::info!(\n+                        \"Inserting excerpt at {} of {} for buffer {}: {:?}[{:?}] = {:?}\",\n+                        excerpt_ix,\n+                        reference.excerpts.len(),\n+                        buffer.remote_id(),\n+                        buffer.text(),\n+                        start_ix..end_ix,\n+                        &buffer.text()[start_ix..end_ix]\n+                    );\n \n+                    (start_ix..end_ix, anchor_range)\n+                });\n+\n                 let excerpt_id = multibuffer.update(cx, |multibuffer, cx| {\n                     multibuffer\n                         .insert_excerpts_after(\n                             prev_excerpt_id,\n                             buffer_handle.clone(),\n                             [ExcerptRange {\n-                                context: start_ix..end_ix,\n+                                context: range,\n                                 primary: None,\n                             }],\n                             cx,\n@@ -2244,7 +2299,7 @@\n             })\n         }\n \n-        let snapshot = multibuffer.read(cx).snapshot(cx);\n+        let snapshot = multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n         let actual_text = snapshot.text();\n         let actual_boundary_rows = snapshot\n             .excerpt_boundaries_in_range(0..)\n@@ -2254,7 +2309,7 @@\n         let actual_diff = format_diff(&actual_text, &actual_row_infos, &actual_boundary_rows);\n \n         let (expected_text, expected_row_infos, expected_boundary_rows) =\n-            reference.expected_content(cx);\n+            cx.update(|cx| reference.expected_content(cx));\n         let expected_diff =\n             format_diff(&expected_text, &expected_row_infos, &expected_boundary_rows);\n \n@@ -2371,7 +2426,7 @@\n         }\n     }\n \n-    let snapshot = multibuffer.read(cx).snapshot(cx);\n+    let snapshot = multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n     for (old_snapshot, subscription) in old_versions {\n         let edits = subscription.consume().into_inner();\n \n\n```\n\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -9,6 +9,7 @@\n pub mod lsp_store;\n pub mod prettier_store;\n pub mod project_settings;\n+mod project_tree;\n pub mod search;\n mod task_inventory;\n pub mod task_store;\n@@ -29,7 +30,9 @@\n use crate::git::GitState;\n use anyhow::{anyhow, Context as _, Result};\n use buffer_store::{BufferChangeSet, BufferStore, BufferStoreEvent};\n-use client::{proto, Client, Collaborator, PendingEntitySubscription, TypedEnvelope, UserStore};\n+use client::{\n+    proto, Client, Collaborator, PendingEntitySubscription, ProjectId, TypedEnvelope, UserStore,\n+};\n use clock::ReplicaId;\n use collections::{BTreeSet, HashMap, HashSet};\n use debounced_delay::DebouncedDelay;\n@@ -44,7 +47,7 @@\n \n use ::git::{\n     blame::Blame,\n-    repository::{Branch, GitRepository},\n+    repository::{Branch, GitRepository, RepoPath},\n     status::FileStatus,\n };\n use gpui::{\n@@ -281,6 +284,7 @@\n     RefreshInlayHints,\n     RevealInProjectPanel(ProjectEntryId),\n     SnippetEdit(BufferId, Vec<(lsp::Range, Snippet)>),\n+    ExpandedAllForEntry(WorktreeId, ProjectEntryId),\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, Hash, PartialOrd, Ord)]\n@@ -474,6 +478,7 @@\n pub struct Symbol {\n     pub language_server_name: LanguageServerName,\n     pub source_worktree_id: WorktreeId,\n+    pub source_language_server_id: LanguageServerId,\n     pub path: ProjectPath,\n     pub label: CodeLabel,\n     pub name: String,\n@@ -603,6 +608,10 @@\n         client.add_model_request_handler(Self::handle_open_new_buffer);\n         client.add_model_message_handler(Self::handle_create_buffer_for_peer);\n \n+        client.add_model_request_handler(Self::handle_stage);\n+        client.add_model_request_handler(Self::handle_unstage);\n+        client.add_model_request_handler(Self::handle_commit);\n+\n         WorktreeStore::init(&client);\n         BufferStore::init(&client);\n         LspStore::init(&client);\n@@ -692,8 +701,9 @@\n                 )\n             });\n \n-            let git_state =\n-                Some(cx.new(|cx| GitState::new(&worktree_store, languages.clone(), cx)));\n+            let git_state = Some(\n+                cx.new(|cx| GitState::new(&worktree_store, languages.clone(), None, None, cx)),\n+            );\n \n             cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n \n@@ -813,6 +823,16 @@\n             });\n             cx.subscribe(&lsp_store, Self::on_lsp_store_event).detach();\n \n+            let git_state = Some(cx.new(|cx| {\n+                GitState::new(\n+                    &worktree_store,\n+                    languages.clone(),\n+                    Some(ssh_proto.clone()),\n+                    Some(ProjectId(SSH_PROJECT_ID)),\n+                    cx,\n+                )\n+            }));\n+\n             cx.subscribe(&ssh, Self::on_ssh_event).detach();\n             cx.observe(&ssh, |_, _, cx| cx.notify()).detach();\n \n@@ -825,7 +845,7 @@\n                 lsp_store,\n                 join_project_response_message_id: 0,\n                 client_state: ProjectClientState::Local,\n-                git_state: None,\n+                git_state,\n                 client_subscriptions: Vec::new(),\n                 _subscriptions: vec![\n                     cx.on_release(Self::release),\n@@ -868,6 +888,7 @@\n                 toolchain_store: Some(toolchain_store),\n             };\n \n+            // ssh -> local machine handlers\n             let ssh = ssh.read(cx);\n             ssh.subscribe_to_entity(SSH_PROJECT_ID, &cx.entity());\n             ssh.subscribe_to_entity(SSH_PROJECT_ID, &this.buffer_store);\n@@ -1008,6 +1029,17 @@\n             SettingsObserver::new_remote(worktree_store.clone(), task_store.clone(), cx)\n         })?;\n \n+        let git_state = Some(cx.new(|cx| {\n+            GitState::new(\n+                &worktree_store,\n+                languages.clone(),\n+                Some(client.clone().into()),\n+                Some(ProjectId(remote_id)),\n+                cx,\n+            )\n+        }))\n+        .transpose()?;\n+\n         let this = cx.new(|cx| {\n             let replica_id = response.payload.replica_id as ReplicaId;\n \n@@ -1058,7 +1090,7 @@\n                     remote_id,\n                     replica_id,\n                 },\n-                git_state: None,\n+                git_state,\n                 buffers_needing_diff: Default::default(),\n                 git_diff_debouncer: DebouncedDelay::new(),\n                 terminals: Terminals {\n@@ -1577,6 +1609,25 @@\n         worktree.update(cx, |worktree, cx| worktree.expand_entry(entry_id, cx))\n     }\n \n+    pub fn expand_all_for_entry(\n+        &mut self,\n+        worktree_id: WorktreeId,\n+        entry_id: ProjectEntryId,\n+        cx: &mut Context<Self>,\n+    ) -> Option<Task<Result<()>>> {\n+        let worktree = self.worktree_for_id(worktree_id, cx)?;\n+        let task = worktree.update(cx, |worktree, cx| {\n+            worktree.expand_all_for_entry(entry_id, cx)\n+        });\n+        Some(cx.spawn(|this, mut cx| async move {\n+            task.ok_or_else(|| anyhow!(\"no task\"))?.await?;\n+            this.update(&mut cx, |_, cx| {\n+                cx.emit(Event::ExpandedAllForEntry(worktree_id, entry_id));\n+            })?;\n+            Ok(())\n+        }))\n+    }\n+\n     pub fn shared(&mut self, project_id: u64, cx: &mut Context<Self>) -> Result<()> {\n         if !matches!(self.client_state, ProjectClientState::Local) {\n             return Err(anyhow!(\"project was already shared\"));\n@@ -1880,7 +1931,7 @@\n     pub fn open_buffer(\n         &mut self,\n         path: impl Into<ProjectPath>,\n-        cx: &mut Context<Self>,\n+        cx: &mut App,\n     ) -> Task<Result<Entity<Buffer>>> {\n         if self.is_disconnected(cx) {\n             return Task::ready(Err(anyhow!(ErrorCode::Disconnected)));\n@@ -1895,11 +1946,11 @@\n     pub fn open_buffer_with_lsp(\n         &mut self,\n         path: impl Into<ProjectPath>,\n-        cx: &mut Context<Self>,\n+        cx: &mut App,\n     ) -> Task<Result<(Entity<Buffer>, lsp_store::OpenLspBufferHandle)>> {\n         let buffer = self.open_buffer(path, cx);\n         let lsp_store = self.lsp_store().clone();\n-        cx.spawn(|_, mut cx| async move {\n+        cx.spawn(|mut cx| async move {\n             let buffer = buffer.await?;\n             let handle = lsp_store.update(&mut cx, |lsp_store, cx| {\n                 lsp_store.register_buffer_with_language_servers(&buffer, cx)\n@@ -2567,7 +2618,7 @@\n         language_name: LanguageName,\n     ) -> Option<SharedString> {\n         languages\n-            .language_for_name(&language_name.0)\n+            .language_for_name(language_name.as_ref())\n             .await\n             .ok()?\n             .toolchain_lister()\n@@ -3932,6 +3983,123 @@\n         Project::respond_to_open_buffer_request(this, buffer, peer_id, &mut cx)\n     }\n \n+    async fn handle_stage(\n+        this: Entity<Self>,\n+        envelope: TypedEnvelope<proto::Stage>,\n+        mut cx: AsyncApp,\n+    ) -> Result<proto::Ack> {\n+        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n+        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n+        let repository_handle = this.update(&mut cx, |project, cx| {\n+            let repository_handle = project\n+                .git_state()\n+                .context(\"missing git state\")?\n+                .read(cx)\n+                .all_repositories()\n+                .into_iter()\n+                .find(|repository_handle| {\n+                    repository_handle.worktree_id == worktree_id\n+                        && repository_handle.repository_entry.work_directory_id()\n+                            == work_directory_id\n+                })\n+                .context(\"missing repository handle\")?;\n+            anyhow::Ok(repository_handle)\n+        })??;\n+\n+        let entries = envelope\n+            .payload\n+            .paths\n+            .into_iter()\n+            .map(PathBuf::from)\n+            .map(RepoPath::new)\n+            .collect();\n+        let (err_sender, mut err_receiver) = mpsc::channel(1);\n+        repository_handle\n+            .stage_entries(entries, err_sender)\n+            .context(\"staging entries\")?;\n+        if let Some(error) = err_receiver.next().await {\n+            Err(error.context(\"error during staging\"))\n+        } else {\n+            Ok(proto::Ack {})\n+        }\n+    }\n+\n+    async fn handle_unstage(\n+        this: Entity<Self>,\n+        envelope: TypedEnvelope<proto::Unstage>,\n+        mut cx: AsyncApp,\n+    ) -> Result<proto::Ack> {\n+        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n+        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n+        let repository_handle = this.update(&mut cx, |project, cx| {\n+            let repository_handle = project\n+                .git_state()\n+                .context(\"missing git state\")?\n+                .read(cx)\n+                .all_repositories()\n+                .into_iter()\n+                .find(|repository_handle| {\n+                    repository_handle.worktree_id == worktree_id\n+                        && repository_handle.repository_entry.work_directory_id()\n+                            == work_directory_id\n+                })\n+                .context(\"missing repository handle\")?;\n+            anyhow::Ok(repository_handle)\n+        })??;\n+\n+        let entries = envelope\n+            .payload\n+            .paths\n+            .into_iter()\n+            .map(PathBuf::from)\n+            .map(RepoPath::new)\n+            .collect();\n+        let (err_sender, mut err_receiver) = mpsc::channel(1);\n+        repository_handle\n+            .unstage_entries(entries, err_sender)\n+            .context(\"unstaging entries\")?;\n+        if let Some(error) = err_receiver.next().await {\n+            Err(error.context(\"error during unstaging\"))\n+        } else {\n+            Ok(proto::Ack {})\n+        }\n+    }\n+\n+    async fn handle_commit(\n+        this: Entity<Self>,\n+        envelope: TypedEnvelope<proto::Commit>,\n+        mut cx: AsyncApp,\n+    ) -> Result<proto::Ack> {\n+        let worktree_id = WorktreeId::from_proto(envelope.payload.worktree_id);\n+        let work_directory_id = ProjectEntryId::from_proto(envelope.payload.work_directory_id);\n+        let repository_handle = this.update(&mut cx, |project, cx| {\n+            let repository_handle = project\n+                .git_state()\n+                .context(\"missing git state\")?\n+                .read(cx)\n+                .all_repositories()\n+                .into_iter()\n+                .find(|repository_handle| {\n+                    repository_handle.worktree_id == worktree_id\n+                        && repository_handle.repository_entry.work_directory_id()\n+                            == work_directory_id\n+                })\n+                .context(\"missing repository handle\")?;\n+            anyhow::Ok(repository_handle)\n+        })??;\n+\n+        let commit_message = envelope.payload.message;\n+        let (err_sender, mut err_receiver) = mpsc::channel(1);\n+        repository_handle\n+            .commit_with_message(commit_message, err_sender)\n+            .context(\"unstaging entries\")?;\n+        if let Some(error) = err_receiver.next().await {\n+            Err(error.context(\"error during unstaging\"))\n+        } else {\n+            Ok(proto::Ack {})\n+        }\n+    }\n+\n     fn respond_to_open_buffer_request(\n         this: Entity<Self>,\n         buffer: Entity<Buffer>,\n@@ -4119,14 +4287,25 @@\n         self.lsp_store.read(cx).supplementary_language_servers()\n     }\n \n-    pub fn language_servers_for_local_buffer<'a>(\n-        &'a self,\n-        buffer: &'a Buffer,\n-        cx: &'a App,\n-    ) -> impl Iterator<Item = (&'a Arc<CachedLspAdapter>, &'a Arc<LanguageServer>)> {\n-        self.lsp_store\n-            .read(cx)\n-            .language_servers_for_local_buffer(buffer, cx)\n+    pub fn language_server_for_id(\n+        &self,\n+        id: LanguageServerId,\n+        cx: &App,\n+    ) -> Option<Arc<LanguageServer>> {\n+        self.lsp_store.read(cx).language_server_for_id(id)\n+    }\n+\n+    pub fn for_language_servers_for_local_buffer<R: 'static>(\n+        &self,\n+        buffer: &Buffer,\n+        callback: impl FnOnce(\n+            Box<dyn Iterator<Item = (&Arc<CachedLspAdapter>, &Arc<LanguageServer>)> + '_>,\n+        ) -> R,\n+        cx: &mut App,\n+    ) -> R {\n+        self.lsp_store.update(cx, |this, cx| {\n+            callback(Box::new(this.language_servers_for_local_buffer(buffer, cx)))\n+        })\n     }\n \n     pub fn buffer_store(&self) -> &Entity<BufferStore> {\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer.rs\":\n```diff\n@@ -21,7 +21,7 @@\n     TextDimension, TextObject, ToOffset as _, ToPoint as _, TransactionId, TreeSitterOptions,\n     Unclipped,\n };\n-use project::buffer_store::BufferChangeSet;\n+use project::buffer_store::{BufferChangeSet, BufferChangeSetEvent};\n use rope::DimensionPair;\n use smallvec::SmallVec;\n use smol::future::yield_now;\n@@ -91,6 +91,7 @@\n     ExcerptsEdited {\n         ids: Vec<ExcerptId>,\n     },\n+    DiffHunksToggled,\n     Edited {\n         singleton_buffer_edited: bool,\n         edited_buffer: Option<Entity<Buffer>>,\n@@ -434,7 +435,6 @@\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum DiffChangeKind {\n     BufferEdited,\n-    ExcerptsChanged,\n     DiffUpdated { base_changed: bool },\n     ExpandOrCollapseHunks { expand: bool },\n }\n@@ -546,8 +546,14 @@\n             diff_bases.insert(\n                 *buffer_id,\n                 ChangeSetState {\n-                    _subscription: new_cx\n-                        .observe(&change_set_state.change_set, Self::buffer_diff_changed),\n+                    _subscription: new_cx.subscribe(\n+                        &change_set_state.change_set,\n+                        |this, change_set, event, cx| match event {\n+                            BufferChangeSetEvent::DiffChanged { changed_range } => {\n+                                this.buffer_diff_changed(change_set, changed_range.clone(), cx)\n+                            }\n+                        },\n+                    ),\n                     change_set: change_set_state.change_set.clone(),\n                 },\n             );\n@@ -1603,7 +1609,7 @@\n                 old: edit_start..edit_start,\n                 new: edit_start..edit_end,\n             }],\n-            DiffChangeKind::ExcerptsChanged,\n+            DiffChangeKind::BufferEdited,\n         );\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n@@ -1636,7 +1642,7 @@\n                 old: start..prev_len,\n                 new: start..start,\n             }],\n-            DiffChangeKind::ExcerptsChanged,\n+            DiffChangeKind::BufferEdited,\n         );\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n@@ -1909,7 +1915,7 @@\n             snapshot.trailing_excerpt_update_count += 1;\n         }\n \n-        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::ExcerptsChanged);\n+        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::BufferEdited);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -1998,22 +2004,26 @@\n         });\n     }\n \n-    fn buffer_diff_changed(&mut self, change_set: Entity<BufferChangeSet>, cx: &mut Context<Self>) {\n+    fn buffer_diff_changed(\n+        &mut self,\n+        change_set: Entity<BufferChangeSet>,\n+        range: Range<text::Anchor>,\n+        cx: &mut Context<Self>,\n+    ) {\n         let change_set = change_set.read(cx);\n         let buffer_id = change_set.buffer_id;\n         let diff = change_set.diff_to_buffer.clone();\n         let base_text = change_set.base_text.clone();\n         self.sync(cx);\n         let mut snapshot = self.snapshot.borrow_mut();\n-        let base_text_version_changed =\n-            snapshot\n-                .diffs\n-                .get(&buffer_id)\n-                .map_or(true, |diff_snapshot| {\n-                    change_set.base_text.as_ref().map_or(true, |base_text| {\n-                        base_text.remote_id() != diff_snapshot.base_text.remote_id()\n-                    })\n-                });\n+        let base_text_changed = snapshot\n+            .diffs\n+            .get(&buffer_id)\n+            .map_or(true, |diff_snapshot| {\n+                change_set.base_text.as_ref().map_or(true, |base_text| {\n+                    base_text.remote_id() != diff_snapshot.base_text.remote_id()\n+                })\n+            });\n \n         if let Some(base_text) = base_text {\n             snapshot.diffs.insert(\n@@ -2026,26 +2036,44 @@\n         } else {\n             snapshot.diffs.remove(&buffer_id);\n         }\n+        let buffers = self.buffers.borrow();\n+        let Some(buffer_state) = buffers.get(&buffer_id) else {\n+            return;\n+        };\n+\n+        let diff_change_range = range.to_offset(buffer_state.buffer.read(cx));\n \n         let mut excerpt_edits = Vec::new();\n-        for locator in self\n-            .buffers\n-            .borrow()\n-            .get(&buffer_id)\n-            .map(|state| &state.excerpts)\n-            .into_iter()\n-            .flatten()\n-        {\n+        for locator in &buffer_state.excerpts {\n             let mut cursor = snapshot\n                 .excerpts\n                 .cursor::<(Option<&Locator>, ExcerptOffset)>(&());\n             cursor.seek_forward(&Some(locator), Bias::Left, &());\n             if let Some(excerpt) = cursor.item() {\n                 if excerpt.locator == *locator {\n-                    let excerpt_range = cursor.start().1..cursor.end(&()).1;\n+                    let excerpt_buffer_range = excerpt.range.context.to_offset(&excerpt.buffer);\n+                    if diff_change_range.end < excerpt_buffer_range.start\n+                        || diff_change_range.start > excerpt_buffer_range.end\n+                    {\n+                        continue;\n+                    }\n+                    let excerpt_start = cursor.start().1;\n+                    let excerpt_len = ExcerptOffset::new(excerpt.text_summary.len);\n+                    let diff_change_start_in_excerpt = ExcerptOffset::new(\n+                        diff_change_range\n+                            .start\n+                            .saturating_sub(excerpt_buffer_range.start),\n+                    );\n+                    let diff_change_end_in_excerpt = ExcerptOffset::new(\n+                        diff_change_range\n+                            .end\n+                            .saturating_sub(excerpt_buffer_range.start),\n+                    );\n+                    let edit_start = excerpt_start + diff_change_start_in_excerpt.min(excerpt_len);\n+                    let edit_end = excerpt_start + diff_change_end_in_excerpt.min(excerpt_len);\n                     excerpt_edits.push(Edit {\n-                        old: excerpt_range.clone(),\n-                        new: excerpt_range.clone(),\n+                        old: edit_start..edit_end,\n+                        new: edit_start..edit_end,\n                     });\n                 }\n             }\n@@ -2055,7 +2083,7 @@\n             snapshot,\n             excerpt_edits,\n             DiffChangeKind::DiffUpdated {\n-                base_changed: base_text_version_changed,\n+                base_changed: base_text_changed,\n             },\n         );\n         cx.emit(Event::Edited {\n@@ -2145,11 +2173,18 @@\n \n     pub fn add_change_set(&mut self, change_set: Entity<BufferChangeSet>, cx: &mut Context<Self>) {\n         let buffer_id = change_set.read(cx).buffer_id;\n-        self.buffer_diff_changed(change_set.clone(), cx);\n+        self.buffer_diff_changed(change_set.clone(), text::Anchor::MIN..text::Anchor::MAX, cx);\n         self.diff_bases.insert(\n             buffer_id,\n             ChangeSetState {\n-                _subscription: cx.observe(&change_set, Self::buffer_diff_changed),\n+                _subscription: cx.subscribe(\n+                    &change_set,\n+                    |this, change_set, event, cx| match event {\n+                        BufferChangeSetEvent::DiffChanged { changed_range } => {\n+                            this.buffer_diff_changed(change_set, changed_range.clone(), cx);\n+                        }\n+                    },\n+                ),\n                 change_set,\n             },\n         );\n@@ -2218,46 +2253,34 @@\n         let snapshot = self.snapshot.borrow_mut();\n         let mut excerpt_edits = Vec::new();\n         for range in ranges.iter() {\n+            let end_excerpt_id = range.end.excerpt_id;\n             let range = range.to_point(&snapshot);\n-\n-            let mut start = snapshot.anchor_before(Point::new(range.start.row, 0));\n-            let mut end = snapshot.anchor_before(Point::new(\n-                range.end.row,\n-                snapshot.line_len(MultiBufferRow(range.end.row)),\n-            ));\n-            let peek_end = if range.end.row < snapshot.max_row().0 {\n-                Point::new(range.end.row + 1, 0)\n-            } else {\n-                range.end\n+            let mut peek_end = range.end;\n+            if range.end.row < snapshot.max_row().0 {\n+                peek_end = Point::new(range.end.row + 1, 0);\n             };\n \n             for diff_hunk in snapshot.diff_hunks_in_range(range.start..peek_end) {\n-                if diff_hunk.row_range.start.0 <= range.start.row\n-                    && diff_hunk.row_range.end.0 >= range.start.row\n-                    && diff_hunk.excerpt_id == start.excerpt_id\n-                {\n-                    start = Anchor::in_buffer(\n-                        diff_hunk.excerpt_id,\n-                        diff_hunk.buffer_id,\n-                        diff_hunk.buffer_range.start,\n-                    );\n-                }\n-                if diff_hunk.row_range.start.0 <= peek_end.row\n-                    && diff_hunk.excerpt_id == end.excerpt_id\n-                {\n-                    end = Anchor::in_buffer(\n-                        diff_hunk.excerpt_id,\n-                        diff_hunk.buffer_id,\n-                        diff_hunk.buffer_range.end,\n-                    );\n+                if diff_hunk.excerpt_id.cmp(&end_excerpt_id, &snapshot).is_gt() {\n+                    continue;\n                 }\n+                let start = Anchor::in_buffer(\n+                    diff_hunk.excerpt_id,\n+                    diff_hunk.buffer_id,\n+                    diff_hunk.buffer_range.start,\n+                );\n+                let end = Anchor::in_buffer(\n+                    diff_hunk.excerpt_id,\n+                    diff_hunk.buffer_id,\n+                    diff_hunk.buffer_range.end,\n+                );\n+                let start = snapshot.excerpt_offset_for_anchor(&start);\n+                let end = snapshot.excerpt_offset_for_anchor(&end);\n+                excerpt_edits.push(text::Edit {\n+                    old: start..end,\n+                    new: start..end,\n+                });\n             }\n-            let start = snapshot.excerpt_offset_for_anchor(&start);\n-            let end = snapshot.excerpt_offset_for_anchor(&end);\n-            excerpt_edits.push(text::Edit {\n-                old: start..end,\n-                new: start..end,\n-            });\n         }\n \n         self.sync_diff_transforms(\n@@ -2265,6 +2288,7 @@\n             excerpt_edits,\n             DiffChangeKind::ExpandOrCollapseHunks { expand },\n         );\n+        cx.emit(Event::DiffHunksToggled);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2329,7 +2353,7 @@\n         drop(cursor);\n         snapshot.excerpts = new_excerpts;\n \n-        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::ExcerptsChanged);\n+        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::BufferEdited);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2430,7 +2454,7 @@\n         drop(cursor);\n         snapshot.excerpts = new_excerpts;\n \n-        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::ExcerptsChanged);\n+        self.sync_diff_transforms(snapshot, edits, DiffChangeKind::BufferEdited);\n         cx.emit(Event::Edited {\n             singleton_buffer_edited: false,\n             edited_buffer: None,\n@@ -2594,64 +2618,53 @@\n             let edit_start_overshoot = (edit.old.start - old_diff_transforms.start().0).value;\n             let edit_old_start = old_diff_transforms.start().1 + edit_start_overshoot;\n             let edit_new_start = (edit_old_start as isize + output_delta) as usize;\n-\n-            if change_kind == DiffChangeKind::BufferEdited {\n-                self.interpolate_diff_transforms_for_edit(\n-                    &edit,\n-                    &excerpts,\n-                    &mut old_diff_transforms,\n-                    &mut new_diff_transforms,\n-                    &mut end_of_current_insert,\n-                );\n-            } else {\n-                self.recompute_diff_transforms_for_edit(\n-                    &edit,\n-                    &mut excerpts,\n-                    &mut old_diff_transforms,\n-                    &mut new_diff_transforms,\n-                    &mut end_of_current_insert,\n-                    &mut old_expanded_hunks,\n-                    &snapshot,\n-                    change_kind,\n-                );\n-            }\n \n-            self.push_buffer_content_transform(\n-                &snapshot,\n+            let changed_diff_hunks = self.recompute_diff_transforms_for_edit(\n+                &edit,\n+                &mut excerpts,\n+                &mut old_diff_transforms,\n                 &mut new_diff_transforms,\n-                edit.new.end,\n-                end_of_current_insert,\n+                &mut end_of_current_insert,\n+                &mut old_expanded_hunks,\n+                &snapshot,\n+                change_kind,\n             );\n \n             // Compute the end of the edit in output coordinates.\n-            let edit_end_overshoot = (edit.old.end - old_diff_transforms.start().0).value;\n-            let edit_old_end = old_diff_transforms.start().1 + edit_end_overshoot;\n-            let edit_new_end = new_diff_transforms.summary().output.len;\n+            let edit_old_end_overshoot = edit.old.end - old_diff_transforms.start().0;\n+            let edit_new_end_overshoot = edit.new.end - new_diff_transforms.summary().excerpt_len();\n+            let edit_old_end = old_diff_transforms.start().1 + edit_old_end_overshoot.value;\n+            let edit_new_end =\n+                new_diff_transforms.summary().output.len + edit_new_end_overshoot.value;\n             let output_edit = Edit {\n                 old: edit_old_start..edit_old_end,\n                 new: edit_new_start..edit_new_end,\n             };\n \n-            output_delta += (output_edit.new.end - output_edit.new.start) as isize\n-                - (output_edit.old.end - output_edit.old.start) as isize;\n-            output_edits.push(output_edit);\n+            output_delta += (output_edit.new.end - output_edit.new.start) as isize;\n+            output_delta -= (output_edit.old.end - output_edit.old.start) as isize;\n+            if changed_diff_hunks || matches!(change_kind, DiffChangeKind::BufferEdited) {\n+                output_edits.push(output_edit);\n+            }\n \n             // If this is the last edit that intersects the current diff transform,\n-            // then preserve a suffix of the this diff transform.\n+            // then recreate the content up to the end of this transform, to prepare\n+            // for reusing additional slices of the old transforms.\n             if excerpt_edits.peek().map_or(true, |next_edit| {\n                 next_edit.old.start >= old_diff_transforms.end(&()).0\n             }) {\n+                let mut excerpt_offset = edit.new.end;\n                 if old_diff_transforms.start().0 < edit.old.end {\n-                    let suffix = old_diff_transforms.end(&()).0 - edit.old.end;\n-                    let transform_end = new_diff_transforms.summary().excerpt_len() + suffix;\n-                    self.push_buffer_content_transform(\n-                        &snapshot,\n-                        &mut new_diff_transforms,\n-                        transform_end,\n-                        end_of_current_insert,\n-                    );\n+                    excerpt_offset += old_diff_transforms.end(&()).0 - edit.old.end;\n                     old_diff_transforms.next(&());\n                 }\n+                old_expanded_hunks.clear();\n+                self.push_buffer_content_transform(\n+                    &snapshot,\n+                    &mut new_diff_transforms,\n+                    excerpt_offset,\n+                    end_of_current_insert,\n+                );\n                 at_transform_boundary = true;\n             }\n         }\n@@ -2691,7 +2704,7 @@\n         old_expanded_hunks: &mut HashSet<(ExcerptId, text::Anchor)>,\n         snapshot: &MultiBufferSnapshot,\n         change_kind: DiffChangeKind,\n-    ) {\n+    ) -> bool {\n         log::trace!(\n             \"recomputing diff transform for edit {:?} => {:?}\",\n             edit.old.start.value..edit.old.end.value,\n@@ -2699,11 +2712,7 @@\n         );\n \n         // Record which hunks were previously expanded.\n-        old_expanded_hunks.clear();\n         while let Some(item) = old_diff_transforms.item() {\n-            if old_diff_transforms.end(&()).0 > edit.old.end {\n-                break;\n-            }\n             if let Some(hunk_anchor) = item.hunk_anchor() {\n                 log::trace!(\n                     \"previously expanded hunk at {}\",\n@@ -2711,10 +2720,22 @@\n                 );\n                 old_expanded_hunks.insert(hunk_anchor);\n             }\n+            if old_diff_transforms.end(&()).0 > edit.old.end {\n+                break;\n+            }\n             old_diff_transforms.next(&());\n         }\n \n+        // Avoid querying diff hunks if there's no possibility of hunks being expanded.\n+        if old_expanded_hunks.is_empty()\n+            && change_kind == DiffChangeKind::BufferEdited\n+            && !self.all_diff_hunks_expanded\n+        {\n+            return false;\n+        }\n+\n         // Visit each excerpt that intersects the edit.\n+        let mut did_expand_hunks = false;\n         while let Some(excerpt) = excerpts.item() {\n             if excerpt.text_summary.len == 0 {\n                 if excerpts.end(&()) <= edit.new.end {\n@@ -2754,8 +2775,10 @@\n                         + ExcerptOffset::new(\n                             hunk_buffer_range.start.saturating_sub(excerpt_buffer_start),\n                         );\n-                    let hunk_excerpt_end = excerpt_start\n-                        + ExcerptOffset::new(hunk_buffer_range.end - excerpt_buffer_start);\n+                    let hunk_excerpt_end = excerpt_end.min(\n+                        excerpt_start\n+                            + ExcerptOffset::new(hunk_buffer_range.end - excerpt_buffer_start),\n+                    );\n \n                     self.push_buffer_content_transform(\n                         snapshot,\n@@ -2787,7 +2810,11 @@\n                     };\n \n                     if should_expand_hunk {\n-                        log::trace!(\"expanding hunk at {}\", hunk_excerpt_start.value);\n+                        did_expand_hunks = true;\n+                        log::trace!(\n+                            \"expanding hunk {:?}\",\n+                            hunk_excerpt_start.value..hunk_excerpt_end.value,\n+                        );\n \n                         if !hunk.diff_base_byte_range.is_empty()\n                             && hunk_buffer_range.start >= edit_buffer_start\n@@ -2833,68 +2860,8 @@\n                 break;\n             }\n         }\n-    }\n-\n-    fn interpolate_diff_transforms_for_edit(\n-        &self,\n-        edit: &Edit<TypedOffset<Excerpt>>,\n-        excerpts: &Cursor<Excerpt, TypedOffset<Excerpt>>,\n-        old_diff_transforms: &mut Cursor<DiffTransform, (TypedOffset<Excerpt>, usize)>,\n-        new_diff_transforms: &mut SumTree<DiffTransform>,\n-        end_of_current_insert: &mut Option<(TypedOffset<Excerpt>, ExcerptId, text::Anchor)>,\n-    ) {\n-        log::trace!(\n-            \"interpolating diff transform for edit {:?} => {:?}\",\n-            edit.old.start.value..edit.old.end.value,\n-            edit.new.start.value..edit.new.end.value\n-        );\n \n-        // Preserve deleted hunks immediately preceding edits.\n-        if let Some(transform) = old_diff_transforms.item() {\n-            if old_diff_transforms.start().0 == edit.old.start {\n-                if let DiffTransform::DeletedHunk { hunk_anchor, .. } = transform {\n-                    if excerpts\n-                        .item()\n-                        .map_or(false, |excerpt| hunk_anchor.1.is_valid(&excerpt.buffer))\n-                    {\n-                        self.push_diff_transform(new_diff_transforms, transform.clone());\n-                        old_diff_transforms.next(&());\n-                    }\n-                }\n-            }\n-        }\n-\n-        let edit_start_transform = old_diff_transforms.item();\n-\n-        // When an edit starts within an inserted hunks, extend the hunk\n-        // to include the lines of the edit.\n-        if let Some((\n-            DiffTransform::BufferContent {\n-                inserted_hunk_anchor: Some(inserted_hunk_anchor),\n-                ..\n-            },\n-            excerpt,\n-        )) = edit_start_transform.zip(excerpts.item())\n-        {\n-            let buffer = &excerpt.buffer;\n-            if inserted_hunk_anchor.1.is_valid(buffer) {\n-                let excerpt_start = *excerpts.start();\n-                let excerpt_end = excerpt_start + ExcerptOffset::new(excerpt.text_summary.len);\n-                let excerpt_buffer_start = excerpt.range.context.start.to_offset(buffer);\n-                let edit_buffer_end =\n-                    excerpt_buffer_start + edit.new.end.value.saturating_sub(excerpt_start.value);\n-                let edit_buffer_end_point = buffer.offset_to_point(edit_buffer_end);\n-                let edited_buffer_line_end =\n-                    buffer.point_to_offset(edit_buffer_end_point + Point::new(1, 0));\n-                let edited_line_end = excerpt_start\n-                    + ExcerptOffset::new(edited_buffer_line_end - excerpt_buffer_start);\n-                let hunk_end = edited_line_end.min(excerpt_end);\n-                *end_of_current_insert =\n-                    Some((hunk_end, inserted_hunk_anchor.0, inserted_hunk_anchor.1));\n-            }\n-        }\n-\n-        old_diff_transforms.seek_forward(&edit.old.end, Bias::Right, &());\n+        did_expand_hunks || !old_expanded_hunks.is_empty()\n     }\n \n     fn append_diff_transforms(\n@@ -3409,6 +3376,49 @@\n         result\n     }\n \n+    pub fn range_to_buffer_ranges_with_deleted_hunks<T: ToOffset>(\n+        &self,\n+        range: Range<T>,\n+    ) -> impl Iterator<Item = (&BufferSnapshot, Range<usize>, ExcerptId, Option<Anchor>)> + '_ {\n+        let start = range.start.to_offset(&self);\n+        let end = range.end.to_offset(&self);\n+\n+        let mut cursor = self.cursor::<usize>();\n+        cursor.seek(&start);\n+\n+        std::iter::from_fn(move || {\n+            let region = cursor.region()?;\n+            if region.range.start > end {\n+                return None;\n+            }\n+            let start_overshoot = start.saturating_sub(region.range.start);\n+            let end_overshoot = end.saturating_sub(region.range.start);\n+            let start = region\n+                .buffer_range\n+                .end\n+                .min(region.buffer_range.start + start_overshoot);\n+            let end = region\n+                .buffer_range\n+                .end\n+                .min(region.buffer_range.start + end_overshoot);\n+\n+            let region_excerpt_id = region.excerpt.id;\n+            let deleted_hunk_anchor = if region.is_main_buffer {\n+                None\n+            } else {\n+                Some(self.anchor_before(region.range.start))\n+            };\n+            let result = (\n+                region.buffer,\n+                start..end,\n+                region_excerpt_id,\n+                deleted_hunk_anchor,\n+            );\n+            cursor.next();\n+            Some(result)\n+        })\n+    }\n+\n     /// Retrieves buffer metadata for the given range, and converts it into multi-buffer\n     /// coordinates.\n     ///\n@@ -3441,10 +3451,8 @@\n         while let Some(region) = cursor.region() {\n             if region.is_main_buffer {\n                 let mut buffer_end = region.buffer_range.start.key;\n-                if region.is_main_buffer {\n-                    let overshoot = range.end.saturating_sub(region.range.start.key);\n-                    buffer_end.add_assign(&overshoot);\n-                }\n+                let overshoot = range.end.saturating_sub(region.range.start.key);\n+                buffer_end.add_assign(&overshoot);\n                 range_end = Some((region.excerpt.id, buffer_end));\n                 break;\n             }\n@@ -3456,6 +3464,10 @@\n             value: None,\n         });\n \n+        if cursor.region().is_some_and(|region| !region.is_main_buffer) {\n+            cursor.prev();\n+        }\n+\n         iter::from_fn(move || loop {\n             let excerpt = cursor.excerpt()?;\n \n@@ -3498,8 +3510,9 @@\n                 // the metadata item's range.\n                 if range.start > D::default() {\n                     while let Some(region) = cursor.region() {\n-                        if region.buffer.remote_id() == excerpt.buffer_id\n-                            && region.buffer_range.end.value.unwrap() < range.start\n+                        if !region.is_main_buffer\n+                            || region.buffer.remote_id() == excerpt.buffer_id\n+                                && region.buffer_range.end.value.unwrap() < range.start\n                         {\n                             cursor.next();\n                         } else {\n@@ -4235,36 +4248,7 @@\n     where\n         D: TextDimension + Ord + Sub<D, Output = D>,\n     {\n-        let mut cursor = self.excerpts.cursor::<ExcerptSummary>(&());\n-        let locator = self.excerpt_locator_for_id(anchor.excerpt_id);\n-\n-        cursor.seek(locator, Bias::Left, &());\n-        if cursor.item().is_none() {\n-            cursor.next(&());\n-        }\n-\n-        let mut excerpt_position = D::from_text_summary(&cursor.start().text);\n-        if let Some(excerpt) = cursor.item() {\n-            if excerpt.id == anchor.excerpt_id {\n-                let excerpt_buffer_start =\n-                    excerpt.range.context.start.summary::<D>(&excerpt.buffer);\n-                let excerpt_buffer_end = excerpt.range.context.end.summary::<D>(&excerpt.buffer);\n-                let buffer_position = cmp::min(\n-                    excerpt_buffer_end,\n-                    anchor.text_anchor.summary::<D>(&excerpt.buffer),\n-                );\n-                if buffer_position > excerpt_buffer_start {\n-                    excerpt_position.add_assign(&(buffer_position - excerpt_buffer_start));\n-                }\n-            }\n-        }\n-\n-        let mut diff_transforms_cursor = self\n-            .diff_transforms\n-            .cursor::<(ExcerptDimension<D>, OutputDimension<D>)>(&());\n-        diff_transforms_cursor.seek(&ExcerptDimension(excerpt_position), Bias::Left, &());\n-\n-        self.resolve_summary_for_anchor(anchor, excerpt_position, &mut diff_transforms_cursor)\n+        self.summaries_for_anchors([anchor])[0]\n     }\n \n     fn resolve_summary_for_anchor<D>(\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -14392,7 +14392,6 @@\n \n         editor.buffer().update(cx, |multibuffer, cx| {\n             let buffer = multibuffer.as_singleton().unwrap();\n-<<<<<<< HEAD\n             let change_set =\n                 cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n =======\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -14394,14 +14394,6 @@\n             let buffer = multibuffer.as_singleton().unwrap();\n             let change_set =\n                 cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n-=======\n-            let change_set = cx.new(|cx| {\n-                let mut change_set = BufferChangeSet::new(&buffer, cx);\n-                let _ =\n-                    change_set.set_base_text(base_text.into(), buffer.read(cx).text_snapshot(), cx);\n-                change_set\n-            });\n->>>>>>> origin/main\n \n             multibuffer.set_all_diff_hunks_expanded(cx);\n             multibuffer.add_change_set(change_set, cx);\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer_tests.rs\":\n```diff\n@@ -358,7 +358,6 @@\n     let base_text = \"one\\ntwo\\nthree\\n\";\n     let text = \"one\\nthree\\n\";\n     let buffer = cx.new(|cx| Buffer::local(text, cx));\n-<<<<<<< HEAD\n     let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n =======\n     let snapshot = buffer.read_with(cx, |buffer, _| buffer.snapshot());\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer_tests.rs\":\n```diff\n@@ -359,15 +359,6 @@\n     let text = \"one\\nthree\\n\";\n     let buffer = cx.new(|cx| Buffer::local(text, cx));\n     let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n-=======\n-    let snapshot = buffer.read_with(cx, |buffer, _| buffer.snapshot());\n-    let change_set = cx.new(|cx| {\n-        let mut change_set = BufferChangeSet::new(&buffer, cx);\n-        let _ = change_set.set_base_text(base_text.into(), snapshot.text, cx);\n-        change_set\n-    });\n-    cx.run_until_parked();\n->>>>>>> origin/main\n     let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n     multibuffer.update(cx, |multibuffer, cx| {\n         multibuffer.add_change_set(change_set, cx)\n\n```\n\nUser edited \"crates/multi_buffer/src/multi_buffer_tests.rs\":\n```diff\n@@ -402,7 +402,6 @@\n     let base_text = \"one\\ntwo\\nthree\\nfour\\nfive\\nsix\\nseven\\neight\\n\";\n     let text = \"one\\nfour\\nseven\\n\";\n     let buffer = cx.new(|cx| Buffer::local(text, cx));\n-<<<<<<< HEAD\n     let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n =======\n     let change_set = cx.new(|cx| {\n\n```\n\n### Input:\n```crates/multi_buffer/src/multi_buffer_tests.rs\n    });\n<|editable_region_start|>\n    cx.run_until_parked();\n\n    let snapshot = multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n    let actual_text = snapshot.text();\n    let actual_row_infos = snapshot.row_infos(MultiBufferRow(0)).collect::<Vec<_>>();\n    let actual_diff = format_diff(&actual_text, &actual_row_infos, &Default::default());\n    pretty_assertions::assert_eq!(\n        actual_diff,\n        indoc! {\n            \"  one\n             - two\n               three\n             \"\n        },\n    );\n\n    multibuffer.update(cx, |multibuffer, cx| {\n        let snapshot = multibuffer.snapshot(cx);\n        assert_eq!(before.to_point(&snapshot), Point::new(1, 0));\n        assert_eq!(after.to_point(&snapshot), Point::new(2, 0));\n        assert_eq!(\n            vec![Point::new(1, 0), Point::new(2, 0),],\n            snapshot.summaries_for_anchors::<Point, _>(&[before, after]),\n        )\n    })\n}\n\n#[gpui::test]\nfn test_diff_hunks_in_range(cx: &mut TestAppContext) {\n    let base_text = \"one\\ntwo\\nthree\\nfour\\nfive\\nsix\\nseven\\neight\\n\";\n    let text = \"one\\nfour\\nseven\\n\";\n    let buffer = cx.new(|cx| Buffer::local(text, cx));\n<|user_cursor_is_here|>    let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n=======\n    let change_set = cx.new(|cx| {\n        let mut change_set = BufferChangeSet::new(&buffer, cx);\n        let snapshot = buffer.read(cx).snapshot();\n        let _ = change_set.set_base_text(base_text.into(), snapshot.text, cx);\n        change_set\n    });\n    cx.run_until_parked();\n>>>>>>> origin/main\n    let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (mut snapshot, mut subscription) = multibuffer.update(cx, |multibuffer, cx| {\n        (multibuffer.snapshot(cx), multibuffer.subscribe())\n    });\n\n    multibuffer.update(cx, |multibuffer, cx| {\n        multibuffer.add_change_set(change_set, cx);\n        multibuffer.expand_diff_hunks(vec![Anchor::min()..Anchor::max()], cx);\n    });\n\n    assert_new_snapshot(\n        &multibuffer,\n        &mut snapshot,\n        &mut subscription,\n        cx,\n        indoc! {\n            \"  one\n             - two\n             - three\n               four\n             - five\n             - six\n               seven\n<|editable_region_end|>\n             - eight\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/multi_buffer/src/multi_buffer_tests.rs\n    });\n<|editable_region_start|>\n    cx.run_until_parked();\n\n    let snapshot = multibuffer.read_with(cx, |multibuffer, cx| multibuffer.snapshot(cx));\n    let actual_text = snapshot.text();\n    let actual_row_infos = snapshot.row_infos(MultiBufferRow(0)).collect::<Vec<_>>();\n    let actual_diff = format_diff(&actual_text, &actual_row_infos, &Default::default());\n    pretty_assertions::assert_eq!(\n        actual_diff,\n        indoc! {\n            \"  one\n             - two\n               three\n             \"\n        },\n    );\n\n    multibuffer.update(cx, |multibuffer, cx| {\n        let snapshot = multibuffer.snapshot(cx);\n        assert_eq!(before.to_point(&snapshot), Point::new(1, 0));\n        assert_eq!(after.to_point(&snapshot), Point::new(2, 0));\n        assert_eq!(\n            vec![Point::new(1, 0), Point::new(2, 0),],\n            snapshot.summaries_for_anchors::<Point, _>(&[before, after]),\n        )\n    })\n}\n\n#[gpui::test]\nfn test_diff_hunks_in_range(cx: &mut TestAppContext) {\n    let base_text = \"one\\ntwo\\nthree\\nfour\\nfive\\nsix\\nseven\\neight\\n\";\n    let text = \"one\\nfour\\nseven\\n\";\n    let buffer = cx.new(|cx| Buffer::local(text, cx));\n<|user_cursor_is_here|>    let change_set = cx.new(|cx| BufferChangeSet::new_with_base_text(base_text, &buffer, cx));\n=======\n    let change_set = cx.new(|cx| {\n        let mut change_set = BufferChangeSet::new(&buffer, cx);\n        let snapshot = buffer.read(cx).snapshot();\n        let _ = change_set.set_base_text(base_text.into(), snapshot.text, cx);\n        change_set\n    });\n    cx.run_until_parked();\n>>>>>>> origin/main\n    let multibuffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n    let (mut snapshot, mut subscription) = multibuffer.update(cx, |multibuffer, cx| {\n        (multibuffer.snapshot(cx), multibuffer.subscribe())\n    });\n\n    multibuffer.update(cx, |multibuffer, cx| {\n        multibuffer.add_change_set(change_set, cx);\n        multibuffer.expand_diff_hunks(vec![Anchor::min()..Anchor::max()], cx);\n    });\n\n    assert_new_snapshot(\n        &multibuffer,\n        &mut snapshot,\n        &mut subscription,\n        cx,\n        indoc! {\n            \"  one\n             - two\n             - three\n               four\n             - five\n             - six\n               seven\n<|editable_region_end|>\n             - eight\n```"
  },
  "max_tokens": 1024
}