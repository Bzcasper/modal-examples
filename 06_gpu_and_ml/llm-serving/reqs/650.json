{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -239,7 +239,7 @@\n                     return Some(zed_extension_api::CodeLabel {\n                         spans: vec![CodeLabelSpan::code_range(Range {\n                             start: 0,\n-                            end: code.len(),\n+                            end: code.len() as u32,\n                         })],\n                         filter_range: Range {\n                             start: \"enum \".len() as u32,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -199,7 +199,7 @@\n                 spans,\n                 filter_range: Range {\n                     start,\n-                    end: completion_len as u32,\n+                    end: start + completion_len as u32,\n                 },\n             })\n         }\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -232,6 +232,8 @@\n                         if let Some(label) = format_function(&completion) {\n                             return Some(label);\n                         }\n+                    } else {\n+                        \n                     }\n                 }\n                 CompletionKind::Enum => {\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -233,7 +233,18 @@\n                             return Some(label);\n                         }\n                     } else {\n-                        \n+                        let code = format!(\"enum {}\", completion.label);\n+                        return Some(zed_extension_api::CodeLabel {\n+                            spans: vec![CodeLabelSpan::code_range(Range {\n+                                start: 0,\n+                                end: code.len() as u32,\n+                            })],\n+                            filter_range: Range {\n+                                start: \"enum \".len() as u32,\n+                                end: code.len() as u32,\n+                            },\n+                            code,\n+                        });\n                     }\n                 }\n                 CompletionKind::Enum => {\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -233,7 +233,7 @@\n                             return Some(label);\n                         }\n                     } else {\n-                        let code = format!(\"enum {}\", completion.label);\n+                        let code = format!(\"struct {}\", completion.label);\n                         return Some(zed_extension_api::CodeLabel {\n                             spans: vec![CodeLabelSpan::code_range(Range {\n                                 start: 0,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -240,7 +240,7 @@\n                                 end: code.len() as u32,\n                             })],\n                             filter_range: Range {\n-                                start: \"enum \".len() as u32,\n+                                start: \"struct \".len() as u32,\n                                 end: code.len() as u32,\n                             },\n                             code,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -232,7 +232,7 @@\n                         if let Some(label) = format_function(&completion) {\n                             return Some(label);\n                         }\n-                    } else {\n+                    } else if completion.detail.as_ref().map_or(false, |detail| detail{\n                         let code = format!(\"struct {}\", completion.label);\n                         return Some(zed_extension_api::CodeLabel {\n                             spans: vec![CodeLabelSpan::code_range(Range {\n\n```\n\n### Input:\n```crates/project/src/lsp_store.rs\n        if !file.is_local() {\n<|editable_region_start|>\n            return;\n        }\n\n        let abs_path = file.abs_path(cx);\n        let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n            return;\n        };\n        let initial_snapshot = buffer.text_snapshot();\n        let worktree_id = file.worktree_id(cx);\n\n        let Some(language) = buffer.language().cloned() else {\n            return;\n        };\n        let path: Arc<Path> = file\n            .path()\n            .parent()\n            .map(Arc::from)\n            .unwrap_or_else(|| file.path().clone());\n        let Some(worktree) = self\n            .worktree_store\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n        else {\n            return;\n        };\n        let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n        let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n            this.get(\n                ProjectPath { worktree_id, path },\n                AdapterQuery::Language(&language.name()),\n                delegate.clone(),\n                cx,\n            )\n            .collect::<Vec<_>>()\n        });\n        let servers = servers\n            .into_iter()\n            .filter_map(|server_node| {\n                let server_id = server_node.server_id_or_init(\n                    |LaunchDisposition {\n                         server_name,\n                         attach,\n                         path,\n                         settings,\n                     }| {\n                         dbg!(<|user_cursor_is_here|>)\n                         match attach {\n                        language::Attach::InstancePerRoot => {\n                            // todo: handle instance per root proper.\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&(worktree_id, server_name.clone()))\n                            {\n                                server_ids.iter().cloned().next().unwrap()\n                            } else {\n                                let language_name = language.name();\n\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                )\n                            }\n                        }\n                        language::Attach::Shared => {\n                            let uri = Url::from_directory_path(\n                                worktree.read(cx).abs_path().join(&path.path),\n                            );\n                            let key = (worktree_id, server_name.clone());\n                            if !self.language_server_ids.contains_key(&key) {\n                                let language_name = language.name();\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                );\n                            }\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&key)\n<|editable_region_end|>\n                                .language_server_ids\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/lsp_store.rs\n        if !file.is_local() {\n<|editable_region_start|>\n            return;\n        }\n\n        let abs_path = file.abs_path(cx);\n        let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n            return;\n        };\n        let initial_snapshot = buffer.text_snapshot();\n        let worktree_id = file.worktree_id(cx);\n\n        let Some(language) = buffer.language().cloned() else {\n            return;\n        };\n        let path: Arc<Path> = file\n            .path()\n            .parent()\n            .map(Arc::from)\n            .unwrap_or_else(|| file.path().clone());\n        let Some(worktree) = self\n            .worktree_store\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n        else {\n            return;\n        };\n        let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n        let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n            this.get(\n                ProjectPath { worktree_id, path },\n                AdapterQuery::Language(&language.name()),\n                delegate.clone(),\n                cx,\n            )\n            .collect::<Vec<_>>()\n        });\n        let servers = servers\n            .into_iter()\n            .filter_map(|server_node| {\n                let server_id = server_node.server_id_or_init(\n                    |LaunchDisposition {\n                         server_name,\n                         attach,\n                         path,\n                         settings,\n                     }| {\n                         dbg!(<|user_cursor_is_here|>)\n                         match attach {\n                        language::Attach::InstancePerRoot => {\n                            // todo: handle instance per root proper.\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&(worktree_id, server_name.clone()))\n                            {\n                                server_ids.iter().cloned().next().unwrap()\n                            } else {\n                                let language_name = language.name();\n\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                )\n                            }\n                        }\n                        language::Attach::Shared => {\n                            let uri = Url::from_directory_path(\n                                worktree.read(cx).abs_path().join(&path.path),\n                            );\n                            let key = (worktree_id, server_name.clone());\n                            if !self.language_server_ids.contains_key(&key) {\n                                let language_name = language.name();\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                );\n                            }\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&key)\n<|editable_region_end|>\n                                .language_server_ids\n```"
  },
  "max_tokens": 1024
}