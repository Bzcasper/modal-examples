{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"assets/keymaps/default-macos.json\":\n```diff\n@@ -505,7 +505,7 @@\n       \"cmd-shift-e\": \"project_panel::ToggleFocus\",\n       \"cmd-shift-b\": \"outline_panel::ToggleFocus\",\n       \"ctrl-shift-g\": \"git_panel::ToggleFocus\",\n-      \"cmd-?\": \"assistant::ToggleFocus\",\n+      \"cmd-i\": \"assistant::ToggleFocus\",\n       \"cmd-alt-s\": \"workspace::SaveAll\",\n       \"cmd-k m\": \"language_selector::Toggle\",\n       \"escape\": \"workspace::Unfollow\",\n\n```\n\nUser edited \"\":\n```diff\n@@ -35,6 +35,10 @@\n       ]\n     }\n   ],\n+  \"project_panel\": {\n+      \"folder_icons\": false\n+    },\n+\n   \"inline_completions\": {\n     \"disabled_globs\": [\".env\"]\n   },\n\n```\n\nUser edited \"\":\n```diff\n@@ -36,8 +36,8 @@\n     }\n   ],\n   \"project_panel\": {\n-      \"folder_icons\": false\n-    },\n+    \"folder_icons\": false\n+  },\n \n   \"inline_completions\": {\n     \"disabled_globs\": [\".env\"]\n\n```\n\nUser edited \"\":\n```diff\n@@ -3,7 +3,8 @@\n     \"context\": \"Workspace\",\n     \"bindings\": {\n       \"alt-\\\\\": null,\n-      \"ctrl-c\": \"menu::Cancel\"\n+      \"ctrl-c\": \"menu::Cancel\",\n+      \"alt-cmd-o\": [\"projects::OpenRecent\", {\"create_new_window\": true }], \n     }\n   },\n   {\n\n```\n\nUser edited \"\":\n```diff\n@@ -4,7 +4,7 @@\n     \"bindings\": {\n       \"alt-\\\\\": null,\n       \"ctrl-c\": \"menu::Cancel\",\n-      \"alt-cmd-o\": [\"projects::OpenRecent\", {\"create_new_window\": true }], \n+      \"alt-cmd-o\": [\"projects::OpenRecent\", { \"create_new_window\": true }]\n     }\n   },\n   {\n\n```\n\n### Input:\n```crates/node_runtime/src/node_runtime.rs\n            return true;\n<|editable_region_start|>\n        };\n        let Some(latest_version) = Version::parse(latest_version).log_err() else {\n            return true;\n        };\n\n        installed_version < latest_version\n    }\n}\n\nenum ArchiveType {\n    TarGz,\n    Zip,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct NpmInfo {\n    #[serde(default)]\n    dist_tags: NpmInfoDistTags,\n    versions: Vec<String>,\n}\n\n#[derive(Debug, Deserialize, Default)]\npub struct NpmInfoDistTags {\n    latest: Option<String>,\n}\n\n#[async_trait::async_trait]\ntrait NodeRuntimeTrait: Send + Sync {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait>;\n    fn binary_path(&self) -> Result<PathBuf>;\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Uri>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output>;\n\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>>;\n}\n\n#[derive(Clone)]\nstruct ManagedNodeRuntime {\n    installation_path: PathBuf,\n}\n\nimpl ManagedNodeRuntime {\n    const VERSION: &str = \"v22.5.1\";\n\n    #[cfg(not(windows))]\n    const NODE_PATH: &str = \"bin/node\";\n    #[cfg(windows)]\n    const NODE_PATH: &str = \"node.exe\";\n\n    #[cfg(not(windows))]\n    const NPM_PATH: &str = \"bin/npm\";\n    #[cfg(windows)]\n    const NPM_PATH: &str = \"node_modules/npm/bin/npm-cli.js\";\n\n    <|user_cursor_is_here|>async fn node_environment_path(&self) -> Result<OsString> {\n        let node_binary = self.installation_path.join(Self::NODE_PATH);\n        let mut env_path = vec![node_binary\n            .parent()\n            .expect(\"invalid node binary path\")\n            .to_path_buf()];\n\n        if let Some(existing_path) = std::env::var_os(\"PATH\") {\n            let mut paths = std::env::split_paths(&existing_path).collect::<Vec<_>>();\n            env_path.append(&mut paths);\n        }\n\n        std::env::join_paths(env_path).context(\"failed to create PATH env variable\")\n    }\n\n    async fn install_if_needed(http: &Arc<dyn HttpClient>) -> Result<Box<dyn NodeRuntimeTrait>> {\n        log::info!(\"Node runtime install_if_needed\");\n\n        let os = match consts::OS {\n            \"macos\" => \"darwin\",\n            \"linux\" => \"linux\",\n            \"windows\" => \"win\",\n            other => bail!(\"Running on unsupported os: {other}\"),\n        };\n\n        let arch = match consts::ARCH {\n            \"x86_64\" => \"x64\",\n            \"aarch64\" => \"arm64\",\n            other => bail!(\"Running on unsupported architecture: {other}\"),\n        };\n\n        let version = Self::VERSION;\n        let folder_name = format!(\"node-{version}-{os}-{arch}\");\n        let node_containing_dir = paths::support_dir().join(\"node\");\n        let node_dir = node_containing_dir.join(folder_name);\n        let node_binary = node_dir.join(Self::NODE_PATH);\n        let npm_file = node_dir.join(Self::NPM_PATH);\n\n        let result = util::command::new_smol_command(&node_binary)\n            .env_clear()\n            .arg(npm_file)\n            .arg(\"--version\")\n            .stdin(Stdio::null())\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .args([\"--cache\".into(), node_dir.join(\"cache\")])\n            .args([\"--userconfig\".into(), node_dir.join(\"blank_user_npmrc\")])\n            .args([\"--globalconfig\".into(), node_dir.join(\"blank_global_npmrc\")])\n            .status()\n            .await;\n        let valid = matches!(result, Ok(status) if status.success());\n\n        if !valid {\n            _ = fs::remove_dir_all(&node_containing_dir).await;\n            fs::create_dir(&node_containing_dir)\n                .await\n                .context(\"error creating node containing dir\")?;\n\n            let archive_type = match consts::OS {\n                \"macos\" | \"linux\" => ArchiveType::TarGz,\n                \"windows\" => ArchiveType::Zip,\n                other => bail!(\"Running on unsupported os: {other}\"),\n            };\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/node_runtime/src/node_runtime.rs\n            return true;\n<|editable_region_start|>\n        };\n        let Some(latest_version) = Version::parse(latest_version).log_err() else {\n            return true;\n        };\n\n        installed_version < latest_version\n    }\n}\n\nenum ArchiveType {\n    TarGz,\n    Zip,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\npub struct NpmInfo {\n    #[serde(default)]\n    dist_tags: NpmInfoDistTags,\n    versions: Vec<String>,\n}\n\n#[derive(Debug, Deserialize, Default)]\npub struct NpmInfoDistTags {\n    latest: Option<String>,\n}\n\n#[async_trait::async_trait]\ntrait NodeRuntimeTrait: Send + Sync {\n    fn boxed_clone(&self) -> Box<dyn NodeRuntimeTrait>;\n    fn binary_path(&self) -> Result<PathBuf>;\n\n    async fn run_npm_subcommand(\n        &self,\n        directory: Option<&Path>,\n        proxy: Option<&Uri>,\n        subcommand: &str,\n        args: &[&str],\n    ) -> Result<Output>;\n\n    async fn npm_package_installed_version(\n        &self,\n        local_package_directory: &Path,\n        name: &str,\n    ) -> Result<Option<String>>;\n}\n\n#[derive(Clone)]\nstruct ManagedNodeRuntime {\n    installation_path: PathBuf,\n}\n\nimpl ManagedNodeRuntime {\n    const VERSION: &str = \"v22.5.1\";\n\n    #[cfg(not(windows))]\n    const NODE_PATH: &str = \"bin/node\";\n    #[cfg(windows)]\n    const NODE_PATH: &str = \"node.exe\";\n\n    #[cfg(not(windows))]\n    const NPM_PATH: &str = \"bin/npm\";\n    #[cfg(windows)]\n    const NPM_PATH: &str = \"node_modules/npm/bin/npm-cli.js\";\n\n    <|user_cursor_is_here|>async fn node_environment_path(&self) -> Result<OsString> {\n        let node_binary = self.installation_path.join(Self::NODE_PATH);\n        let mut env_path = vec![node_binary\n            .parent()\n            .expect(\"invalid node binary path\")\n            .to_path_buf()];\n\n        if let Some(existing_path) = std::env::var_os(\"PATH\") {\n            let mut paths = std::env::split_paths(&existing_path).collect::<Vec<_>>();\n            env_path.append(&mut paths);\n        }\n\n        std::env::join_paths(env_path).context(\"failed to create PATH env variable\")\n    }\n\n    async fn install_if_needed(http: &Arc<dyn HttpClient>) -> Result<Box<dyn NodeRuntimeTrait>> {\n        log::info!(\"Node runtime install_if_needed\");\n\n        let os = match consts::OS {\n            \"macos\" => \"darwin\",\n            \"linux\" => \"linux\",\n            \"windows\" => \"win\",\n            other => bail!(\"Running on unsupported os: {other}\"),\n        };\n\n        let arch = match consts::ARCH {\n            \"x86_64\" => \"x64\",\n            \"aarch64\" => \"arm64\",\n            other => bail!(\"Running on unsupported architecture: {other}\"),\n        };\n\n        let version = Self::VERSION;\n        let folder_name = format!(\"node-{version}-{os}-{arch}\");\n        let node_containing_dir = paths::support_dir().join(\"node\");\n        let node_dir = node_containing_dir.join(folder_name);\n        let node_binary = node_dir.join(Self::NODE_PATH);\n        let npm_file = node_dir.join(Self::NPM_PATH);\n\n        let result = util::command::new_smol_command(&node_binary)\n            .env_clear()\n            .arg(npm_file)\n            .arg(\"--version\")\n            .stdin(Stdio::null())\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .args([\"--cache\".into(), node_dir.join(\"cache\")])\n            .args([\"--userconfig\".into(), node_dir.join(\"blank_user_npmrc\")])\n            .args([\"--globalconfig\".into(), node_dir.join(\"blank_global_npmrc\")])\n            .status()\n            .await;\n        let valid = matches!(result, Ok(status) if status.success());\n\n        if !valid {\n            _ = fs::remove_dir_all(&node_containing_dir).await;\n            fs::create_dir(&node_containing_dir)\n                .await\n                .context(\"error creating node containing dir\")?;\n\n            let archive_type = match consts::OS {\n                \"macos\" | \"linux\" => ArchiveType::TarGz,\n                \"windows\" => ArchiveType::Zip,\n                other => bail!(\"Running on unsupported os: {other}\"),\n            };\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}