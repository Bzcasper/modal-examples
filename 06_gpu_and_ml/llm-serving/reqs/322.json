{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1795,6 +1795,7 @@\n         } else {\n             label.clone()\n         };\n+        dbg!((&label, &text));\n         Self {\n             text,\n             runs,\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -4397,6 +4397,7 @@\n                 language.map(|language| language.as_ref()),\n             )\n         });\n+        dbg!(&new_label);\n         ensure_uniform_list_compatible_label(&mut new_label);\n \n         let mut completions = completions.borrow_mut();\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11382,6 +11382,7 @@\n         match context_menu {\n             CodeContextMenu::Completions(completions_menu) => {\n                 let completions = completions_menu.completions.borrow_mut();\n+                dbg!(&completions)\n                 assert_eq!(\n                     completions\n                         .iter()\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11382,7 +11382,7 @@\n         match context_menu {\n             CodeContextMenu::Completions(completions_menu) => {\n                 let completions = completions_menu.completions.borrow_mut();\n-                dbg!(&completions)\n+                dbg!(&completions);\n                 assert_eq!(\n                     completions\n                         .iter()\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11382,7 +11382,6 @@\n         match context_menu {\n             CodeContextMenu::Completions(completions_menu) => {\n                 let completions = completions_menu.completions.borrow_mut();\n-                dbg!(&completions);\n                 assert_eq!(\n                     completions\n                         .iter()\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11385,7 +11385,7 @@\n                 assert_eq!(\n                     completions\n                         .iter()\n-                        .map(|completion| &completion.label.text)\n+                        .map(|completion| dbg!(&completion.label.text)\n                         .collect::<Vec<_>>(),\n                     vec![\"method id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11385,7 +11385,7 @@\n                 assert_eq!(\n                     completions\n                         .iter()\n-                        .map(|completion| dbg!(&completion.label.text)\n+                        .map(|completion| dbg!(&completion.label).text)\n                         .collect::<Vec<_>>(),\n                     vec![\"method id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11385,7 +11385,7 @@\n                 assert_eq!(\n                     completions\n                         .iter()\n-                        .map(|completion| dbg!(&completion.label).text)\n+                        .map(|completion| &dbg!(&completion.label).text)\n                         .collect::<Vec<_>>(),\n                     vec![\"method id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11374,6 +11374,7 @@\n         editor.context_menu_next(&Default::default(), window, cx);\n     });\n \n+    dbg!(\"~~~~~~~~~~~~~~~~~\");\n     cx.update_editor(|editor, _, _| {\n         let context_menu = editor.context_menu.borrow_mut();\n         let context_menu = context_menu\n\n```\n\n### Input:\n```crates/editor/src/editor_tests.rs\n                        .map(|completion| &completion.label.text)\n<|editable_region_start|>\n                        .collect::<Vec<_>>(),\n                    vec![\"id\", \"other\"]\n                )\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>({\n        let item1 = item1.clone();\n        move |_, item_to_resolve, _| {\n            let item1 = item1.clone();\n            async move {\n                if item1 == item_to_resolve {\n                    Ok(lsp::CompletionItem {\n                        label: \"method id()\".to_string(),\n                        filter_text: Some(\"id\".to_string()),\n                        detail: Some(\"Now resolved!\".to_string()),\n                        documentation: Some(lsp::Documentation::String(\"Docs\".to_string())),\n                        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n                            range: lsp::Range::new(\n                                lsp::Position::new(0, 22),\n                                lsp::Position::new(0, 22),\n                            ),\n                            new_text: \".id\".to_string(),\n                        })),\n                        ..lsp::CompletionItem::default()\n                    })\n                } else {\n                    Ok(item_to_resolve)\n                }\n            }\n        }\n    })\n    .next()\n    .await\n    .unwrap();\n    cx.run_until_parked();\n\n    cx.update_editor(|editor, window, cx| {\n        editor.context_menu_next(&Default::default(), window, cx);\n    });\n\n    dbg!(\"~~~~~~~~~~~~~~~~~\");\n    cx.update_editor(|editor, _, _| {\n        let context_menu = editor.context_menu.borrow_mut();\n        let context_menu = context_menu\n            .as_ref()\n            .expect(\"Should have the context menu deployed\");\n        match context_menu {\n            CodeContextMenu::Completions(completions_menu) => {\n                let completions = completions_menu.completions.borrow_mut();\n                dbg!(<|user_cursor_is_here|>)\n                assert_eq!(\n                    completions\n                        .iter()\n                        .map(|completion| &dbg!(&completion.label).text)\n                        .collect::<Vec<_>>(),\n                    vec![\"method id()\", \"other\"],\n                    \"Should update first completion label, but not second as the filter text did not match.\"\n                );\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_completions_resolve_happens_once(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            completion_provider: Some(lsp::CompletionOptions {\n                trigger_characters: Some(vec![\".\".to_string()]),\n                resolve_provider: Some(true),\n                ..Default::default()\n            }),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {\"fn main() { let a = 2ˇ; }\"});\n    cx.simulate_keystroke(\".\");\n\n    let unresolved_item_1 = lsp::CompletionItem {\n        label: \"id\".to_string(),\n        filter_text: Some(\"id\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".id\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n    let resolved_item_1 = lsp::CompletionItem {\n        additional_text_edits: Some(vec![lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 20), lsp::Position::new(0, 22)),\n            new_text: \"!!\".to_string(),\n        }]),\n        ..unresolved_item_1.clone()\n    };\n    let unresolved_item_2 = lsp::CompletionItem {\n        label: \"other\".to_string(),\n<|editable_region_end|>\n    let unresolved_item_2 = lsp::CompletionItem {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/editor/src/editor_tests.rs\n                        .map(|completion| &completion.label.text)\n<|editable_region_start|>\n                        .collect::<Vec<_>>(),\n                    vec![\"id\", \"other\"]\n                )\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>({\n        let item1 = item1.clone();\n        move |_, item_to_resolve, _| {\n            let item1 = item1.clone();\n            async move {\n                if item1 == item_to_resolve {\n                    Ok(lsp::CompletionItem {\n                        label: \"method id()\".to_string(),\n                        filter_text: Some(\"id\".to_string()),\n                        detail: Some(\"Now resolved!\".to_string()),\n                        documentation: Some(lsp::Documentation::String(\"Docs\".to_string())),\n                        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n                            range: lsp::Range::new(\n                                lsp::Position::new(0, 22),\n                                lsp::Position::new(0, 22),\n                            ),\n                            new_text: \".id\".to_string(),\n                        })),\n                        ..lsp::CompletionItem::default()\n                    })\n                } else {\n                    Ok(item_to_resolve)\n                }\n            }\n        }\n    })\n    .next()\n    .await\n    .unwrap();\n    cx.run_until_parked();\n\n    cx.update_editor(|editor, window, cx| {\n        editor.context_menu_next(&Default::default(), window, cx);\n    });\n\n    dbg!(\"~~~~~~~~~~~~~~~~~\");\n    cx.update_editor(|editor, _, _| {\n        let context_menu = editor.context_menu.borrow_mut();\n        let context_menu = context_menu\n            .as_ref()\n            .expect(\"Should have the context menu deployed\");\n        match context_menu {\n            CodeContextMenu::Completions(completions_menu) => {\n                let completions = completions_menu.completions.borrow_mut();\n                dbg!(<|user_cursor_is_here|>)\n                assert_eq!(\n                    completions\n                        .iter()\n                        .map(|completion| &dbg!(&completion.label).text)\n                        .collect::<Vec<_>>(),\n                    vec![\"method id()\", \"other\"],\n                    \"Should update first completion label, but not second as the filter text did not match.\"\n                );\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_completions_resolve_happens_once(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            completion_provider: Some(lsp::CompletionOptions {\n                trigger_characters: Some(vec![\".\".to_string()]),\n                resolve_provider: Some(true),\n                ..Default::default()\n            }),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {\"fn main() { let a = 2ˇ; }\"});\n    cx.simulate_keystroke(\".\");\n\n    let unresolved_item_1 = lsp::CompletionItem {\n        label: \"id\".to_string(),\n        filter_text: Some(\"id\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".id\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n    let resolved_item_1 = lsp::CompletionItem {\n        additional_text_edits: Some(vec![lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 20), lsp::Position::new(0, 22)),\n            new_text: \"!!\".to_string(),\n        }]),\n        ..unresolved_item_1.clone()\n    };\n    let unresolved_item_2 = lsp::CompletionItem {\n        label: \"other\".to_string(),\n<|editable_region_end|>\n    let unresolved_item_2 = lsp::CompletionItem {\n```"
  },
  "max_tokens": 1024
}