{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -232,7 +232,11 @@\n                         if let Some(label) = format_function(&completion) {\n                             return Some(label);\n                         }\n-                    } else if completion.detail.as_ref().map_or(false, |detail| detail.eq(\"type\"){\n+                    } else if completion\n+                        .detail\n+                        .as_ref()\n+                        .map_or(false, |detail| detail.eq(\"type\"))\n+                    {\n                         let code = format!(\"struct {}\", completion.label);\n                         return Some(zed_extension_api::CodeLabel {\n                             spans: vec![CodeLabelSpan::code_range(Range {\n\n```\n\nUser edited \"src/apprt/embedded.zig\":\n```diff\n@@ -1338,6 +1338,7 @@\n         opts: *const apprt.runtime.App.Options,\n         config: *const Config,\n     ) !*App {\n+        \n         var core_app = try CoreApp.create(global.alloc);\n         errdefer core_app.destroy();\n \n\n```\n\nUser edited \"src/apprt/embedded.zig\":\n```diff\n@@ -1338,7 +1338,7 @@\n         opts: *const apprt.runtime.App.Options,\n         config: *const Config,\n     ) !*App {\n-        \n+        e\n         var core_app = try CoreApp.create(global.alloc);\n         errdefer core_app.destroy();\n \n\n```\n\nUser edited \"src/apprt/embedded.zig\":\n```diff\n@@ -1338,7 +1338,7 @@\n         opts: *const apprt.runtime.App.Options,\n         config: *const Config,\n     ) !*App {\n-        e\n+        std.\n         var core_app = try CoreApp.create(global.alloc);\n         errdefer core_app.destroy();\n \n\n```\n\n\n\n\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1885,7 +1885,9 @@\n                          attach,\n                          path,\n                          settings,\n-                     }| match attach {\n+                     }| {\n+                         dbg!(&path, )\n+                         match attach {\n                         language::Attach::InstancePerRoot => {\n                             // todo: handle instance per root proper.\n                             if let Some(server_ids) = self\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1886,7 +1886,7 @@\n                          path,\n                          settings,\n                      }| {\n-                         dbg!(&path, )\n+                         dbg!(&path, &server_name);\n                          match attach {\n                         language::Attach::InstancePerRoot => {\n                             // todo: handle instance per root proper.\n\n```\n\n### Input:\n```crates/project/src/lsp_store.rs\n            return;\n<|editable_region_start|>\n        }\n\n        let abs_path = file.abs_path(cx);\n        let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n            return;\n        };\n        let initial_snapshot = buffer.text_snapshot();\n        let worktree_id = file.worktree_id(cx);\n\n        let Some(language) = buffer.language().cloned() else {\n            return;\n        };\n        let path: Arc<Path> = file\n            .path()\n            .parent()\n            .map(Arc::from)\n            .unwrap_or_else(|| file.path().clone());\n        let Some(worktree) = self\n            .worktree_store\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n        else {\n            return;\n        };\n        let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n        let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n            this.get(\n                ProjectPath { worktree_id, path },\n                AdapterQuery::Language(&language.name()),\n                delegate.clone(),\n                cx,\n            )\n            .collect::<Vec<_>>()\n        });\n        let servers = servers\n            .into_iter()\n            .filter_map(|server_node| {\n                let server_id = server_node.server_id_or_init(\n                    |LaunchDisposition {\n                         server_name,\n                         attach,\n                         path,\n                         settings,\n                     }| {\n                         dbg!(&path, &server_name);<|user_cursor_is_here|>\n                         match attach {\n                        language::Attach::InstancePerRoot => {\n                            // todo: handle instance per root proper.\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&(worktree_id, server_name.clone()))\n                            {\n                                server_ids.iter().cloned().next().unwrap()\n                            } else {\n                                let language_name = language.name();\n\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                )\n                            }\n                        }\n                        language::Attach::Shared => {\n                            let uri = Url::from_directory_path(\n                                worktree.read(cx).abs_path().join(&path.path),\n                            );\n                            let key = (worktree_id, server_name.clone());\n                            if !self.language_server_ids.contains_key(&key) {\n                                let language_name = language.name();\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                );\n                            }\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&key)\n<|editable_region_end|>\n                                .language_server_ids\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/lsp_store.rs\n            return;\n<|editable_region_start|>\n        }\n\n        let abs_path = file.abs_path(cx);\n        let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n            return;\n        };\n        let initial_snapshot = buffer.text_snapshot();\n        let worktree_id = file.worktree_id(cx);\n\n        let Some(language) = buffer.language().cloned() else {\n            return;\n        };\n        let path: Arc<Path> = file\n            .path()\n            .parent()\n            .map(Arc::from)\n            .unwrap_or_else(|| file.path().clone());\n        let Some(worktree) = self\n            .worktree_store\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n        else {\n            return;\n        };\n        let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n        let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n            this.get(\n                ProjectPath { worktree_id, path },\n                AdapterQuery::Language(&language.name()),\n                delegate.clone(),\n                cx,\n            )\n            .collect::<Vec<_>>()\n        });\n        let servers = servers\n            .into_iter()\n            .filter_map(|server_node| {\n                let server_id = server_node.server_id_or_init(\n                    |LaunchDisposition {\n                         server_name,\n                         attach,\n                         path,\n                         settings,\n                     }| {\n                         dbg!(&path, &server_name);<|user_cursor_is_here|>\n                         match attach {\n                        language::Attach::InstancePerRoot => {\n                            // todo: handle instance per root proper.\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&(worktree_id, server_name.clone()))\n                            {\n                                server_ids.iter().cloned().next().unwrap()\n                            } else {\n                                let language_name = language.name();\n\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                )\n                            }\n                        }\n                        language::Attach::Shared => {\n                            let uri = Url::from_directory_path(\n                                worktree.read(cx).abs_path().join(&path.path),\n                            );\n                            let key = (worktree_id, server_name.clone());\n                            if !self.language_server_ids.contains_key(&key) {\n                                let language_name = language.name();\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n                                        .expect(\"To find LSP adapter\"),\n                                    settings,\n                                    cx,\n                                );\n                            }\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&key)\n<|editable_region_end|>\n                                .language_server_ids\n```"
  },
  "max_tokens": 1024
}