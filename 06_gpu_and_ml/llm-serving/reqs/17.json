{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -181,7 +181,7 @@\n         fn format_function(completion: &Completion) -> Option<zed_extension_api::CodeLabel> {\n             let completion_len = completion.label.len();\n             let details = completion.label_details.as_ref()?;\n-            let (detail, description) = details.detail.zip(details.description)?;\n+            let (detail, description) = details.detail.as_ref().zip(details.description)?;\n \n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, description, detail);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -181,7 +181,8 @@\n         fn format_function(completion: &Completion) -> Option<zed_extension_api::CodeLabel> {\n             let completion_len = completion.label.len();\n             let details = completion.label_details.as_ref()?;\n-            let (detail, description) = details.detail.as_ref().zip(details.description)?;\n+            let (detail, description) =\n+                details.detail.as_ref().zip(details.description.as_ref())?;\n \n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, description, detail);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -185,7 +185,7 @@\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n \n             let (spans, code) = {\n-                let code = format!(\"fn {}{} {}\", completion.label, description, detail);\n+                let code = format!(\"fn {}{} {}\", completion.label,  detail);\n                 (vec![CodeLabelSpan::code_range(0..code.len())], code)\n             };\n             let start = \"fn \".len() as u32;\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -185,7 +185,7 @@\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n \n             let (spans, code) = {\n-                let code = format!(\"fn {}{} {}\", completion.label,  detail);\n+                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 (vec![CodeLabelSpan::code_range(0..code.len())], code)\n             };\n             let start = \"fn \".len() as u32;\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -218,7 +218,9 @@\n                         return Some(label);\n                     }\n                 }\n-                CompletionKind::Snippet\n+                CompletionKind::Snippet => {\n+                    \n+                }\n                     if completion\n                         .detail\n                         .as_ref()\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -219,8 +219,6 @@\n                     }\n                 }\n                 CompletionKind::Snippet => {\n-                    \n-                }\n                     if completion\n                         .detail\n                         .as_ref()\n@@ -230,6 +228,8 @@\n                         return Some(label);\n                     }\n                 }\n+                }\n+\n                 _ => {}\n             }\n         }\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -222,7 +222,7 @@\n                     if completion\n                         .detail\n                         .as_ref()\n-                        .map_or(false, |detail| detail.starts_with(\"fn \")) =>\n+                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                 {\n                     if let Some(label) = format_function(&completion) {\n                         return Some(label);\n\n```\n\n### Input:\n```extensions/zig/src/zig.rs\n                }\n<|editable_region_start|>\n            }\n        }\n\n        self.cached_binary_path = Some(binary_path.clone());\n        Ok(ZlsBinary {\n            path: binary_path,\n            args,\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion) -> Option<zed_extension_api::CodeLabel> {\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                (vec![CodeLabelSpan::code_range(0..code.len())], code)\n            };\n            let start = \"fn \".len() as u32;\n            return Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    start,\n                    end: start + completion_len as u32,\n                },\n            });\n        }\n        if let Some(kind) = completion.kind {\n            d<|user_cursor_is_here|>\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Snippet => {\n                    dbg!(&completion);\n                    if completion\n                        .detail\n                        .as_ref()\n                            .map_or(false, |detail| detail.starts_with(\"fn \"))\n                {\n                    if let Some(label) = format_function(&completion) {\n                            return Some(label);\n                        }\n                }\n                }\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n            spans: vec![],\n            filter_range: Range {\n                start: 0,\n                end: completion_len as u32,\n            },\n        })\n    }\n}\n\nzed::register_extension!(ZigExtension);\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```extensions/zig/src/zig.rs\n                }\n<|editable_region_start|>\n            }\n        }\n\n        self.cached_binary_path = Some(binary_path.clone());\n        Ok(ZlsBinary {\n            path: binary_path,\n            args,\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion) -> Option<zed_extension_api::CodeLabel> {\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                (vec![CodeLabelSpan::code_range(0..code.len())], code)\n            };\n            let start = \"fn \".len() as u32;\n            return Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    start,\n                    end: start + completion_len as u32,\n                },\n            });\n        }\n        if let Some(kind) = completion.kind {\n            d<|user_cursor_is_here|>\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Snippet => {\n                    dbg!(&completion);\n                    if completion\n                        .detail\n                        .as_ref()\n                            .map_or(false, |detail| detail.starts_with(\"fn \"))\n                {\n                    if let Some(label) = format_function(&completion) {\n                            return Some(label);\n                        }\n                }\n                }\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n            spans: vec![],\n            filter_range: Range {\n                start: 0,\n                end: completion_len as u32,\n            },\n        })\n    }\n}\n\nzed::register_extension!(ZigExtension);\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}