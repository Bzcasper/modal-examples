{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/zed/src/zed/inline_completion_registry.rs\":\n```diff\n@@ -11,6 +11,7 @@\n use settings::SettingsStore;\n use supermaven::{Supermaven, SupermavenCompletionProvider};\n use ui::Window;\n+use workspace::Workspace;\n use zed_predict_onboarding::ZedPredictModal;\n \n pub fn init(client: Arc<Client>, user_store: Entity<UserStore>, fs: Arc<dyn Fs>, cx: &mut App) {\n\n```\n\nUser edited \"crates/zed/src/zed/inline_completion_registry.rs\":\n```diff\n@@ -288,7 +288,7 @@\n                     });\n                     editor.set_inline_completion_provider(Some(provider), window, cx);\n                 } else {\n-                    dbg!(window.root::<Workspace>().flatten());\n+                    dbg!();\n                 }\n             }\n         }\n\n```\n\nUser edited \"crates/zed/src/zed/inline_completion_registry.rs\":\n```diff\n@@ -263,7 +263,7 @@\n                     }\n                 }\n \n-                if let Some(workspace) = editor.workspace() {\n+                if let Some(workspace) = window.root::<Workspace>().flatten() {\n                     let project_abs_path = singleton_buffer.and_then(|buffer| {\n                         buffer.update(cx, |buffer, cx| {\n                             buffer.file().and_then(|file| {\n\n```\n\nUser edited \"crates/zed/src/zed/inline_completion_registry.rs\":\n```diff\n@@ -287,8 +287,6 @@\n                         )\n                     });\n                     editor.set_inline_completion_provider(Some(provider), window, cx);\n-                } else {\n-                    dbg!();\n                 }\n             }\n         }\n\n```\n\n\n\nUser edited \"crates/zeta/src/persistence.rs\":\n```diff\n@@ -37,6 +37,7 @@\n \n     query! {\n         pub async fn save_accepted_data_collection(project_path: PathBuf, accepted_data_collection: bool) -> Result<()> {\n+            \n             INSERT INTO zeta_preferences\n                 (project_path, accepted_data_collection)\n             VALUES\n\n```\n\nUser edited \"crates/zeta/src/persistence.rs\":\n```diff\n@@ -37,7 +37,6 @@\n \n     query! {\n         pub async fn save_accepted_data_collection(project_path: PathBuf, accepted_data_collection: bool) -> Result<()> {\n-            \n             INSERT INTO zeta_preferences\n                 (project_path, accepted_data_collection)\n             VALUES\n\n```\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -911,6 +911,7 @@\n             .insert(absolute_path_of_project_worktree.clone(), can_collect_data);\n \n         db::write_and_log(cx, move || {\n+            println!(\"PERSISTING!!\")\n             persistence::DB\n                 .save_accepted_data_collection(absolute_path_of_project_worktree, can_collect_data)\n         });\n\n```\n\n### Input:\n```crates/zeta/src/zeta.rs\n            output_excerpt = completion.output_excerpt,\n<|editable_region_start|>\n            feedback\n        );\n        self.client.telemetry().flush_events();\n        cx.notify();\n    }\n\n    pub fn shown_completions(&self) -> impl DoubleEndedIterator<Item = &InlineCompletion> {\n        self.shown_completions.iter()\n    }\n\n    pub fn shown_completions_len(&self) -> usize {\n        self.shown_completions.len()\n    }\n\n    fn report_changes_for_buffer(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> BufferSnapshot {\n        self.register_buffer(buffer, cx);\n\n        let registered_buffer = self\n            .registered_buffers\n            .get_mut(&buffer.entity_id())\n            .unwrap();\n        let new_snapshot = buffer.read(cx).snapshot();\n\n        if new_snapshot.version != registered_buffer.snapshot.version {\n            let old_snapshot = mem::replace(&mut registered_buffer.snapshot, new_snapshot.clone());\n            self.push_event(Event::BufferChange {\n                old_snapshot,\n                new_snapshot: new_snapshot.clone(),\n                timestamp: Instant::now(),\n            });\n        }\n\n        new_snapshot\n    }\n\n    pub fn data_collection_choice_at(&self, path: &Path) -> DataCollectionChoice {\n        match self.data_collection_preferences.per_worktree.get(path) {\n            Some(true) => DataCollectionChoice::Enabled,\n            Some(false) => DataCollectionChoice::Disabled,\n            None => DataCollectionChoice::NotAnswered,\n        }\n    }\n\n    fn update_data_collection_preference_for_project(\n        &mut self,\n        absolute_path_of_project_worktree: PathBuf,\n        can_collect_data: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.data_collection_preferences\n            .per_worktree\n            .insert(absolute_path_of_project_worktree.clone(), can_collect_data);\n\n        db::write_and_log(cx, move || {\n            println!(\"PERSISTING!!<|user_cursor_is_here|>\")\n            persistence::DB\n                .save_accepted_data_collection(absolute_path_of_project_worktree, can_collect_data)\n        });\n    }\n\n    fn set_never_ask_again_for_data_collection(&mut self, cx: &mut Context<Self>) {\n        self.data_collection_preferences.never_ask_again = true;\n\n        // persist choice\n        db::write_and_log(cx, move || {\n            KEY_VALUE_STORE.write_kvp(\n                ZED_PREDICT_DATA_COLLECTION_NEVER_ASK_AGAIN_KEY.into(),\n                \"true\".to_string(),\n            )\n        });\n    }\n\n    fn load_data_collection_preferences(cx: &mut Context<Self>) -> DataCollectionPreferences {\n        if env::var(\"ZED_PREDICT_CLEAR_DATA_COLLECTION_PREFERENCES\").is_ok() {\n            db::write_and_log(cx, move || async move {\n                KEY_VALUE_STORE\n                    .delete_kvp(ZED_PREDICT_DATA_COLLECTION_NEVER_ASK_AGAIN_KEY.into())\n                    .await\n                    .log_err();\n\n                persistence::DB.clear_all_zeta_preferences().await\n            });\n            return DataCollectionPreferences::default();\n        }\n\n        let never_ask_again = KEY_VALUE_STORE\n            .read_kvp(ZED_PREDICT_DATA_COLLECTION_NEVER_ASK_AGAIN_KEY)\n            .log_err()\n            .flatten()\n            .map(|value| value == \"true\")\n            .unwrap_or(false);\n\n        let preferences_per_project = persistence::DB\n            .get_all_zeta_preferences()\n            .log_err()\n            .unwrap_or_else(HashMap::default);\n\n        DataCollectionPreferences {\n            never_ask_again,\n            per_worktree: preferences_per_project,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\nstruct DataCollectionPreferences {\n    /// Set when a user clicks on \"Never Ask Again\", can never be unset.\n    never_ask_again: bool,\n    per_worktree: HashMap<PathBuf, bool>,\n}\n\nfn common_prefix<T1: Iterator<Item = char>, T2: Iterator<Item = char>>(a: T1, b: T2) -> usize {\n    a.zip(b)\n        .take_while(|(a, b)| a == b)\n        .map(|(a, _)| a.len_utf8())\n<|editable_region_end|>\n        .take_while(|(a, b)| a == b)\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/zeta/src/zeta.rs\n            output_excerpt = completion.output_excerpt,\n<|editable_region_start|>\n            feedback\n        );\n        self.client.telemetry().flush_events();\n        cx.notify();\n    }\n\n    pub fn shown_completions(&self) -> impl DoubleEndedIterator<Item = &InlineCompletion> {\n        self.shown_completions.iter()\n    }\n\n    pub fn shown_completions_len(&self) -> usize {\n        self.shown_completions.len()\n    }\n\n    fn report_changes_for_buffer(\n        &mut self,\n        buffer: &Entity<Buffer>,\n        cx: &mut Context<Self>,\n    ) -> BufferSnapshot {\n        self.register_buffer(buffer, cx);\n\n        let registered_buffer = self\n            .registered_buffers\n            .get_mut(&buffer.entity_id())\n            .unwrap();\n        let new_snapshot = buffer.read(cx).snapshot();\n\n        if new_snapshot.version != registered_buffer.snapshot.version {\n            let old_snapshot = mem::replace(&mut registered_buffer.snapshot, new_snapshot.clone());\n            self.push_event(Event::BufferChange {\n                old_snapshot,\n                new_snapshot: new_snapshot.clone(),\n                timestamp: Instant::now(),\n            });\n        }\n\n        new_snapshot\n    }\n\n    pub fn data_collection_choice_at(&self, path: &Path) -> DataCollectionChoice {\n        match self.data_collection_preferences.per_worktree.get(path) {\n            Some(true) => DataCollectionChoice::Enabled,\n            Some(false) => DataCollectionChoice::Disabled,\n            None => DataCollectionChoice::NotAnswered,\n        }\n    }\n\n    fn update_data_collection_preference_for_project(\n        &mut self,\n        absolute_path_of_project_worktree: PathBuf,\n        can_collect_data: bool,\n        cx: &mut Context<Self>,\n    ) {\n        self.data_collection_preferences\n            .per_worktree\n            .insert(absolute_path_of_project_worktree.clone(), can_collect_data);\n\n        db::write_and_log(cx, move || {\n            println!(\"PERSISTING!!<|user_cursor_is_here|>\")\n            persistence::DB\n                .save_accepted_data_collection(absolute_path_of_project_worktree, can_collect_data)\n        });\n    }\n\n    fn set_never_ask_again_for_data_collection(&mut self, cx: &mut Context<Self>) {\n        self.data_collection_preferences.never_ask_again = true;\n\n        // persist choice\n        db::write_and_log(cx, move || {\n            KEY_VALUE_STORE.write_kvp(\n                ZED_PREDICT_DATA_COLLECTION_NEVER_ASK_AGAIN_KEY.into(),\n                \"true\".to_string(),\n            )\n        });\n    }\n\n    fn load_data_collection_preferences(cx: &mut Context<Self>) -> DataCollectionPreferences {\n        if env::var(\"ZED_PREDICT_CLEAR_DATA_COLLECTION_PREFERENCES\").is_ok() {\n            db::write_and_log(cx, move || async move {\n                KEY_VALUE_STORE\n                    .delete_kvp(ZED_PREDICT_DATA_COLLECTION_NEVER_ASK_AGAIN_KEY.into())\n                    .await\n                    .log_err();\n\n                persistence::DB.clear_all_zeta_preferences().await\n            });\n            return DataCollectionPreferences::default();\n        }\n\n        let never_ask_again = KEY_VALUE_STORE\n            .read_kvp(ZED_PREDICT_DATA_COLLECTION_NEVER_ASK_AGAIN_KEY)\n            .log_err()\n            .flatten()\n            .map(|value| value == \"true\")\n            .unwrap_or(false);\n\n        let preferences_per_project = persistence::DB\n            .get_all_zeta_preferences()\n            .log_err()\n            .unwrap_or_else(HashMap::default);\n\n        DataCollectionPreferences {\n            never_ask_again,\n            per_worktree: preferences_per_project,\n        }\n    }\n}\n\n#[derive(Default, Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\nstruct DataCollectionPreferences {\n    /// Set when a user clicks on \"Never Ask Again\", can never be unset.\n    never_ask_again: bool,\n    per_worktree: HashMap<PathBuf, bool>,\n}\n\nfn common_prefix<T1: Iterator<Item = char>, T2: Iterator<Item = char>>(a: T1, b: T2) -> usize {\n    a.zip(b)\n        .take_while(|(a, b)| a == b)\n        .map(|(a, _)| a.len_utf8())\n<|editable_region_end|>\n        .take_while(|(a, b)| a == b)\n```"
  },
  "max_tokens": 1024
}