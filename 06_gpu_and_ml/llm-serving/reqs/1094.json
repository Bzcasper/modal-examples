{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -3689,7 +3689,7 @@\n             }\n         }\n \n-        self.fun_name(cx);~~~~~\n+        self.fun_name(cx);~~~~\n \n         if let Some(prettier_store) = self.as_local().map(|s| s.prettier_store.clone()) {\n             prettier_store.update(cx, |prettier_store, cx| {\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -41,7 +41,7 @@\n   - Sorry about this! I can't easily reproduce the problem. Does this happen on all projects, or just some? Is there anything relevant in the Zed logs?\n       tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - That doesn't sound good... Can you please clarify the steps you took to make this happen?\n-      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n+e      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - Looks like a recent regression, cc @victim - could you please take a look?\n   - Makes sense. We're working on Windows/Git/AI/etc. and will look into this as part of that (tag:\"windows\", e.g.)\n   \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -41,7 +41,7 @@\n   - Sorry about this! I can't easily reproduce the problem. Does this happen on all projects, or just some? Is there anything relevant in the Zed logs?\n       tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - That doesn't sound good... Can you please clarify the steps you took to make this happen?\n-e      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n+      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - Looks like a recent regression, cc @victim - could you please take a look?\n   - Makes sense. We're working on Windows/Git/AI/etc. and will look into this as part of that (tag:\"windows\", e.g.)\n   \n\n```\n\n### Input:\n```crates/picker/src/picker.rs\n        } else {\n<|editable_region_start|>\n            cx.propagate()\n        }\n    }\n\n    fn handle_click(\n        &mut self,\n        ix: usize,\n        secondary: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        cx.stop_propagation();\n        window.prevent_default();\n        self.set_selected_index(ix, false, window, cx);\n        self.do_confirm(secondary, window, cx)\n    }\n\n    fn do_confirm(&mut self, secondary: bool, window: &mut Window, cx: &mut Context<Self>) {\n        if let Some(update_query) = self.delegate.confirm_update_query(window, cx) {\n            self.set_query(update_query, window, cx);\n            self.delegate.set_selected_index(0, window, cx);\n        } else {\n            self.delegate.confirm(secondary, window, cx)\n        }\n    }\n\n    fn on_input_editor_event(\n        &mut self,\n        _: &Entity<Editor>,\n        event: &editor::EditorEvent,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Head::Editor(ref editor) = &self.head else {\n            panic!(\"unexpected call\");\n        };\n        match event {\n            editor::EditorEvent::BufferEdited => {\n                let query = editor.read(cx).text(cx);\n                self.update_matches(query, window, cx);\n            }\n            editor::EditorEvent::Blurred => {\n                self.cancel(&menu::Cancel, window, cx);\n            }\n            _ => {}\n        }\n    }\n\n    fn on_empty_head_blur(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let Head::Empty(_) = &self.head else {\n            panic!(\"unexpected call\");\n        };\n        self.c<|user_cursor_is_here|>ancel(&menu::Cancel, window, cx);\n    }\n\n    pub fn refresh_placeholder(&mut self, window: &mut Window, cx: &mut App) {\n        match &self.head {\n            Head::Editor(editor) => {\n                let placeholder = self.delegate.placeholder_text(window, cx);\n                editor.update(cx, |editor, cx| {\n                    editor.set_placeholder_text(placeholder, cx);\n                    cx.notify();\n                });\n            }\n            Head::Empty(_) => {}\n        }\n    }\n\n    pub fn refresh(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let query = self.query(cx);\n        self.update_matches(query, window, cx);\n    }\n\n    pub fn update_matches(&mut self, query: String, window: &mut Window, cx: &mut Context<Self>) {\n        let delegate_pending_update_matches = self.delegate.update_matches(query, window, cx);\n\n        self.matches_updated(window, cx);\n        // This struct ensures that we can synchronously drop the task returned by the\n        // delegate's `update_matches` method and the task that the picker is spawning.\n        // If we simply capture the delegate's task into the picker's task, when the picker's\n        // task gets synchronously dropped, the delegate's task would keep running until\n        // the picker's task has a chance of being scheduled, because dropping a task happens\n        // asynchronously.\n        self.pending_update_matches = Some(PendingUpdateMatches {\n            delegate_update_matches: Some(delegate_pending_update_matches),\n            _task: cx.spawn_in(window, |this, mut cx| async move {\n                let delegate_pending_update_matches = this.update(&mut cx, |this, _| {\n                    this.pending_update_matches\n                        .as_mut()\n                        .unwrap()\n                        .delegate_update_matches\n                        .take()\n                        .unwrap()\n                })?;\n                delegate_pending_update_matches.await;\n                this.update_in(&mut cx, |this, window, cx| {\n                    this.matches_updated(window, cx);\n                })\n            }),\n        });\n    }\n\n    fn matches_updated(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if let ElementContainer::List(state) = &mut self.element_container {\n            state.reset(self.delegate.match_count());\n        }\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/picker/src/picker.rs\n        } else {\n<|editable_region_start|>\n            cx.propagate()\n        }\n    }\n\n    fn handle_click(\n        &mut self,\n        ix: usize,\n        secondary: bool,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        cx.stop_propagation();\n        window.prevent_default();\n        self.set_selected_index(ix, false, window, cx);\n        self.do_confirm(secondary, window, cx)\n    }\n\n    fn do_confirm(&mut self, secondary: bool, window: &mut Window, cx: &mut Context<Self>) {\n        if let Some(update_query) = self.delegate.confirm_update_query(window, cx) {\n            self.set_query(update_query, window, cx);\n            self.delegate.set_selected_index(0, window, cx);\n        } else {\n            self.delegate.confirm(secondary, window, cx)\n        }\n    }\n\n    fn on_input_editor_event(\n        &mut self,\n        _: &Entity<Editor>,\n        event: &editor::EditorEvent,\n        window: &mut Window,\n        cx: &mut Context<Self>,\n    ) {\n        let Head::Editor(ref editor) = &self.head else {\n            panic!(\"unexpected call\");\n        };\n        match event {\n            editor::EditorEvent::BufferEdited => {\n                let query = editor.read(cx).text(cx);\n                self.update_matches(query, window, cx);\n            }\n            editor::EditorEvent::Blurred => {\n                self.cancel(&menu::Cancel, window, cx);\n            }\n            _ => {}\n        }\n    }\n\n    fn on_empty_head_blur(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let Head::Empty(_) = &self.head else {\n            panic!(\"unexpected call\");\n        };\n        self.c<|user_cursor_is_here|>ancel(&menu::Cancel, window, cx);\n    }\n\n    pub fn refresh_placeholder(&mut self, window: &mut Window, cx: &mut App) {\n        match &self.head {\n            Head::Editor(editor) => {\n                let placeholder = self.delegate.placeholder_text(window, cx);\n                editor.update(cx, |editor, cx| {\n                    editor.set_placeholder_text(placeholder, cx);\n                    cx.notify();\n                });\n            }\n            Head::Empty(_) => {}\n        }\n    }\n\n    pub fn refresh(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        let query = self.query(cx);\n        self.update_matches(query, window, cx);\n    }\n\n    pub fn update_matches(&mut self, query: String, window: &mut Window, cx: &mut Context<Self>) {\n        let delegate_pending_update_matches = self.delegate.update_matches(query, window, cx);\n\n        self.matches_updated(window, cx);\n        // This struct ensures that we can synchronously drop the task returned by the\n        // delegate's `update_matches` method and the task that the picker is spawning.\n        // If we simply capture the delegate's task into the picker's task, when the picker's\n        // task gets synchronously dropped, the delegate's task would keep running until\n        // the picker's task has a chance of being scheduled, because dropping a task happens\n        // asynchronously.\n        self.pending_update_matches = Some(PendingUpdateMatches {\n            delegate_update_matches: Some(delegate_pending_update_matches),\n            _task: cx.spawn_in(window, |this, mut cx| async move {\n                let delegate_pending_update_matches = this.update(&mut cx, |this, _| {\n                    this.pending_update_matches\n                        .as_mut()\n                        .unwrap()\n                        .delegate_update_matches\n                        .take()\n                        .unwrap()\n                })?;\n                delegate_pending_update_matches.await;\n                this.update_in(&mut cx, |this, window, cx| {\n                    this.matches_updated(window, cx);\n                })\n            }),\n        });\n    }\n\n    fn matches_updated(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n        if let ElementContainer::List(state) = &mut self.element_container {\n            state.reset(self.delegate.match_count());\n        }\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}