{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8077,10 +8077,7 @@\n         };\n \n         let mut label = label.unwrap_or_else(|| {\n-            CodeLabel::plain(\n-                lsp_completion.label.clone(),\n-                lsp_completion.filter_text.as_deref(),\n-            )\n+            CodeLabel::fallback_for_completion(&completion_item, language.as_deref())\n         });\n         ensure_uniform_list_compatible_label(&mut label);\n \n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8878,7 +8878,7 @@\n /// Completion items are displayed in a `UniformList`.\n /// Usually, those items are single-line strings, but in LSP responses,\n /// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n-/// Many language plugins construct these items by joining these parts together, and we may fall back to `CodeLabel::plain` that uses `label`.\n+/// Many language plugins construct these items by joining these parts together, and we may fall back to `CodeLabel::fallback_for_completion` that uses `label`.\n /// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n /// breaking the completions menu presentation.\n ///\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8878,7 +8878,7 @@\n /// Completion items are displayed in a `UniformList`.\n /// Usually, those items are single-line strings, but in LSP responses,\n /// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n-/// Many language plugins construct these items by joining these parts together, and we may fall back to `CodeLabel::fallback_for_completion` that uses `label`.\n+/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label`.\n /// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n /// breaking the completions menu presentation.\n ///\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8878,7 +8878,7 @@\n /// Completion items are displayed in a `UniformList`.\n /// Usually, those items are single-line strings, but in LSP responses,\n /// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n-/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label`.\n+/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label` at least.\n /// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n /// breaking the completions menu presentation.\n ///\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8077,7 +8077,7 @@\n         };\n \n         let mut label = label.unwrap_or_else(|| {\n-            CodeLabel::fallback_for_completion(&completion_item, language.as_deref())\n+            CodeLabel::fallback_for_completion(&lsp_completion, language.as_deref())\n         });\n         ensure_uniform_list_compatible_label(&mut label);\n \n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -4392,7 +4392,7 @@\n         .pop()\n         .flatten()\n         .unwrap_or_else(|| {\n-            CodeLabel::fallback_for_completion(&completion_item, language.as_deref())\n+            CodeLabel::fallback_for_completion(&completion_item, language.map(|language| language.as_))\n         });\n         ensure_uniform_list_compatible_label(&mut new_label);\n \n\n```\n\n### Input:\n```crates/project/src/lsp_store.rs\n            }\n<|editable_region_start|>\n        }\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        completion.lsp_completion = completion_item;\n        completion.resolved = true;\n        Ok(())\n    }\n\n    async fn regenerate_completion_labels(\n        adapter: Arc<CachedLspAdapter>,\n        snapshot: &BufferSnapshot,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let completion_item = completions.borrow()[completion_index]\n            .lsp_completion\n            .clone();\n        if let Some(lsp_documentation) = completion_item.documentation.as_ref() {\n            let documentation = language::prepare_completion_documentation(\n                lsp_documentation,\n                &language_registry,\n                snapshot.language().cloned(),\n            )\n            .await;\n\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(documentation);\n        } else {\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(Documentation::Undocumented);\n        }\n\n        // NB: Zed does not have `details` inside the completion resolve capabilities, but certain language servers violate the spec and do not return `details` immediately, e.g. https://github.com/yioneko/vtsls/issues/213\n        // So we have to update the label here anyway...\n        let language = snapshot.language();\n        let mut new_label = match language {\n            Some(language) => {\n                adapter\n                    .labels_for_completions(&[completion_item.clone()], language)\n                    .await?\n            }\n            None => Vec::new(),\n        }\n        .pop()\n        .flatten()\n        .unwrap_or_else(|| {\n            CodeLabel::fallback_for_completion(&completion_item, language.map(|language| language.as_ref()clip<|user_cursor_is_here|>))\n        });\n        ensure_uniform_list_compatible_label(&mut new_label);\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        if completion.label.filter_text() == new_label.filter_text() {\n            completion.label = new_label;\n        } else {\n            log::error!(\n                \"Resolved completion changed display label from {} to {}. \\\n                 Refusing to apply this because it changes the fuzzy match text from {} to {}\",\n                completion.label.text(),\n                new_label.text(),\n                completion.label.filter_text(),\n                new_label.filter_text()\n            );\n        }\n\n        Ok(())\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    async fn resolve_completion_remote(\n        project_id: u64,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        client: AnyProtoClient,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let lsp_completion = {\n            let completion = &completions.borrow()[completion_index];\n            if completion.resolved {\n                return Ok(());\n            }\n            serde_json::to_string(&completion.lsp_completion)\n                .unwrap()\n                .into_bytes()\n        };\n        let request = proto::ResolveCompletionDocumentation {\n            project_id,\n            language_server_id: server_id.0 as u64,\n            lsp_completion,\n            buffer_id: buffer_id.into(),\n        };\n\n        let response = client\n            .request(request)\n            .await\n            .context(\"completion documentation resolve proto request\")?;\n        let lsp_completion = serde_json::from_slice(&response.lsp_completion)?;\n<|editable_region_end|>\n            .context(\"completion documentation resolve proto request\")?;\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/lsp_store.rs\n            }\n<|editable_region_start|>\n        }\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        completion.lsp_completion = completion_item;\n        completion.resolved = true;\n        Ok(())\n    }\n\n    async fn regenerate_completion_labels(\n        adapter: Arc<CachedLspAdapter>,\n        snapshot: &BufferSnapshot,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let completion_item = completions.borrow()[completion_index]\n            .lsp_completion\n            .clone();\n        if let Some(lsp_documentation) = completion_item.documentation.as_ref() {\n            let documentation = language::prepare_completion_documentation(\n                lsp_documentation,\n                &language_registry,\n                snapshot.language().cloned(),\n            )\n            .await;\n\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(documentation);\n        } else {\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(Documentation::Undocumented);\n        }\n\n        // NB: Zed does not have `details` inside the completion resolve capabilities, but certain language servers violate the spec and do not return `details` immediately, e.g. https://github.com/yioneko/vtsls/issues/213\n        // So we have to update the label here anyway...\n        let language = snapshot.language();\n        let mut new_label = match language {\n            Some(language) => {\n                adapter\n                    .labels_for_completions(&[completion_item.clone()], language)\n                    .await?\n            }\n            None => Vec::new(),\n        }\n        .pop()\n        .flatten()\n        .unwrap_or_else(|| {\n            CodeLabel::fallback_for_completion(&completion_item, language.map(|language| language.as_ref()clip<|user_cursor_is_here|>))\n        });\n        ensure_uniform_list_compatible_label(&mut new_label);\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        if completion.label.filter_text() == new_label.filter_text() {\n            completion.label = new_label;\n        } else {\n            log::error!(\n                \"Resolved completion changed display label from {} to {}. \\\n                 Refusing to apply this because it changes the fuzzy match text from {} to {}\",\n                completion.label.text(),\n                new_label.text(),\n                completion.label.filter_text(),\n                new_label.filter_text()\n            );\n        }\n\n        Ok(())\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    async fn resolve_completion_remote(\n        project_id: u64,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        client: AnyProtoClient,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let lsp_completion = {\n            let completion = &completions.borrow()[completion_index];\n            if completion.resolved {\n                return Ok(());\n            }\n            serde_json::to_string(&completion.lsp_completion)\n                .unwrap()\n                .into_bytes()\n        };\n        let request = proto::ResolveCompletionDocumentation {\n            project_id,\n            language_server_id: server_id.0 as u64,\n            lsp_completion,\n            buffer_id: buffer_id.into(),\n        };\n\n        let response = client\n            .request(request)\n            .await\n            .context(\"completion documentation resolve proto request\")?;\n        let lsp_completion = serde_json::from_slice(&response.lsp_completion)?;\n<|editable_region_end|>\n            .context(\"completion documentation resolve proto request\")?;\n```"
  },
  "max_tokens": 1024
}