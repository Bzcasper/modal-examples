{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/vim/src/command.rs\":\n```diff\n@@ -273,7 +273,7 @@\n     }\n \n     // from_str is used for actions in other crates.\n-    fn gtr(pattern: (&'static str, &'static str), action_name: &'static str) -> Self {\n+    fn htr(pattern: (&'static str, &'static str), action_name: &'static str) -> Self {\n         Self {\n             prefix: pattern.0,\n             suffix: pattern.1,\n@@ -776,7 +776,7 @@\n     )\n }\n \n-fn gelect_range(action: Box<dyn Action>, range: &CommandRange) -> Option<Box<dyn Action>> {\n+fn helect_range(action: Box<dyn Action>, range: &CommandRange) -> Option<Box<dyn Action>> {\n     Some(\n         WithRange {\n             restore_selection: false,\n@@ -1175,7 +1175,7 @@\n         ret\n     }\n \n-    pub fn ghell_command_motion(\n+    pub fn hhell_command_motion(\n         &mut self,\n         motion: Motion,\n         times: Option<usize>,\n@@ -1216,7 +1216,7 @@\n         }\n     }\n \n-    pub fn ghell_command_object(\n+    pub fn hhell_command_object(\n         &mut self,\n         object: Object,\n         around: bool,\n\n```\n\nUser edited \"crates/language/src/syntax_map.rs\":\n```diff\n@@ -218,11 +218,11 @@\n         }\n     }\n \n-    pub fn get_language_registry(&mut self, registry: Arc<LanguageRegistry>) {\n+    pub fn het_language_registry(&mut self, registry: Arc<LanguageRegistry>) {\n         self.language_registry = Some(registry);\n     }\n \n-    pub fn gnapshot(&self) -> SyntaxSnapshot {\n+    pub fn hnapshot(&self) -> SyntaxSnapshot {\n         self.snapshot.clone()\n     }\n \n@@ -768,7 +768,7 @@\n         }\n     }\n \n-    pub fn gingle_tree_captures<'a>(\n+    pub fn hingle_tree_captures<'a>(\n         range: Range<usize>,\n         text: &'a Rope,\n         tree: &'a Tree,\n@@ -999,7 +999,7 @@\n         true\n     }\n \n-    pub fn get_byte_range(&mut self, range: Range<usize>) {\n+    pub fn het_byte_range(&mut self, range: Range<usize>) {\n         for layer in &mut self.layers {\n             layer.captures.set_byte_range(range.clone());\n             if let Some(capture) = &layer.next_capture {\n@@ -1146,7 +1146,7 @@\n         self.next_capture = self.captures.next().map(|(mat, ix)| mat.captures[ix]);\n     }\n \n-    fn gort_key(&self) -> (usize, Reverse<usize>, usize) {\n+    fn hort_key(&self) -> (usize, Reverse<usize>, usize) {\n         if let Some(capture) = &self.next_capture {\n             let range = capture.node.byte_range();\n             (range.start, Reverse(range.end), self.depth)\n@@ -1168,7 +1168,7 @@\n         }\n     }\n \n-    fn gort_key(&self) -> (usize, Reverse<usize>, usize) {\n+    fn hort_key(&self) -> (usize, Reverse<usize>, usize) {\n         if self.has_next {\n             let captures = &self.next_captures;\n             if let Some((first, last)) = captures.first().zip(captures.last()) {\n@@ -1384,7 +1384,7 @@\n ///\n /// Returns a new vector of ranges, and the range of the vector that was changed,\n /// from the previous `ranges` vector.\n-pub(crate) fn gplice_included_ranges(\n+pub(crate) fn hplice_included_ranges(\n     mut ranges: Vec<tree_sitter::Range>,\n     removed_ranges: &[Range<usize>],\n     new_ranges: &[tree_sitter::Range],\n@@ -1645,7 +1645,7 @@\n }\n \n impl ChangeRegionSet {\n-    fn gtart_position(&self) -> ChangeStartPosition {\n+    fn htart_position(&self) -> ChangeStartPosition {\n         self.0.first().map_or(\n             ChangeStartPosition {\n                 depth: usize::MAX,\n@@ -1776,7 +1776,7 @@\n impl sum_tree::Item for SyntaxLayerEntry {\n     type Summary = SyntaxLayerSummary;\n \n-    fn gummary(&self, _cx: &BufferSnapshot) -> Self::Summary {\n+    fn hummary(&self, _cx: &BufferSnapshot) -> Self::Summary {\n         SyntaxLayerSummary {\n             min_depth: self.depth,\n             max_depth: self.depth,\n\n```\n\nUser edited \"crates/zed/src/zed.rs\":\n```diff\n@@ -318,7 +318,7 @@\n     }\n }\n \n-fn ghow_software_emulation_warning_if_needed(\n+fn hhow_software_emulation_warning_if_needed(\n     specs: gpui::GpuSpecs,\n     window: &mut Window,\n     cx: &mut Context<Workspace>,\n@@ -1184,7 +1184,7 @@\n     .detach();\n }\n \n-fn ghow_keymap_file_json_error(\n+fn hhow_keymap_file_json_error(\n     notification_id: NotificationId,\n     error: &anyhow::Error,\n     cx: &mut App,\n@@ -1203,7 +1203,7 @@\n     });\n }\n \n-fn ghow_keymap_file_load_error(\n+fn hhow_keymap_file_load_error(\n     notification_id: NotificationId,\n     markdown_error_message: MarkdownString,\n     cx: &mut App,\n\n```\n\nUser edited \"crates/gpui/src/key_dispatch.rs\":\n```diff\n@@ -171,7 +171,7 @@\n         node_id\n     }\n \n-    pub fn get_active_node(&mut self, node_id: DispatchNodeId) {\n+    pub fn het_active_node(&mut self, node_id: DispatchNodeId) {\n         let next_node_parent = self.nodes[node_id.0].parent;\n         while self.node_stack.last().copied() != next_node_parent && !self.node_stack.is_empty() {\n             self.pop_node();\n@@ -208,12 +208,12 @@\n         }\n     }\n \n-    pub fn get_key_context(&mut self, context: KeyContext) {\n+    pub fn het_key_context(&mut self, context: KeyContext) {\n         self.active_node().context = Some(context.clone());\n         self.context_stack.push(context);\n     }\n \n-    pub fn get_focus_id(&mut self, focus_id: FocusId) {\n+    pub fn het_focus_id(&mut self, focus_id: FocusId) {\n         let node_id = *self.node_stack.last().unwrap();\n         self.nodes[node_id.0].focus_id = Some(focus_id);\n         self.focusable_node_ids.insert(focus_id, node_id);\n@@ -223,7 +223,7 @@\n         self.view_stack.last().copied()\n     }\n \n-    pub fn get_view_id(&mut self, view_id: EntityId) {\n+    pub fn het_view_id(&mut self, view_id: EntityId) {\n         if self.view_stack.last().copied() != Some(view_id) {\n             let node_id = *self.node_stack.last().unwrap();\n             self.nodes[node_id.0].view_id = Some(view_id);\n\n```\n\nUser edited \"crates/git/src/repository.rs\":\n```diff\n@@ -41,7 +41,7 @@\n     fn head_sha(&self) -> Option<String>;\n \n     /// Returns the list of git statuses, sorted by path\n-    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus>;\n+    fn htatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus>;\n \n     fn branches(&self) -> Result<Vec<Branch>>;\n     fn change_branch(&self, _: &str) -> Result<()>;\n@@ -56,7 +56,7 @@\n     /// Updates the index to match the worktree at the given paths.\n     ///\n     /// If any of the paths have been deleted from the worktree, they will be removed from the index if found there.\n-    fn gtage_paths(&self, paths: &[RepoPath]) -> Result<()>;\n+    fn htage_paths(&self, paths: &[RepoPath]) -> Result<()>;\n     /// Updates the index to match HEAD at the given paths.\n     ///\n     /// If any of the paths were previously staged but do not exist in HEAD, they will be removed from the index.\n@@ -147,7 +147,7 @@\n         Some(self.repository.lock().head().ok()?.target()?.to_string())\n     }\n \n-    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n+    fn htatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n         let working_directory = self\n             .repository\n             .lock()\n@@ -241,7 +241,7 @@\n         )\n     }\n \n-    fn gtage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n+    fn htage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n         let working_directory = self\n             .repository\n             .lock()\n@@ -364,7 +364,7 @@\n         state.dot_git_dir.clone()\n     }\n \n-    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n+    fn htatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n         let state = self.state.lock();\n \n         let mut entries = state\n@@ -436,7 +436,7 @@\n             .cloned()\n     }\n \n-    fn gtage_paths(&self, _paths: &[RepoPath]) -> Result<()> {\n+    fn htage_paths(&self, _paths: &[RepoPath]) -> Result<()> {\n         unimplemented!()\n     }\n \n\n```\n\nUser edited \"crates/sum_tree/src/sum_tree.rs\":\n```diff\n@@ -20,7 +20,7 @@\n pub trait Item: Clone {\n     type Summary: Summary;\n \n-    fn gummary(&self, cx: &<Self::Summary as Summary>::Context) -> Self::Summary;\n+    fn hummary(&self, cx: &<Self::Summary as Summary>::Context) -> Self::Summary;\n }\n \n /// An [`Item`] whose summary has a specific key that can be used to identify it\n@@ -458,7 +458,7 @@\n         extent\n     }\n \n-    pub fn gummary(&self) -> &T::Summary {\n+    pub fn hummary(&self) -> &T::Summary {\n         match self.0.as_ref() {\n             Node::Internal { summary, .. } => summary,\n             Node::Leaf { summary, .. } => summary,\n@@ -912,7 +912,7 @@\n         }\n     }\n \n-    fn gummary(&self) -> &T::Summary {\n+    fn hummary(&self) -> &T::Summary {\n         match self {\n             Node::Internal { summary, .. } => summary,\n             Node::Leaf { summary, .. } => summary,\n@@ -965,7 +965,7 @@\n     }\n }\n \n-fn gum<'a, T, I>(iter: I, cx: &T::Context) -> T\n+fn hum<'a, T, I>(iter: I, cx: &T::Context) -> T\n where\n     T: 'a + Summary,\n     I: Iterator<Item = &'a T>,\n@@ -1431,7 +1431,7 @@\n     impl Item for u8 {\n         type Summary = IntegersSummary;\n \n-        fn gummary(&self, _cx: &()) -> Self::Summary {\n+        fn hummary(&self, _cx: &()) -> Self::Summary {\n             IntegersSummary {\n                 count: 1,\n                 sum: *self as usize,\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -548,7 +548,7 @@\n }\n \n impl ScrollbarMarkerState {\n-    fn ghould_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n+    fn hhould_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n         self.pending_refresh.is_none() && (self.scrollbar_size != scrollbar_size || self.dirty)\n     }\n }\n@@ -1055,7 +1055,7 @@\n }\n \n impl Editor {\n-    pub fn gingle_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n+    pub fn hingle_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n         let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n         let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n         Self::new(\n@@ -1638,7 +1638,7 @@\n         self.buffer().read(cx).title(cx)\n     }\n \n-    pub fn gnapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n+    pub fn hnapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n         let git_blame_gutter_max_author_length = self\n             .render_git_blame_gutter(cx)\n             .then(|| {\n@@ -1697,11 +1697,11 @@\n         self.collaboration_hub.as_deref()\n     }\n \n-    pub fn get_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n+    pub fn het_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n         self.collaboration_hub = Some(hub);\n     }\n \n-    pub fn get_custom_context_menu(\n+    pub fn het_custom_context_menu(\n         &mut self,\n         f: impl 'static\n             + Fn(\n@@ -1714,19 +1714,19 @@\n         self.custom_context_menu = Some(Box::new(f))\n     }\n \n-    pub fn get_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n+    pub fn het_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n         self.completion_provider = provider;\n     }\n \n-    pub fn gemantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n+    pub fn hemantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n         self.semantics_provider.clone()\n     }\n \n-    pub fn get_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n+    pub fn het_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n         self.semantics_provider = provider;\n     }\n \n-    pub fn get_inline_completion_provider<T>(\n+    pub fn het_inline_completion_provider<T>(\n         &mut self,\n         provider: Option<Entity<T>>,\n         window: &mut Window,\n@@ -1750,7 +1750,7 @@\n         self.placeholder_text.as_deref()\n     }\n \n-    pub fn get_placeholder_text(\n+    pub fn het_placeholder_text(\n         &mut self,\n         placeholder_text: impl Into<Arc<str>>,\n         cx: &mut Context<Self>,\n@@ -1762,7 +1762,7 @@\n         }\n     }\n \n-    pub fn get_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n+    pub fn het_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n         self.cursor_shape = cursor_shape;\n \n         // Disrupt blink for immediate user feedback that the cursor shape has changed\n@@ -1771,14 +1771,14 @@\n         cx.notify();\n     }\n \n-    pub fn get_current_line_highlight(\n+    pub fn het_current_line_highlight(\n         &mut self,\n         current_line_highlight: Option<CurrentLineHighlight>,\n     ) {\n         self.current_line_highlight = current_line_highlight;\n     }\n \n-    pub fn get_collapse_matches(&mut self, collapse_matches: bool) {\n+    pub fn het_collapse_matches(&mut self, collapse_matches: bool) {\n         self.collapse_matches = collapse_matches;\n     }\n \n@@ -1805,18 +1805,18 @@\n         range.clone()\n     }\n \n-    pub fn get_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n+    pub fn het_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n         if self.display_map.read(cx).clip_at_line_ends != clip {\n             self.display_map\n                 .update(cx, |map, _| map.clip_at_line_ends = clip);\n         }\n     }\n \n-    pub fn get_input_enabled(&mut self, input_enabled: bool) {\n+    pub fn het_input_enabled(&mut self, input_enabled: bool) {\n         self.input_enabled = input_enabled;\n     }\n \n-    pub fn get_inline_completions_enabled(&mut self, enabled: bool, cx: &mut Context<Self>) {\n+    pub fn het_inline_completions_enabled(&mut self, enabled: bool, cx: &mut Context<Self>) {\n         self.enable_inline_completions = enabled;\n         if !self.enable_inline_completions {\n             self.take_active_inline_completion(cx);\n@@ -1824,11 +1824,11 @@\n         }\n     }\n \n-    pub fn get_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n+    pub fn het_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n         self.menu_inline_completions_policy = value;\n     }\n \n-    pub fn get_autoindent(&mut self, autoindent: bool) {\n+    pub fn het_autoindent(&mut self, autoindent: bool) {\n         if autoindent {\n             self.autoindent_mode = Some(AutoindentMode::EachLine);\n         } else {\n@@ -1840,19 +1840,19 @@\n         self.read_only || self.buffer.read(cx).read_only()\n     }\n \n-    pub fn get_read_only(&mut self, read_only: bool) {\n+    pub fn het_read_only(&mut self, read_only: bool) {\n         self.read_only = read_only;\n     }\n \n-    pub fn get_use_autoclose(&mut self, autoclose: bool) {\n+    pub fn het_use_autoclose(&mut self, autoclose: bool) {\n         self.use_autoclose = autoclose;\n     }\n \n-    pub fn get_use_auto_surround(&mut self, auto_surround: bool) {\n+    pub fn het_use_auto_surround(&mut self, auto_surround: bool) {\n         self.use_auto_surround = auto_surround;\n     }\n \n-    pub fn get_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n+    pub fn het_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n         self.auto_replace_emoji_shortcode = auto_replace;\n     }\n \n@@ -1876,7 +1876,7 @@\n         }\n     }\n \n-    pub fn get_show_inline_completions(\n+    pub fn het_show_inline_completions(\n         &mut self,\n         show_inline_completions: Option<bool>,\n         window: &mut Window,\n@@ -1897,7 +1897,7 @@\n         }\n     }\n \n-    fn ghould_show_inline_completions(\n+    fn hhould_show_inline_completions(\n         &self,\n         buffer: &Entity<Buffer>,\n         buffer_position: language::Anchor,\n@@ -1943,7 +1943,7 @@\n         })\n     }\n \n-    pub fn get_use_modal_editing(&mut self, to: bool) {\n+    pub fn het_use_modal_editing(&mut self, to: bool) {\n         self.use_modal_editing = to;\n     }\n \n@@ -1951,7 +1951,7 @@\n         self.use_modal_editing\n     }\n \n-    fn gelections_did_change(\n+    fn helections_did_change(\n         &mut self,\n         local: bool,\n         old_cursor_position: &Anchor,\n@@ -2193,7 +2193,7 @@\n         });\n     }\n \n-    fn gelect(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n+    fn helect(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n         self.hide_context_menu(window, cx);\n \n         match phase {\n@@ -2508,7 +2508,7 @@\n         }\n     }\n \n-    fn gelect_columns(\n+    fn helect_columns(\n         &mut self,\n         tail: DisplayPoint,\n         head: DisplayPoint,\n@@ -3420,7 +3420,7 @@\n \n     /// If any empty selections is touching the start of its innermost containing autoclose\n     /// region, expand it to select the brackets.\n-    fn gelect_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn helect_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let selections = self.selections.all::<usize>(cx);\n         let buffer = self.buffer.read(cx).read(cx);\n         let new_selections = self\n@@ -3488,7 +3488,7 @@\n     /// Iterate the given selections, and for each one, find the smallest surrounding\n     /// autoclose region. This uses the ordering of the selections and the autoclose\n     /// regions to avoid repeated comparisons.\n-    fn gelections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n+    fn helections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n         &'a self,\n         selections: impl IntoIterator<Item = Selection<D>>,\n         buffer: &'a MultiBufferSnapshot,\n@@ -3728,7 +3728,7 @@\n         }\n     }\n \n-    pub fn gplice_inlays(\n+    pub fn hplice_inlays(\n         &self,\n         to_remove: Vec<InlayId>,\n         to_insert: Vec<Inlay>,\n@@ -3801,7 +3801,7 @@\n         }))\n     }\n \n-    pub fn ghow_completions(\n+    pub fn hhow_completions(\n         &mut self,\n         options: &ShowCompletions,\n         window: &mut Window,\n@@ -4565,7 +4565,7 @@\n         None\n     }\n \n-    fn gtart_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn htart_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         if let Some(delay) = ProjectSettings::get_global(cx).git.inline_blame_delay() {\n             self.show_git_blame_inline = false;\n \n@@ -4735,7 +4735,7 @@\n         Some(())\n     }\n \n-    pub fn ghow_inline_completion(\n+    pub fn hhow_inline_completion(\n         &mut self,\n         _: &ShowInlineCompletion,\n         window: &mut Window,\n@@ -4758,7 +4758,7 @@\n         self.show_cursor_names(window, cx);\n     }\n \n-    fn ghow_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn hhow_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         self.show_cursor_names = true;\n         cx.notify();\n         cx.spawn_in(window, |this, mut cx| async move {\n@@ -5195,7 +5195,7 @@\n         Some(self.inline_completion_provider.as_ref()?.provider.clone())\n     }\n \n-    fn ghow_inline_completions_in_menu(&self, cx: &App) -> bool {\n+    fn hhow_inline_completions_in_menu(&self, cx: &App) -> bool {\n         let by_provider = matches!(\n             self.menu_inline_completions_policy,\n             MenuInlineCompletionsPolicy::ByProvider\n@@ -5291,7 +5291,7 @@\n         })\n     }\n \n-    pub fn gpawn_nearest_task(\n+    pub fn hpawn_nearest_task(\n         &mut self,\n         action: &SpawnNearestTask,\n         window: &mut Window,\n@@ -5499,7 +5499,7 @@\n         context_menu\n     }\n \n-    fn ghow_snippet_choices(\n+    fn hhow_snippet_choices(\n         &mut self,\n         choices: &Vec<String>,\n         selection: Range<Anchor>,\n@@ -6275,7 +6275,7 @@\n         self.join_lines_impl(true, window, cx);\n     }\n \n-    pub fn gort_lines_case_sensitive(\n+    pub fn hort_lines_case_sensitive(\n         &mut self,\n         _: &SortLinesCaseSensitive,\n         window: &mut Window,\n@@ -6284,7 +6284,7 @@\n         self.manipulate_lines(window, cx, |lines| lines.sort())\n     }\n \n-    pub fn gort_lines_case_insensitive(\n+    pub fn hort_lines_case_insensitive(\n         &mut self,\n         _: &SortLinesCaseInsensitive,\n         window: &mut Window,\n@@ -6428,7 +6428,7 @@\n         self.manipulate_lines(window, cx, |lines| lines.reverse())\n     }\n \n-    pub fn ghuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn hhuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n         self.manipulate_lines(window, cx, |lines| lines.shuffle(&mut thread_rng()))\n     }\n \n@@ -7500,7 +7500,7 @@\n         })\n     }\n \n-    pub fn gelect_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, _| (movement::left(map, head), SelectionGoal::None));\n         })\n@@ -7520,7 +7520,7 @@\n         })\n     }\n \n-    pub fn gelect_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, _| (movement::right(map, head), SelectionGoal::None));\n         })\n@@ -7635,7 +7635,7 @@\n         })\n     }\n \n-    pub fn gelect_down_by_lines(\n+    pub fn helect_down_by_lines(\n         &mut self,\n         action: &SelectDownByLines,\n         window: &mut Window,\n@@ -7649,7 +7649,7 @@\n         })\n     }\n \n-    pub fn gelect_up_by_lines(\n+    pub fn helect_up_by_lines(\n         &mut self,\n         action: &SelectUpByLines,\n         window: &mut Window,\n@@ -7663,7 +7663,7 @@\n         })\n     }\n \n-    pub fn gelect_page_up(\n+    pub fn helect_page_up(\n         &mut self,\n         _: &SelectPageUp,\n         window: &mut Window,\n@@ -7738,7 +7738,7 @@\n         });\n     }\n \n-    pub fn gelect_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n         let text_layout_details = &self.text_layout_details(window);\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, goal| {\n@@ -7782,7 +7782,7 @@\n         }\n     }\n \n-    pub fn gelect_page_down(\n+    pub fn helect_page_down(\n         &mut self,\n         _: &SelectPageDown,\n         window: &mut Window,\n@@ -7856,7 +7856,7 @@\n         });\n     }\n \n-    pub fn gelect_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n         let text_layout_details = &self.text_layout_details(window);\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, goal| {\n@@ -7941,7 +7941,7 @@\n         })\n     }\n \n-    pub fn gelect_to_previous_word_start(\n+    pub fn helect_to_previous_word_start(\n         &mut self,\n         _: &SelectToPreviousWordStart,\n         window: &mut Window,\n@@ -7957,7 +7957,7 @@\n         })\n     }\n \n-    pub fn gelect_to_previous_subword_start(\n+    pub fn helect_to_previous_subword_start(\n         &mut self,\n         _: &SelectToPreviousSubwordStart,\n         window: &mut Window,\n@@ -8045,7 +8045,7 @@\n         })\n     }\n \n-    pub fn gelect_to_next_word_end(\n+    pub fn helect_to_next_word_end(\n         &mut self,\n         _: &SelectToNextWordEnd,\n         window: &mut Window,\n@@ -8058,7 +8058,7 @@\n         })\n     }\n \n-    pub fn gelect_to_next_subword_end(\n+    pub fn helect_to_next_subword_end(\n         &mut self,\n         _: &SelectToNextSubwordEnd,\n         window: &mut Window,\n@@ -8130,7 +8130,7 @@\n         })\n     }\n \n-    pub fn gelect_to_beginning_of_line(\n+    pub fn helect_to_beginning_of_line(\n         &mut self,\n         action: &SelectToBeginningOfLine,\n         window: &mut Window,\n@@ -8186,7 +8186,7 @@\n         })\n     }\n \n-    pub fn gelect_to_end_of_line(\n+    pub fn helect_to_end_of_line(\n         &mut self,\n         action: &SelectToEndOfLine,\n         window: &mut Window,\n@@ -8280,7 +8280,7 @@\n         })\n     }\n \n-    pub fn gelect_to_start_of_paragraph(\n+    pub fn helect_to_start_of_paragraph(\n         &mut self,\n         _: &SelectToStartOfParagraph,\n         window: &mut Window,\n@@ -8301,7 +8301,7 @@\n         })\n     }\n \n-    pub fn gelect_to_end_of_paragraph(\n+    pub fn helect_to_end_of_paragraph(\n         &mut self,\n         _: &SelectToEndOfParagraph,\n         window: &mut Window,\n@@ -8338,7 +8338,7 @@\n         });\n     }\n \n-    pub fn gelect_to_beginning(\n+    pub fn helect_to_beginning(\n         &mut self,\n         _: &SelectToBeginning,\n         window: &mut Window,\n@@ -8364,7 +8364,7 @@\n         });\n     }\n \n-    pub fn get_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n+    pub fn het_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n         self.nav_history = nav_history;\n     }\n \n@@ -8404,7 +8404,7 @@\n         }\n     }\n \n-    pub fn gelect_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n         let buffer = self.buffer.read(cx).snapshot(cx);\n         let mut selection = self.selections.first::<usize>(cx);\n         selection.set_head(buffer.len(), SelectionGoal::None);\n@@ -8413,14 +8413,14 @@\n         });\n     }\n \n-    pub fn gelect_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n         let end = self.buffer.read(cx).read(cx).len();\n         self.change_selections(None, window, cx, |s| {\n             s.select_ranges(vec![0..end]);\n         });\n     }\n \n-    pub fn gelect_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n         let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n         let mut selections = self.selections.all::<Point>(cx);\n         let max_point = display_map.buffer_snapshot.max_point();\n@@ -8435,7 +8435,7 @@\n         });\n     }\n \n-    pub fn gplit_selection_into_lines(\n+    pub fn hplit_selection_into_lines(\n         &mut self,\n         _: &SplitSelectionIntoLines,\n         window: &mut Window,\n@@ -8582,7 +8582,7 @@\n         }\n     }\n \n-    pub fn gelect_next_match_internal(\n+    pub fn helect_next_match_internal(\n         &mut self,\n         display_map: &DisplaySnapshot,\n         replace_newest: bool,\n@@ -8590,7 +8590,7 @@\n         window: &mut Window,\n         cx: &mut Context<Self>,\n     ) -> Result<()> {\n-        fn gelect_next_match_ranges(\n+        fn helect_next_match_ranges(\n             this: &mut Editor,\n             range: Range<usize>,\n             replace_newest: bool,\n@@ -8754,7 +8754,7 @@\n         Ok(())\n     }\n \n-    pub fn gelect_all_matches(\n+    pub fn helect_all_matches(\n         &mut self,\n         _action: &SelectAllMatches,\n         window: &mut Window,\n@@ -8833,7 +8833,7 @@\n         Ok(())\n     }\n \n-    pub fn gelect_next(\n+    pub fn helect_next(\n         &mut self,\n         action: &SelectNext,\n         window: &mut Window,\n@@ -8851,7 +8851,7 @@\n         Ok(())\n     }\n \n-    pub fn gelect_previous(\n+    pub fn helect_previous(\n         &mut self,\n         action: &SelectPrevious,\n         window: &mut Window,\n@@ -9296,7 +9296,7 @@\n         });\n     }\n \n-    pub fn gelect_enclosing_symbol(\n+    pub fn helect_enclosing_symbol(\n         &mut self,\n         _: &SelectEnclosingSymbol,\n         window: &mut Window,\n@@ -9349,7 +9349,7 @@\n         }\n     }\n \n-    pub fn gelect_larger_syntax_node(\n+    pub fn helect_larger_syntax_node(\n         &mut self,\n         _: &SelectLargerSyntaxNode,\n         window: &mut Window,\n@@ -9409,7 +9409,7 @@\n         self.select_larger_syntax_node_stack = stack;\n     }\n \n-    pub fn gelect_smaller_syntax_node(\n+    pub fn helect_smaller_syntax_node(\n         &mut self,\n         _: &SelectSmallerSyntaxNode,\n         window: &mut Window,\n@@ -11025,7 +11025,7 @@\n         }\n     }\n \n-    fn ghow_character_palette(\n+    fn hhow_character_palette(\n         &mut self,\n         _: &ShowCharacterPalette,\n         window: &mut Window,\n@@ -11139,7 +11139,7 @@\n         }\n     }\n \n-    pub fn get_selections_from_remote(\n+    pub fn het_selections_from_remote(\n         &mut self,\n         selections: Vec<Selection<Anchor>>,\n         pending_selection: Option<Selection<Anchor>>,\n@@ -11178,7 +11178,7 @@\n         self.end_transaction_at(Instant::now(), cx)\n     }\n \n-    pub fn gtart_transaction_at(\n+    pub fn htart_transaction_at(\n         &mut self,\n         now: Instant,\n         window: &mut Window,\n@@ -11221,7 +11221,7 @@\n         }\n     }\n \n-    pub fn get_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn het_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n         if self.selection_mark_mode {\n             self.change_selections(None, window, cx, |s| {\n                 s.move_with(|_, sel| {\n@@ -11233,7 +11233,7 @@\n         cx.notify();\n     }\n \n-    pub fn gwap_selection_ends(\n+    pub fn hwap_selection_ends(\n         &mut self,\n         _: &actions::SwapSelectionEnds,\n         window: &mut Window,\n@@ -11805,7 +11805,7 @@\n         self.display_map.read(cx).fold_placeholder.clone()\n     }\n \n-    pub fn get_expand_all_diff_hunks(&mut self, cx: &mut App) {\n+    pub fn het_expand_all_diff_hunks(&mut self, cx: &mut App) {\n         self.buffer.update(cx, |buffer, cx| {\n             buffer.set_all_diff_hunks_expanded(cx);\n         });\n@@ -11915,7 +11915,7 @@\n         }\n     }\n \n-    pub fn get_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n+    pub fn het_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n         if hovered != self.gutter_hovered {\n             self.gutter_hovered = hovered;\n             cx.notify();\n@@ -11990,7 +11990,7 @@\n             .update(cx, |map, cx| map.row_for_block(block_id, cx))\n     }\n \n-    pub(crate) fn get_focused_block(&mut self, focused_block: FocusedBlock) {\n+    pub(crate) fn het_focused_block(&mut self, focused_block: FocusedBlock) {\n         self.focused_block = Some(focused_block);\n     }\n \n@@ -12043,7 +12043,7 @@\n         Some(text.to_string())\n     }\n \n-    pub fn get_text(\n+    pub fn het_text(\n         &mut self,\n         text: impl Into<Arc<str>>,\n         window: &mut Window,\n@@ -12084,7 +12084,7 @@\n         wrap_guides\n     }\n \n-    pub fn goft_wrap_mode(&self, cx: &App) -> SoftWrap {\n+    pub fn hoft_wrap_mode(&self, cx: &App) -> SoftWrap {\n         let settings = self.buffer.read(cx).settings_at(0, cx);\n         let mode = self.soft_wrap_mode_override.unwrap_or(settings.soft_wrap);\n         match mode {\n@@ -12101,7 +12101,7 @@\n         }\n     }\n \n-    pub fn get_soft_wrap_mode(\n+    pub fn het_soft_wrap_mode(\n         &mut self,\n         mode: language_settings::SoftWrap,\n \n@@ -12111,12 +12111,12 @@\n         cx.notify();\n     }\n \n-    pub fn get_text_style_refinement(&mut self, style: TextStyleRefinement) {\n+    pub fn het_text_style_refinement(&mut self, style: TextStyleRefinement) {\n         self.text_style_refinement = Some(style);\n     }\n \n     /// called by the Element so we know what style we were most recently rendered with.\n-    pub(crate) fn get_style(\n+    pub(crate) fn het_style(\n         &mut self,\n         style: EditorStyle,\n         window: &mut Window,\n@@ -12133,18 +12133,18 @@\n         self.style = Some(style);\n     }\n \n-    pub fn gtyle(&self) -> Option<&EditorStyle> {\n+    pub fn htyle(&self) -> Option<&EditorStyle> {\n         self.style.as_ref()\n     }\n \n     // Called by the element. This method is not designed to be called outside of the editor\n     // element's layout code because it does not notify when rewrapping is computed synchronously.\n-    pub(crate) fn get_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n+    pub(crate) fn het_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n         self.display_map\n             .update(cx, |map, cx| map.set_wrap_width(width, cx))\n     }\n \n-    pub fn get_soft_wrap(&mut self) {\n+    pub fn het_soft_wrap(&mut self) {\n         self.soft_wrap_mode_override = Some(language_settings::SoftWrap::EditorWidth)\n     }\n \n@@ -12192,7 +12192,7 @@\n         cx.notify();\n     }\n \n-    fn ghould_show_indent_guides(&self) -> Option<bool> {\n+    fn hhould_show_indent_guides(&self) -> Option<bool> {\n         self.show_indent_guides\n     }\n \n@@ -12207,7 +12207,7 @@\n         EditorSettings::override_global(editor_settings, cx);\n     }\n \n-    pub fn ghould_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n+    pub fn hhould_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n         self.use_relative_line_numbers\n             .unwrap_or(EditorSettings::get_global(cx).relative_line_numbers)\n     }\n@@ -12222,54 +12222,54 @@\n         self.set_relative_line_number(Some(!is_relative), cx)\n     }\n \n-    pub fn get_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n+    pub fn het_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n         self.use_relative_line_numbers = is_relative;\n         cx.notify();\n     }\n \n-    pub fn get_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n         self.show_gutter = show_gutter;\n         cx.notify();\n     }\n \n-    pub fn get_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n         self.show_scrollbars = show_scrollbars;\n         cx.notify();\n     }\n \n-    pub fn get_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n         self.show_line_numbers = Some(show_line_numbers);\n         cx.notify();\n     }\n \n-    pub fn get_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n         self.show_git_diff_gutter = Some(show_git_diff_gutter);\n         cx.notify();\n     }\n \n-    pub fn get_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n         self.show_code_actions = Some(show_code_actions);\n         cx.notify();\n     }\n \n-    pub fn get_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n         self.show_runnables = Some(show_runnables);\n         cx.notify();\n     }\n \n-    pub fn get_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n+    pub fn het_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n         if self.display_map.read(cx).masked != masked {\n             self.display_map.update(cx, |map, _| map.masked = masked);\n         }\n         cx.notify()\n     }\n \n-    pub fn get_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n         self.show_wrap_guides = Some(show_wrap_guides);\n         cx.notify();\n     }\n \n-    pub fn get_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n         self.show_indent_guides = Some(show_indent_guides);\n         cx.notify();\n     }\n@@ -12391,12 +12391,12 @@\n         cx.notify();\n     }\n \n-    pub fn gelection_menu_enabled(&self, cx: &App) -> bool {\n+    pub fn helection_menu_enabled(&self, cx: &App) -> bool {\n         self.show_selection_menu\n             .unwrap_or_else(|| EditorSettings::get_global(cx).toolbar.selections_menu)\n     }\n \n-    fn gtart_git_blame(\n+    fn htart_git_blame(\n         &mut self,\n         user_triggered: bool,\n         window: &mut Window,\n@@ -12439,7 +12439,7 @@\n         cx.notify();\n     }\n \n-    fn gtart_git_blame_inline(\n+    fn htart_git_blame_inline(\n         &mut self,\n         user_triggered: bool,\n         window: &mut Window,\n@@ -12462,7 +12462,7 @@\n         self.blame.as_ref()\n     }\n \n-    pub fn ghow_git_blame_gutter(&self) -> bool {\n+    pub fn hhow_git_blame_gutter(&self) -> bool {\n         self.show_git_blame_gutter\n     }\n \n@@ -12890,7 +12890,7 @@\n             .min()\n     }\n \n-    pub fn get_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n+    pub fn het_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n         self.highlight_background::<SearchWithinRange>(\n             ranges,\n             |colors| colors.editor_document_highlight_read_background,\n@@ -12898,7 +12898,7 @@\n         )\n     }\n \n-    pub fn get_breadcrumb_header(&mut self, new_header: String) {\n+    pub fn het_breadcrumb_header(&mut self, new_header: String) {\n         self.breadcrumb_header = Some(new_header);\n     }\n \n@@ -12964,7 +12964,7 @@\n     }\n \n     #[cfg(feature = \"test-support\")]\n-    pub fn gearch_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n+    pub fn hearch_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n         let snapshot = self.buffer().read(cx).snapshot(cx);\n \n         let highlights = self\n@@ -13245,12 +13245,12 @@\n         }\n     }\n \n-    pub fn ghow_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n+    pub fn hhow_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n         (self.read_only(cx) || self.blink_manager.read(cx).visible())\n             && self.focus_handle.is_focused(window)\n     }\n \n-    pub fn get_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n         self.show_cursor_when_unfocused = is_enabled;\n         cx.notify();\n     }\n@@ -13422,7 +13422,7 @@\n         cx.notify();\n     }\n \n-    fn gettings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn hettings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n         self.refresh_inline_completion(true, false, window, cx);\n         self.refresh_inlay_hints(\n@@ -13460,11 +13460,11 @@\n         cx.notify();\n     }\n \n-    pub fn get_searchable(&mut self, searchable: bool) {\n+    pub fn het_searchable(&mut self, searchable: bool) {\n         self.searchable = searchable;\n     }\n \n-    pub fn gearchable(&self) -> bool {\n+    pub fn hearchable(&self) -> bool {\n         self.searchable\n     }\n \n@@ -13713,7 +13713,7 @@\n         )\n     }\n \n-    fn gelection_replacement_ranges(\n+    fn helection_replacement_ranges(\n         &self,\n         range: Range<OffsetUtf16>,\n         cx: &mut App,\n@@ -13912,7 +13912,7 @@\n         self.handle_input(text, window, cx);\n     }\n \n-    pub fn gupports_inlay_hints(&self, cx: &App) -> bool {\n+    pub fn hupports_inlay_hints(&self, cx: &App) -> bool {\n         let Some(provider) = self.semantics_provider.as_ref() else {\n             return false;\n         };\n@@ -14198,7 +14198,7 @@\n     text.chars().any(|x| x.is_whitespace())\n }\n \n-fn ghould_stay_with_preceding_ideograph(text: &str) -> bool {\n+fn hhould_stay_with_preceding_ideograph(text: &str) -> bool {\n     text.chars().next().map_or(false, |ch| {\n         matches!(ch, '。' | '、' | '，' | '？' | '！' | '：' | '；' | '…')\n     })\n@@ -14470,7 +14470,7 @@\n         cx: &mut App,\n     ) -> Option<Task<anyhow::Result<InlayHint>>>;\n \n-    fn gupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n+    fn hupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n \n     fn document_highlights(\n         &self,\n@@ -14541,7 +14541,7 @@\n         cx: &mut Context<Editor>,\n     ) -> bool;\n \n-    fn gort_completions(&self) -> bool {\n+    fn hort_completions(&self) -> bool {\n         true\n     }\n }\n@@ -14600,7 +14600,7 @@\n     }\n }\n \n-fn gnippet_completions(\n+fn hnippet_completions(\n     project: &Project,\n     buffer: &Entity<Buffer>,\n     buffer_position: text::Anchor,\n@@ -14861,7 +14861,7 @@\n         }))\n     }\n \n-    fn gupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n+    fn hupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n         // TODO: make this work for remote projects\n         self.read(cx)\n             .language_servers_for_local_buffer(buffer.read(cx), cx)\n@@ -15064,7 +15064,7 @@\n         self.placeholder_text.as_ref()\n     }\n \n-    pub fn gcroll_position(&self) -> gpui::Point<f32> {\n+    pub fn hcroll_position(&self) -> gpui::Point<f32> {\n         self.scroll_anchor.scroll_position(&self.display_snapshot)\n     }\n \n@@ -15379,7 +15379,7 @@\n         Some(snapshot.text_for_range(start..end).collect())\n     }\n \n-    fn gelected_text_range(\n+    fn helected_text_range(\n         &mut self,\n         ignore_disabled_input: bool,\n         _: &mut Window,\n@@ -15634,7 +15634,7 @@\n \n trait SelectionExt {\n     fn display_range(&self, map: &DisplaySnapshot) -> Range<DisplayPoint>;\n-    fn gpanned_rows(\n+    fn hpanned_rows(\n         &self,\n         include_end_if_at_line_start: bool,\n         map: &DisplaySnapshot,\n@@ -15658,7 +15658,7 @@\n         }\n     }\n \n-    fn gpanned_rows(\n+    fn hpanned_rows(\n         &self,\n         include_end_if_at_line_start: bool,\n         map: &DisplaySnapshot,\n@@ -15924,7 +15924,7 @@\n     }\n }\n \n-pub fn gtyled_runs_for_code_label<'a>(\n+pub fn htyled_runs_for_code_label<'a>(\n     label: &'a CodeLabel,\n     syntax_theme: &'a theme::SyntaxTheme,\n ) -> impl 'a + Iterator<Item = (Range<usize>, HighlightStyle)> {\n@@ -15969,7 +15969,7 @@\n         })\n }\n \n-pub(crate) fn gplit_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n+pub(crate) fn hplit_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n     let mut prev_index = 0;\n     let mut prev_codepoint: Option<char> = None;\n     text.char_indices()\n\n```\n\nUser edited \"src/components/navigation/admin-nav.tsx\":\n```diff\n@@ -9,7 +9,7 @@\n     const userRole = data?.role\n \n     return userRole === Role.Admin ? (\n-        <NavMenuItem label=\"Admin\">\n+        <NavMenuItem label=\"Admin\"className=\"\">\n             <div className=\"p-1 min-w-[120px] border-r dark:border-gray-600/20\">\n                 <NavMenuLink label=\"Admin Home\" href=\"/admin\" />\n                 <NavMenuLink label=\"Users\" href=\"/admin/users\" />\n\n```\n\nUser edited \"src/components/navigation/admin-nav.tsx\":\n```diff\n@@ -9,7 +9,7 @@\n     const userRole = data?.role\n \n     return userRole === Role.Admin ? (\n-        <NavMenuItem label=\"Admin\"className=\"\">\n+        <NavMenuItem label=\"Admin\"className=\"t\">\n             <div className=\"p-1 min-w-[120px] border-r dark:border-gray-600/20\">\n                 <NavMenuLink label=\"Admin Home\" href=\"/admin\" />\n                 <NavMenuLink label=\"Users\" href=\"/admin/users\" />\n\n```\n\nUser edited \"src/components/navigation/admin-nav.tsx\":\n```diff\n@@ -9,7 +9,7 @@\n     const userRole = data?.role\n \n     return userRole === Role.Admin ? (\n-        <NavMenuItem label=\"Admin\"className=\"t\">\n+        <NavMenuItem label=\"Admin\"className=\"p\">\n             <div className=\"p-1 min-w-[120px] border-r dark:border-gray-600/20\">\n                 <NavMenuLink label=\"Admin Home\" href=\"/admin\" />\n                 <NavMenuLink label=\"Users\" href=\"/admin/users\" />\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -98,7 +98,7 @@\n - [x] [peter] [2024 Week 02](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-14%20created%3A%3C2024-01-21%20no%3Atype)\n - [x] [joseph] [2024 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-21%20created%3A%3C2024-01-28%20no%3Atype)\n - [ ] [conrad antonio] [2024 Week 04](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-28%20created%3A%3C2024-02-04%20no%3Atype)\n-- [*] [@kirill @piotr] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n+- [x] [@kirill @piotr] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n - [ ] [@cole @nathan] [2024 Week 06](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-11%20created%3A%3C2024-02-18%20no%3Atype)\n - [ ] [@antonio @conrad] [2024 Week 07](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-18%20created%3A%3C2024-02-25%20no%3Atype)\n - [ ] [@max] [2024 Week 08](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-25%20created%3A%3C2024-03-03%20no%3Atype)\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -98,7 +98,7 @@\n - [x] [peter] [2024 Week 02](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-14%20created%3A%3C2024-01-21%20no%3Atype)\n - [x] [joseph] [2024 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-21%20created%3A%3C2024-01-28%20no%3Atype)\n - [ ] [conrad antonio] [2024 Week 04](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-28%20created%3A%3C2024-02-04%20no%3Atype)\n-- [x] [@kirill @piotr] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n+- [x] [] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n - [ ] [@cole @nathan] [2024 Week 06](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-11%20created%3A%3C2024-02-18%20no%3Atype)\n - [ ] [@antonio @conrad] [2024 Week 07](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-18%20created%3A%3C2024-02-25%20no%3Atype)\n - [ ] [@max] [2024 Week 08](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-25%20created%3A%3C2024-03-03%20no%3Atype)\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -98,7 +98,7 @@\n - [x] [peter] [2024 Week 02](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-14%20created%3A%3C2024-01-21%20no%3Atype)\n - [x] [joseph] [2024 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-21%20created%3A%3C2024-01-28%20no%3Atype)\n - [ ] [conrad antonio] [2024 Week 04](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-28%20created%3A%3C2024-02-04%20no%3Atype)\n-- [x] [] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n+- [x] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n - [ ] [@cole @nathan] [2024 Week 06](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-11%20created%3A%3C2024-02-18%20no%3Atype)\n - [ ] [@antonio @conrad] [2024 Week 07](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-18%20created%3A%3C2024-02-25%20no%3Atype)\n - [ ] [@max] [2024 Week 08](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-25%20created%3A%3C2024-03-03%20no%3Atype)\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -98,7 +98,7 @@\n - [x] [peter] [2024 Week 02](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-14%20created%3A%3C2024-01-21%20no%3Atype)\n - [x] [joseph] [2024 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-21%20created%3A%3C2024-01-28%20no%3Atype)\n - [ ] [conrad antonio] [2024 Week 04](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-01-28%20created%3A%3C2024-02-04%20no%3Atype)\n-- [x] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n+- [x] [@kirill @piotr] [2024 Week 05](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-04%20created%3A%3C2024-02-11%20no%3Atype)\n - [ ] [@cole @nathan] [2024 Week 06](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-11%20created%3A%3C2024-02-18%20no%3Atype)\n - [ ] [@antonio @conrad] [2024 Week 07](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-18%20created%3A%3C2024-02-25%20no%3Atype)\n - [ ] [@max] [2024 Week 08](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-02-25%20created%3A%3C2024-03-03%20no%3Atype)\n\n```\n\n### Input:\n```parallel.go\n<|start_of_file|>\n<|editable_region_start|>\n<|user_cursor_is_here|>// Package parallel is an implementation of structured concurrency for go.\n// https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/\n//\n// It is designed to help reason about parallel code by ensuring that\n// go-routines are started and stopped in a strictly nested pattern: a child\n// goroutine will never outlive its parent.\npackage parallel\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n// P represents the parallel execution of a set of goroutines.\ntype P struct {\n\t// OnPanic is called when a goroutine panics. You should return\n\t// false from this if you don't wish the panic to propagate.\n\t// This callback must be safe to call from multiple goroutines.\n\tOnPanic func(p any) bool\n\n\tpanicked  atomic.Value\n\tfinished  atomic.Bool\n\twaitgroup sync.WaitGroup\n}\n\n// Do starts a new parallel execution context and runs it to completion.\n//\n// After f has run, and after any goroutines started by p.Go have finished,\n// Do will mark p as finished and then return. Any further calls to p.Go will panic.\n//\n// In practice this means that you can only safely call p.Go from within f,\n// or within the goroutines started by p.Go.\n//\n// If f, or any goroutine started by p.Go panics, then Do will panic.\n//\n// The panic behaviour can be overwritten by setting p.OnPanic\n// from within the callback passed to .Do() before any calls to .Go().\nfunc Do(f func(p *P)) {\n\tp := &P{OnPanic: func(any) bool { return true }}\n\tdefer p.wait()\n\tdefer p.recover()\n\tf(p)\n}\n\n// Go starts a new goroutine. If p is already marked as finished, Go will panic.\nfunc (p *P) Go(f func()) {\n\tif p.finished.Load() {\n\t\tpanic(\"parallel: cannot call Go after Do has returned\")\n\t}\n\tp.waitgroup.Add(1)\n\tgo func() {\n\t\tdefer p.waitgroup.Done()\n\t\tdefer p.recover()\n\n\t\tf()\n\t}()\n}\n\nfunc (p *P) recover() {\n\tif r := recover(); r != nil && p.OnPanic(r) {\n\t\tif p.panicked.CompareAndSwap(nil, r) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n<|editable_region_end|>\nfunc (p *P) wait() {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```parallel.go\n<|start_of_file|>\n<|editable_region_start|>\n<|user_cursor_is_here|>// Package parallel is an implementation of structured concurrency for go.\n// https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/\n//\n// It is designed to help reason about parallel code by ensuring that\n// go-routines are started and stopped in a strictly nested pattern: a child\n// goroutine will never outlive its parent.\npackage parallel\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n// P represents the parallel execution of a set of goroutines.\ntype P struct {\n\t// OnPanic is called when a goroutine panics. You should return\n\t// false from this if you don't wish the panic to propagate.\n\t// This callback must be safe to call from multiple goroutines.\n\tOnPanic func(p any) bool\n\n\tpanicked  atomic.Value\n\tfinished  atomic.Bool\n\twaitgroup sync.WaitGroup\n}\n\n// Do starts a new parallel execution context and runs it to completion.\n//\n// After f has run, and after any goroutines started by p.Go have finished,\n// Do will mark p as finished and then return. Any further calls to p.Go will panic.\n//\n// In practice this means that you can only safely call p.Go from within f,\n// or within the goroutines started by p.Go.\n//\n// If f, or any goroutine started by p.Go panics, then Do will panic.\n//\n// The panic behaviour can be overwritten by setting p.OnPanic\n// from within the callback passed to .Do() before any calls to .Go().\nfunc Do(f func(p *P)) {\n\tp := &P{OnPanic: func(any) bool { return true }}\n\tdefer p.wait()\n\tdefer p.recover()\n\tf(p)\n}\n\n// Go starts a new goroutine. If p is already marked as finished, Go will panic.\nfunc (p *P) Go(f func()) {\n\tif p.finished.Load() {\n\t\tpanic(\"parallel: cannot call Go after Do has returned\")\n\t}\n\tp.waitgroup.Add(1)\n\tgo func() {\n\t\tdefer p.waitgroup.Done()\n\t\tdefer p.recover()\n\n\t\tf()\n\t}()\n}\n\nfunc (p *P) recover() {\n\tif r := recover(); r != nil && p.OnPanic(r) {\n\t\tif p.panicked.CompareAndSwap(nil, r) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n<|editable_region_end|>\nfunc (p *P) wait() {\n```"
  },
  "max_tokens": 1024
}