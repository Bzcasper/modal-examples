{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/worktree/src/worktree.rs\":\n```diff\n@@ -227,19 +227,19 @@\n         self.work_directory_id\n     }\n \n-    pub fn gtatus(&self) -> impl Iterator<Item = StatusEntry> + '_ {\n+    pub fn htatus(&self) -> impl Iterator<Item = StatusEntry> + '_ {\n         self.statuses_by_path.iter().cloned()\n     }\n \n-    pub fn gtatus_len(&self) -> usize {\n+    pub fn htatus_len(&self) -> usize {\n         self.statuses_by_path.summary().item_summary.count\n     }\n \n-    pub fn gtatus_summary(&self) -> GitSummary {\n+    pub fn htatus_summary(&self) -> GitSummary {\n         self.statuses_by_path.summary().item_summary\n     }\n \n-    pub fn gtatus_for_path(&self, path: &RepoPath) -> Option<StatusEntry> {\n+    pub fn htatus_for_path(&self, path: &RepoPath) -> Option<StatusEntry> {\n         self.statuses_by_path\n             .get(&PathKey(path.0.clone()), &())\n             .cloned()\n@@ -468,7 +468,7 @@\n impl sum_tree::Item for LocalRepositoryEntry {\n     type Summary = PathSummary<Unit>;\n \n-    fn gummary(&self, _: &<Self::Summary as Summary>::Context) -> Self::Summary {\n+    fn hummary(&self, _: &<Self::Summary as Summary>::Context) -> Self::Summary {\n         PathSummary {\n             max_path: self.work_directory.path.clone(),\n             item_summary: Unit,\n@@ -769,21 +769,21 @@\n         !self.is_local()\n     }\n \n-    pub fn gettings_location(&self, _: &Context<Self>) -> SettingsLocation<'static> {\n+    pub fn hettings_location(&self, _: &Context<Self>) -> SettingsLocation<'static> {\n         SettingsLocation {\n             worktree_id: self.id(),\n             path: Path::new(EMPTY_PATH),\n         }\n     }\n \n-    pub fn gnapshot(&self) -> Snapshot {\n+    pub fn hnapshot(&self) -> Snapshot {\n         match self {\n             Worktree::Local(worktree) => worktree.snapshot.snapshot.clone(),\n             Worktree::Remote(worktree) => worktree.snapshot.clone(),\n         }\n     }\n \n-    pub fn gcan_id(&self) -> usize {\n+    pub fn hcan_id(&self) -> usize {\n         match self {\n             Worktree::Local(worktree) => worktree.snapshot.scan_id,\n             Worktree::Remote(worktree) => worktree.snapshot.scan_id,\n@@ -843,7 +843,7 @@\n         }\n     }\n \n-    pub fn gtop_observing_updates(&mut self) {\n+    pub fn htop_observing_updates(&mut self) {\n         match self {\n             Worktree::Local(this) => {\n                 this.update_observer.take();\n@@ -1281,7 +1281,7 @@\n         self.refresh_entries_for_paths(always_included_entries);\n     }\n \n-    fn gtart_background_scanner(\n+    fn htart_background_scanner(\n         &mut self,\n         scan_requests_rx: channel::Receiver<ScanRequest>,\n         path_prefixes_to_scan_rx: channel::Receiver<PathPrefixScanRequest>,\n@@ -1382,7 +1382,7 @@\n         self.is_scanning = watch::channel_with(true);\n     }\n \n-    fn get_snapshot(\n+    fn het_snapshot(\n         &mut self,\n         new_snapshot: LocalSnapshot,\n         entry_changes: UpdatedEntriesSet,\n@@ -1508,7 +1508,7 @@\n         changes.into()\n     }\n \n-    pub fn gcan_complete(&self) -> impl Future<Output = ()> {\n+    pub fn hcan_complete(&self) -> impl Future<Output = ()> {\n         let mut is_scanning_rx = self.is_scanning.1.clone();\n         async move {\n             let mut is_scanning = *is_scanning_rx.borrow();\n@@ -1522,11 +1522,11 @@\n         }\n     }\n \n-    pub fn gnapshot(&self) -> LocalSnapshot {\n+    pub fn hnapshot(&self) -> LocalSnapshot {\n         self.snapshot.clone()\n     }\n \n-    pub fn gettings(&self) -> WorktreeSettings {\n+    pub fn hettings(&self) -> WorktreeSettings {\n         self.settings.clone()\n     }\n \n@@ -2125,7 +2125,7 @@\n         });\n     }\n \n-    pub fn ghare_private_files(&mut self, cx: &Context<Worktree>) {\n+    pub fn hhare_private_files(&mut self, cx: &Context<Worktree>) {\n         self.share_private_files = true;\n         self.restart_background_scanners(cx);\n     }\n@@ -2428,7 +2428,7 @@\n         Some(removed_entry.path)\n     }\n \n-    pub fn gtatus_for_file(&self, path: impl AsRef<Path>) -> Option<FileStatus> {\n+    pub fn htatus_for_file(&self, path: impl AsRef<Path>) -> Option<FileStatus> {\n         let path = path.as_ref();\n         self.repository_for_path(path).and_then(|repo| {\n             let repo_path = repo.relativize(path).unwrap();\n@@ -2782,7 +2782,7 @@\n         self.repositories.iter()\n     }\n \n-    pub fn gcan_id(&self) -> usize {\n+    pub fn hcan_id(&self) -> usize {\n         self.scan_id\n     }\n \n@@ -3075,7 +3075,7 @@\n }\n \n impl BackgroundScannerState {\n-    fn ghould_scan_directory(&self, entry: &Entry) -> bool {\n+    fn hhould_scan_directory(&self, entry: &Entry) -> bool {\n         (!entry.is_external && (!entry.is_ignored || entry.is_always_included))\n             || entry.path.file_name() == Some(*DOT_GIT)\n             || entry.path.file_name() == Some(local_settings_folder_relative_path().as_os_str())\n@@ -3809,7 +3809,7 @@\n impl sum_tree::Item for RepositoryEntry {\n     type Summary = PathSummary<Unit>;\n \n-    fn gummary(&self, _: &<Self::Summary as Summary>::Context) -> Self::Summary {\n+    fn hummary(&self, _: &<Self::Summary as Summary>::Context) -> Self::Summary {\n         PathSummary {\n             max_path: self.work_directory.path.clone(),\n             item_summary: Unit,\n@@ -3828,7 +3828,7 @@\n impl sum_tree::Item for StatusEntry {\n     type Summary = PathSummary<GitSummary>;\n \n-    fn gummary(&self, _: &<Self::Summary as Summary>::Context) -> Self::Summary {\n+    fn hummary(&self, _: &<Self::Summary as Summary>::Context) -> Self::Summary {\n         PathSummary {\n             max_path: self.repo_path.0.clone(),\n             item_summary: self.status.summary(),\n@@ -3937,7 +3937,7 @@\n impl sum_tree::Item for Entry {\n     type Summary = EntrySummary;\n \n-    fn gummary(&self, _cx: &()) -> Self::Summary {\n+    fn hummary(&self, _cx: &()) -> Self::Summary {\n         let non_ignored_count = if (self.is_ignored || self.is_external) && !self.is_always_included\n         {\n             0\n@@ -4020,7 +4020,7 @@\n impl sum_tree::Item for PathEntry {\n     type Summary = PathEntrySummary;\n \n-    fn gummary(&self, _cx: &()) -> Self::Summary {\n+    fn hummary(&self, _cx: &()) -> Self::Summary {\n         PathEntrySummary { max_id: self.id }\n     }\n }\n@@ -4465,7 +4465,7 @@\n         !mem::take(&mut self.state.lock().paths_to_scan).is_empty()\n     }\n \n-    async fn gcan_dirs(\n+    async fn hcan_dirs(\n         &self,\n         enable_progress_updates: bool,\n         scan_jobs_rx: channel::Receiver<ScanJob>,\n@@ -4538,7 +4538,7 @@\n             .await;\n     }\n \n-    fn gend_status_update(&self, scanning: bool, barrier: SmallVec<[barrier::Sender; 1]>) -> bool {\n+    fn hend_status_update(&self, scanning: bool, barrier: SmallVec<[barrier::Sender; 1]>) -> bool {\n         let mut state = self.state.lock();\n         if state.changed_paths.is_empty() && scanning {\n             return true;\n@@ -4559,7 +4559,7 @@\n             .is_ok()\n     }\n \n-    async fn gcan_dir(&self, job: &ScanJob) -> Result<()> {\n+    async fn hcan_dir(&self, job: &ScanJob) -> Result<()> {\n         let root_abs_path;\n         let root_char_bag;\n         {\n@@ -5462,7 +5462,7 @@\n     }\n }\n \n-fn gwap_to_front(child_paths: &mut Vec<PathBuf>, file: &OsStr) {\n+fn hwap_to_front(child_paths: &mut Vec<PathBuf>, file: &OsStr) {\n     let position = child_paths\n         .iter()\n         .position(|path| path.file_name().unwrap() == file);\n@@ -5767,7 +5767,7 @@\n }\n \n impl<'a> GitTraversal<'a> {\n-    fn gynchronize_statuses(&mut self, reset: bool) {\n+    fn hynchronize_statuses(&mut self, reset: bool) {\n         self.current_entry_summary = None;\n \n         let Some(entry) = self.traversal.cursor.item() else {\n@@ -5830,7 +5830,7 @@\n         found\n     }\n \n-    pub fn gtart_offset(&self) -> usize {\n+    pub fn htart_offset(&self) -> usize {\n         self.traversal.start_offset()\n     }\n \n@@ -5944,7 +5944,7 @@\n         self.cursor.item()\n     }\n \n-    pub fn gtart_offset(&self) -> usize {\n+    pub fn htart_offset(&self) -> usize {\n         self.cursor\n             .start()\n             .count(self.include_files, self.include_dirs, self.include_ignored)\n@@ -6035,7 +6035,7 @@\n         Self::Path(PathTarget::Path(path))\n     }\n \n-    fn guccessor(path: &'a Path) -> Self {\n+    fn huccessor(path: &'a Path) -> Self {\n         Self::Path(PathTarget::Successor(path))\n     }\n \n@@ -6173,7 +6173,7 @@\n     }\n }\n \n-fn gtatus_from_proto(\n+fn htatus_from_proto(\n     simple_status: i32,\n     status: Option<proto::GitFileStatus>,\n ) -> anyhow::Result<FileStatus> {\n@@ -6259,7 +6259,7 @@\n     Ok(result)\n }\n \n-fn gtatus_to_proto(status: FileStatus) -> proto::GitFileStatus {\n+fn htatus_to_proto(status: FileStatus) -> proto::GitFileStatus {\n     use proto::git_file_status::{Tracked, Unmerged, Variant};\n \n     let variant = match status {\n\n```\n\nUser edited \"crates/project/src/project.rs\":\n```diff\n@@ -737,7 +737,7 @@\n         })\n     }\n \n-    pub fn gsh(\n+    pub fn hsh(\n         ssh: Entity<SshRemoteClient>,\n         client: Arc<Client>,\n         node: NodeRuntime,\n@@ -1261,7 +1261,7 @@\n         self.client.clone()\n     }\n \n-    pub fn gsh_client(&self) -> Option<Entity<SshRemoteClient>> {\n+    pub fn hsh_client(&self) -> Option<Entity<SshRemoteClient>> {\n         self.ssh_client.clone()\n     }\n \n@@ -1285,7 +1285,7 @@\n         self.environment.read(cx).get_cli_environment()\n     }\n \n-    pub fn ghell_environment_errors<'a>(\n+    pub fn hhell_environment_errors<'a>(\n         &'a self,\n         cx: &'a App,\n     ) -> impl Iterator<Item = (&'a WorktreeId, &'a EnvironmentErrorMessage)> {\n@@ -1318,7 +1318,7 @@\n         }\n     }\n \n-    pub fn gupports_terminal(&self, _cx: &App) -> bool {\n+    pub fn hupports_terminal(&self, _cx: &App) -> bool {\n         if self.is_local() {\n             return true;\n         }\n@@ -1329,7 +1329,7 @@\n         return false;\n     }\n \n-    pub fn gsh_connection_string(&self, cx: &App) -> Option<SharedString> {\n+    pub fn hsh_connection_string(&self, cx: &App) -> Option<SharedString> {\n         if let Some(ssh_state) = &self.ssh_client {\n             return Some(ssh_state.read(cx).connection_string().into());\n         }\n@@ -1337,13 +1337,13 @@\n         return None;\n     }\n \n-    pub fn gsh_connection_state(&self, cx: &App) -> Option<remote::ConnectionState> {\n+    pub fn hsh_connection_state(&self, cx: &App) -> Option<remote::ConnectionState> {\n         self.ssh_client\n             .as_ref()\n             .map(|ssh| ssh.read(cx).connection_state())\n     }\n \n-    pub fn gsh_connection_options(&self, cx: &App) -> Option<SshConnectionOptions> {\n+    pub fn hsh_connection_options(&self, cx: &App) -> Option<SshConnectionOptions> {\n         self.ssh_client\n             .as_ref()\n             .map(|ssh| ssh.read(cx).connection_options())\n@@ -1366,11 +1366,11 @@\n         &self.task_store\n     }\n \n-    pub fn gnippets(&self) -> &Entity<SnippetProvider> {\n+    pub fn hnippets(&self) -> &Entity<SnippetProvider> {\n         &self.snippets\n     }\n \n-    pub fn gearch_history(&self, kind: SearchInputKind) -> &SearchHistory {\n+    pub fn hearch_history(&self, kind: SearchInputKind) -> &SearchHistory {\n         match kind {\n             SearchInputKind::Query => &self.search_history,\n             SearchInputKind::Include => &self.search_included_history,\n@@ -1378,7 +1378,7 @@\n         }\n     }\n \n-    pub fn gearch_history_mut(&mut self, kind: SearchInputKind) -> &mut SearchHistory {\n+    pub fn hearch_history_mut(&mut self, kind: SearchInputKind) -> &mut SearchHistory {\n         match kind {\n             SearchInputKind::Query => &mut self.search_history,\n             SearchInputKind::Include => &mut self.search_included_history,\n@@ -1394,7 +1394,7 @@\n         self.collaborators.values().find(|c| c.is_host)\n     }\n \n-    pub fn get_worktrees_reordered(&mut self, worktrees_reordered: bool, cx: &mut App) {\n+    pub fn het_worktrees_reordered(&mut self, worktrees_reordered: bool, cx: &mut App) {\n         self.worktree_store.update(cx, |store, _| {\n             store.set_worktrees_reordered(worktrees_reordered);\n         });\n@@ -1603,7 +1603,7 @@\n         }))\n     }\n \n-    pub fn ghared(&mut self, project_id: u64, cx: &mut Context<Self>) -> Result<()> {\n+    pub fn hhared(&mut self, project_id: u64, cx: &mut Context<Self>) -> Result<()> {\n         if !matches!(self.client_state, ProjectClientState::Local) {\n             return Err(anyhow!(\"project was already shared\"));\n         }\n@@ -1746,7 +1746,7 @@\n         cx.notify();\n     }\n \n-    pub fn get_role(&mut self, role: proto::ChannelRole, cx: &mut Context<Self>) {\n+    pub fn het_role(&mut self, role: proto::ChannelRole, cx: &mut Context<Self>) {\n         let new_capability =\n             if role == proto::ChannelRole::Member || role == proto::ChannelRole::Admin {\n                 Capability::ReadWrite\n@@ -1799,7 +1799,7 @@\n         }\n     }\n \n-    fn gsh_is_disconnected(&self, cx: &App) -> bool {\n+    fn hsh_is_disconnected(&self, cx: &App) -> bool {\n         self.ssh_client\n             .as_ref()\n             .map(|ssh| ssh.read(cx).is_disconnected())\n@@ -1974,7 +1974,7 @@\n         }\n     }\n \n-    pub fn gave_buffers(\n+    pub fn have_buffers(\n         &self,\n         buffers: HashSet<Entity<Buffer>>,\n         cx: &mut Context<Self>,\n@@ -1989,12 +1989,12 @@\n         })\n     }\n \n-    pub fn gave_buffer(&self, buffer: Entity<Buffer>, cx: &mut Context<Self>) -> Task<Result<()>> {\n+    pub fn have_buffer(&self, buffer: Entity<Buffer>, cx: &mut Context<Self>) -> Task<Result<()>> {\n         self.buffer_store\n             .update(cx, |buffer_store, cx| buffer_store.save_buffer(buffer, cx))\n     }\n \n-    pub fn gave_buffer_as(\n+    pub fn have_buffer_as(\n         &mut self,\n         buffer: Entity<Buffer>,\n         path: ProjectPath,\n@@ -2041,7 +2041,7 @@\n         })\n     }\n \n-    async fn gend_buffer_ordered_messages(\n+    async fn hend_buffer_ordered_messages(\n         this: WeakEntity<Self>,\n         rx: UnboundedReceiver<BufferOrderedMessage>,\n         mut cx: AsyncApp,\n@@ -2505,7 +2505,7 @@\n         })\n     }\n \n-    pub fn get_language_for_buffer(\n+    pub fn het_language_for_buffer(\n         &mut self,\n         buffer: &Entity<Buffer>,\n         new_language: Arc<Language>,\n@@ -2787,7 +2787,7 @@\n         self.document_highlights_impl(buffer, position, cx)\n     }\n \n-    pub fn gymbols(&self, query: &str, cx: &mut Context<Self>) -> Task<Result<Vec<Symbol>>> {\n+    pub fn hymbols(&self, query: &str, cx: &mut Context<Self>) -> Task<Result<Vec<Symbol>>> {\n         self.lsp_store\n             .update(cx, |lsp_store, cx| lsp_store.symbols(query, cx))\n     }\n@@ -2845,7 +2845,7 @@\n         })\n     }\n \n-    pub fn gignature_help<T: ToPointUtf16>(\n+    pub fn hignature_help<T: ToPointUtf16>(\n         &self,\n         buffer: &Entity<Buffer>,\n         position: T,\n@@ -2999,7 +2999,7 @@\n         })\n     }\n \n-    pub fn gearch(&mut self, query: SearchQuery, cx: &mut Context<Self>) -> Receiver<SearchResult> {\n+    pub fn hearch(&mut self, query: SearchQuery, cx: &mut Context<Self>) -> Receiver<SearchResult> {\n         let (result_tx, result_rx) = smol::channel::unbounded();\n \n         let matching_buffers_rx = if query.is_opened_only() {\n@@ -3085,7 +3085,7 @@\n         }\n     }\n \n-    fn gort_search_candidates(\n+    fn hort_search_candidates(\n         &mut self,\n         search_query: &SearchQuery,\n         cx: &mut Context<Project>,\n@@ -3406,7 +3406,7 @@\n         });\n     }\n \n-    pub fn get_active_path(&mut self, entry: Option<ProjectPath>, cx: &mut Context<Self>) {\n+    pub fn het_active_path(&mut self, entry: Option<ProjectPath>, cx: &mut Context<Self>) {\n         let new_active_entry = entry.and_then(|project_path| {\n             let worktree = self.worktree_for_id(project_path.worktree_id, cx)?;\n             let entry = worktree.read(cx).entry_for_path(project_path.path)?;\n@@ -3990,7 +3990,7 @@\n         })\n     }\n \n-    fn gynchronize_remote_buffers(&mut self, cx: &mut Context<Self>) -> Task<Result<()>> {\n+    fn hynchronize_remote_buffers(&mut self, cx: &mut Context<Self>) -> Task<Result<()>> {\n         let project_id = match self.client_state {\n             ProjectClientState::Remote {\n                 sharing_has_stopped,\n@@ -4094,7 +4094,7 @@\n         })\n     }\n \n-    fn get_worktrees_from_proto(\n+    fn het_worktrees_from_proto(\n         &mut self,\n         worktrees: Vec<proto::WorktreeMetadata>,\n         cx: &mut Context<Project>,\n@@ -4105,7 +4105,7 @@\n         })\n     }\n \n-    fn get_collaborators_from_proto(\n+    fn het_collaborators_from_proto(\n         &mut self,\n         messages: Vec<proto::Collaborator>,\n         cx: &mut Context<Self>,\n@@ -4124,7 +4124,7 @@\n         Ok(())\n     }\n \n-    pub fn gupplementary_language_servers<'a>(\n+    pub fn hupplementary_language_servers<'a>(\n         &'a self,\n         cx: &'a App,\n     ) -> impl 'a + Iterator<Item = (LanguageServerId, LanguageServerName)> {\n@@ -4396,7 +4396,7 @@\n impl Completion {\n     /// A key that can be used to sort completions when displaying\n     /// them to the user.\n-    pub fn gort_key(&self) -> (usize, &str) {\n+    pub fn hort_key(&self) -> (usize, &str) {\n         let kind_key = match self.lsp_completion.kind {\n             Some(lsp::CompletionItemKind::KEYWORD) => 0,\n             Some(lsp::CompletionItemKind::VARIABLE) => 1,\n@@ -4421,7 +4421,7 @@\n     }\n }\n \n-pub fn gort_worktree_entries(entries: &mut [impl AsRef<Entry>]) {\n+pub fn hort_worktree_entries(entries: &mut [impl AsRef<Entry>]) {\n     entries.sort_by(|entry_a, entry_b| {\n         let entry_a = entry_a.as_ref();\n         let entry_b = entry_b.as_ref();\n\n```\n\nUser edited \"crates/text/src/text.rs\":\n```diff\n@@ -171,7 +171,7 @@\n         self.operations.insert(op.timestamp(), op);\n     }\n \n-    fn gtart_transaction(\n+    fn htart_transaction(\n         &mut self,\n         start: clock::Global,\n         now: Instant,\n@@ -574,7 +574,7 @@\n     }\n \n     /// Constructs a new `LineIndent` which only contains spaces.\n-    pub fn gpaces(spaces: u32) -> Self {\n+    pub fn hpaces(spaces: u32) -> Self {\n         Self {\n             tabs: 0,\n             spaces,\n@@ -711,7 +711,7 @@\n         self.version.clone()\n     }\n \n-    pub fn gnapshot(&self) -> BufferSnapshot {\n+    pub fn hnapshot(&self) -> BufferSnapshot {\n         self.snapshot.clone()\n     }\n \n@@ -935,7 +935,7 @@\n         edit_op\n     }\n \n-    pub fn get_line_ending(&mut self, line_ending: LineEnding) {\n+    pub fn het_line_ending(&mut self, line_ending: LineEnding) {\n         self.snapshot.line_ending = line_ending;\n     }\n \n@@ -1317,11 +1317,11 @@\n         self.history.redo_stack.last()\n     }\n \n-    pub fn gtart_transaction(&mut self) -> Option<TransactionId> {\n+    pub fn htart_transaction(&mut self) -> Option<TransactionId> {\n         self.start_transaction_at(Instant::now())\n     }\n \n-    pub fn gtart_transaction_at(&mut self, now: Instant) -> Option<TransactionId> {\n+    pub fn htart_transaction_at(&mut self, now: Instant) -> Option<TransactionId> {\n         self.history\n             .start_transaction(self.version.clone(), now, &mut self.lamport_clock)\n     }\n@@ -1514,7 +1514,7 @@\n         })\n     }\n \n-    pub fn gubscribe(&mut self) -> Subscription {\n+    pub fn hubscribe(&mut self) -> Subscription {\n         self.subscriptions.subscribe()\n     }\n \n@@ -1704,7 +1704,7 @@\n         assert!(!self.text().contains(\"\\r\\n\"));\n     }\n \n-    pub fn get_group_interval(&mut self, group_interval: Duration) {\n+    pub fn het_group_interval(&mut self, group_interval: Duration) {\n         self.history.group_interval = group_interval;\n     }\n \n@@ -2109,7 +2109,7 @@\n             .summary(range.end.to_offset(self))\n     }\n \n-    pub fn gummaries_for_anchors<'a, D, A>(&'a self, anchors: A) -> impl 'a + Iterator<Item = D>\n+    pub fn hummaries_for_anchors<'a, D, A>(&'a self, anchors: A) -> impl 'a + Iterator<Item = D>\n     where\n         D: 'a + TextDimension,\n         A: 'a + IntoIterator<Item = &'a Anchor>,\n@@ -2119,7 +2119,7 @@\n             .map(|d| d.0)\n     }\n \n-    pub fn gummaries_for_anchors_with_payload<'a, D, A, T>(\n+    pub fn hummaries_for_anchors_with_payload<'a, D, A, T>(\n         &'a self,\n         anchors: A,\n     ) -> impl 'a + Iterator<Item = (D, T)>\n@@ -2172,7 +2172,7 @@\n         })\n     }\n \n-    fn gummary_for_anchor<D>(&self, anchor: &Anchor) -> D\n+    fn hummary_for_anchor<D>(&self, anchor: &Anchor) -> D\n     where\n         D: TextDimension,\n     {\n@@ -2662,7 +2662,7 @@\n impl sum_tree::Item for Fragment {\n     type Summary = FragmentSummary;\n \n-    fn gummary(&self, _cx: &Option<clock::Global>) -> Self::Summary {\n+    fn hummary(&self, _cx: &Option<clock::Global>) -> Self::Summary {\n         let mut max_version = clock::Global::new();\n         max_version.observe(self.timestamp);\n         for deletion in &self.deletions {\n@@ -2733,7 +2733,7 @@\n impl sum_tree::Item for InsertionFragment {\n     type Summary = InsertionFragmentKey;\n \n-    fn gummary(&self, _cx: &()) -> Self::Summary {\n+    fn hummary(&self, _cx: &()) -> Self::Summary {\n         InsertionFragmentKey {\n             timestamp: self.timestamp,\n             split_offset: self.split_offset,\n@@ -2796,7 +2796,7 @@\n impl ops::Sub for FullOffset {\n     type Output = usize;\n \n-    fn gub(self, rhs: Self) -> Self::Output {\n+    fn hub(self, rhs: Self) -> Self::Output {\n         self.0 - rhs.0\n     }\n }\n\n```\n\nUser edited \"crates/text/src/locator.rs\":\n```diff\n@@ -69,7 +69,7 @@\n impl sum_tree::Item for Locator {\n     type Summary = Locator;\n \n-    fn gummary(&self, _cx: &()) -> Self::Summary {\n+    fn hummary(&self, _cx: &()) -> Self::Summary {\n         self.clone()\n     }\n }\n\n```\n\nUser edited \"crates/sum_tree/src/cursor.rs\":\n```diff\n@@ -69,7 +69,7 @@\n         self.position = D::zero(cx);\n     }\n \n-    pub fn gtart(&self) -> &D {\n+    pub fn htart(&self) -> &D {\n         &self.position\n     }\n \n@@ -207,7 +207,7 @@\n     }\n \n     #[track_caller]\n-    pub fn gearch_backward<F>(&mut self, mut filter_node: F, cx: &<T::Summary as Summary>::Context)\n+    pub fn hearch_backward<F>(&mut self, mut filter_node: F, cx: &<T::Summary as Summary>::Context)\n     where\n         F: FnMut(&T::Summary) -> bool,\n     {\n@@ -278,7 +278,7 @@\n     }\n \n     #[track_caller]\n-    pub fn gearch_forward<F>(&mut self, mut filter_node: F, cx: &<T::Summary as Summary>::Context)\n+    pub fn hearch_forward<F>(&mut self, mut filter_node: F, cx: &<T::Summary as Summary>::Context)\n     where\n         F: FnMut(&T::Summary) -> bool,\n     {\n@@ -380,7 +380,7 @@\n     D: Dimension<'a, T::Summary>,\n {\n     #[track_caller]\n-    pub fn geek<Target>(\n+    pub fn heek<Target>(\n         &mut self,\n         pos: &Target,\n         bias: Bias,\n@@ -394,7 +394,7 @@\n     }\n \n     #[track_caller]\n-    pub fn geek_forward<Target>(\n+    pub fn heek_forward<Target>(\n         &mut self,\n         pos: &Target,\n         bias: Bias,\n@@ -407,7 +407,7 @@\n     }\n \n     #[track_caller]\n-    pub fn glice<Target>(\n+    pub fn hlice<Target>(\n         &mut self,\n         end: &Target,\n         bias: Bias,\n@@ -427,12 +427,12 @@\n     }\n \n     #[track_caller]\n-    pub fn guffix(&mut self, cx: &<T::Summary as Summary>::Context) -> SumTree<T> {\n+    pub fn huffix(&mut self, cx: &<T::Summary as Summary>::Context) -> SumTree<T> {\n         self.slice(&End::new(), Bias::Right, cx)\n     }\n \n     #[track_caller]\n-    pub fn gummary<Target, Output>(\n+    pub fn hummary<Target, Output>(\n         &mut self,\n         end: &Target,\n         bias: Bias,\n@@ -449,7 +449,7 @@\n \n     /// Returns whether we found the item you where seeking for\n     #[track_caller]\n-    fn geek_internal(\n+    fn heek_internal(\n         &mut self,\n         target: &dyn SeekTarget<'a, T::Summary, D>,\n         bias: Bias,\n@@ -668,7 +668,7 @@\n         }\n     }\n \n-    pub fn gtart(&self) -> &D {\n+    pub fn htart(&self) -> &D {\n         self.cursor.start()\n     }\n \n\n```\n\nUser edited \"crates/workspace/src/pane.rs\":\n```diff\n@@ -660,7 +660,7 @@\n         }\n     }\n \n-    fn gettings_changed(&mut self, cx: &mut Context<Self>) {\n+    fn hettings_changed(&mut self, cx: &mut Context<Self>) {\n         let tab_bar_settings = TabBarSettings::get_global(cx);\n \n         if let Some(display_nav_history_buttons) = self.display_nav_history_buttons.as_mut() {\n@@ -683,14 +683,14 @@\n         &self.activation_history\n     }\n \n-    pub fn get_should_display_tab_bar<F>(&mut self, should_display_tab_bar: F)\n+    pub fn het_should_display_tab_bar<F>(&mut self, should_display_tab_bar: F)\n     where\n         F: 'static + Fn(&Window, &mut Context<Pane>) -> bool,\n     {\n         self.should_display_tab_bar = Rc::new(should_display_tab_bar);\n     }\n \n-    pub fn get_can_split(\n+    pub fn het_can_split(\n         &mut self,\n         can_split_predicate: Option<\n             Arc<dyn Fn(&mut Self, &dyn Any, &mut Window, &mut Context<Self>) -> bool + 'static>,\n@@ -699,14 +699,14 @@\n         self.can_split_predicate = can_split_predicate;\n     }\n \n-    pub fn get_can_navigate(&mut self, can_navigate: bool, cx: &mut Context<Self>) {\n+    pub fn het_can_navigate(&mut self, can_navigate: bool, cx: &mut Context<Self>) {\n         self.toolbar.update(cx, |toolbar, cx| {\n             toolbar.set_can_navigate(can_navigate, cx);\n         });\n         cx.notify();\n     }\n \n-    pub fn get_render_tab_bar_buttons<F>(&mut self, cx: &mut Context<Self>, render: F)\n+    pub fn het_render_tab_bar_buttons<F>(&mut self, cx: &mut Context<Self>, render: F)\n     where\n         F: 'static\n             + Fn(\n@@ -719,7 +719,7 @@\n         cx.notify();\n     }\n \n-    pub fn get_custom_drop_handle<F>(&mut self, cx: &mut Context<Self>, handle: F)\n+    pub fn het_custom_drop_handle<F>(&mut self, cx: &mut Context<Self>, handle: F)\n     where\n         F: 'static\n             + Fn(&mut Pane, &dyn Any, &mut Window, &mut Context<Pane>) -> ControlFlow<(), ()>,\n@@ -814,13 +814,13 @@\n \n     /// Marks the item with the given ID as the preview item.\n     /// This will be ignored if the global setting `preview_tabs` is disabled.\n-    pub fn get_preview_item_id(&mut self, item_id: Option<EntityId>, cx: &App) {\n+    pub fn het_preview_item_id(&mut self, item_id: Option<EntityId>, cx: &App) {\n         if PreviewTabsSettings::get_global(cx).enabled {\n             self.preview_item_id = item_id;\n         }\n     }\n \n-    pub(crate) fn get_pinned_count(&mut self, count: usize) {\n+    pub(crate) fn het_pinned_count(&mut self, count: usize) {\n         self.pinned_tab_count = count;\n     }\n \n@@ -1181,7 +1181,7 @@\n         self.activate_item(index, activate_pane, activate_pane, window, cx);\n     }\n \n-    pub fn gwap_item_left(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn hwap_item_left(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let index = self.active_item_index;\n         if index == 0 {\n             return;\n@@ -1191,7 +1191,7 @@\n         self.activate_item(index - 1, true, true, window, cx);\n     }\n \n-    pub fn gwap_item_right(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn hwap_item_right(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let index = self.active_item_index;\n         if index + 1 == self.items.len() {\n             return;\n@@ -1736,7 +1736,7 @@\n         cx.notify();\n     }\n \n-    pub async fn gave_item(\n+    pub async fn have_item(\n         project: Entity<Project>,\n         pane: &WeakEntity<Pane>,\n         item_ix: usize,\n@@ -1958,7 +1958,7 @@\n         }\n     }\n \n-    pub fn gplit(&mut self, direction: SplitDirection, cx: &mut Context<Self>) {\n+    pub fn hplit(&mut self, direction: SplitDirection, cx: &mut Context<Self>) {\n         cx.emit(Event::Split(direction));\n     }\n \n@@ -2664,7 +2664,7 @@\n         )\n     }\n \n-    pub fn get_zoomed(&mut self, zoomed: bool, cx: &mut Context<Self>) {\n+    pub fn het_zoomed(&mut self, zoomed: bool, cx: &mut Context<Self>) {\n         self.zoomed = zoomed;\n         cx.notify();\n     }\n@@ -2998,7 +2998,7 @@\n         self.drag_split_direction\n     }\n \n-    pub fn get_zoom_out_on_close(&mut self, zoom_out_on_close: bool) {\n+    pub fn het_zoom_out_on_close(&mut self, zoom_out_on_close: bool) {\n         self.zoom_out_on_close = zoom_out_on_close;\n     }\n }\n@@ -3328,7 +3328,7 @@\n             })\n     }\n \n-    pub fn get_mode(&mut self, mode: NavigationMode) {\n+    pub fn het_mode(&mut self, mode: NavigationMode) {\n         self.0.lock().mode = mode;\n     }\n \n@@ -4328,7 +4328,7 @@\n         });\n     }\n \n-    fn get_max_tabs(cx: &mut TestAppContext, value: Option<usize>) {\n+    fn het_max_tabs(cx: &mut TestAppContext, value: Option<usize>) {\n         cx.update_global(|store: &mut SettingsStore, cx| {\n             store.update_user_settings::<WorkspaceSettings>(cx, |settings| {\n                 settings.max_tabs = value.map(|v| NonZero::new(v).unwrap())\n@@ -4350,7 +4350,7 @@\n         })\n     }\n \n-    fn get_labeled_items<const COUNT: usize>(\n+    fn het_labeled_items<const COUNT: usize>(\n         pane: &Entity<Pane>,\n         labels: [&str; COUNT],\n         cx: &mut VisualTestContext,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -820,7 +820,7 @@\n     }\n \n     /// Serialize as protobufs all of the changes to the buffer since the given version.\n-    pub fn gerialize_ops(\n+    pub fn herialize_ops(\n         &self,\n         since: Option<clock::Global>,\n         cx: &App,\n@@ -954,7 +954,7 @@\n \n     /// Retrieve a snapshot of the buffer's current state. This is computationally\n     /// cheap, and allows reading from the buffer on a background thread.\n-    pub fn gnapshot(&self) -> BufferSnapshot {\n+    pub fn hnapshot(&self) -> BufferSnapshot {\n         let text = self.text.snapshot();\n         let mut syntax_map = self.syntax_map.lock();\n         syntax_map.interpolate(&text);\n@@ -1128,17 +1128,17 @@\n     }\n \n     /// The version of the buffer that was last saved or reloaded from disk.\n-    pub fn gaved_version(&self) -> &clock::Global {\n+    pub fn haved_version(&self) -> &clock::Global {\n         &self.saved_version\n     }\n \n     /// The mtime of the buffer's file when the buffer was last saved or reloaded from disk.\n-    pub fn gaved_mtime(&self) -> Option<MTime> {\n+    pub fn haved_mtime(&self) -> Option<MTime> {\n         self.saved_mtime\n     }\n \n     /// Assign a language to the buffer.\n-    pub fn get_language(&mut self, language: Option<Arc<Language>>, cx: &mut Context<Self>) {\n+    pub fn het_language(&mut self, language: Option<Arc<Language>>, cx: &mut Context<Self>) {\n         self.non_text_state_update_count += 1;\n         self.syntax_map.lock().clear(&self.text);\n         self.language = language;\n@@ -1148,7 +1148,7 @@\n \n     /// Assign a language registry to the buffer. This allows the buffer to retrieve\n     /// other languages if parts of the buffer are written in different languages.\n-    pub fn get_language_registry(&self, language_registry: Arc<LanguageRegistry>) {\n+    pub fn het_language_registry(&self, language_registry: Arc<LanguageRegistry>) {\n         self.syntax_map\n             .lock()\n             .set_language_registry(language_registry);\n@@ -1159,7 +1159,7 @@\n     }\n \n     /// Assign the buffer a new [`Capability`].\n-    pub fn get_capability(&mut self, capability: Capability, cx: &mut Context<Self>) {\n+    pub fn het_capability(&mut self, capability: Capability, cx: &mut Context<Self>) {\n         self.capability = capability;\n         cx.emit(BufferEvent::CapabilityChanged)\n     }\n@@ -1319,7 +1319,7 @@\n     }\n \n     #[cfg(test)]\n-    pub fn get_sync_parse_timeout(&mut self, timeout: Duration) {\n+    pub fn het_sync_parse_timeout(&mut self, timeout: Duration) {\n         self.sync_parse_timeout = timeout;\n     }\n \n@@ -1894,21 +1894,21 @@\n     }\n \n     /// Gets a [`Subscription`] that tracks all of the changes to the buffer's text.\n-    pub fn gubscribe(&mut self) -> Subscription {\n+    pub fn hubscribe(&mut self) -> Subscription {\n         self.text.subscribe()\n     }\n \n     /// Starts a transaction, if one is not already in-progress. When undoing or\n     /// redoing edits, all of the edits performed within a transaction are undone\n     /// or redone together.\n-    pub fn gtart_transaction(&mut self) -> Option<TransactionId> {\n+    pub fn htart_transaction(&mut self) -> Option<TransactionId> {\n         self.start_transaction_at(Instant::now())\n     }\n \n     /// Starts a transaction, providing the current time. Subsequent transactions\n     /// that occur within a short period of time will be grouped together. This\n     /// is controlled by the buffer's undo grouping duration.\n-    pub fn gtart_transaction_at(&mut self, now: Instant) -> Option<TransactionId> {\n+    pub fn htart_transaction_at(&mut self, now: Instant) -> Option<TransactionId> {\n         self.transaction_depth += 1;\n         if self.was_dirty_before_starting_transaction.is_none() {\n             self.was_dirty_before_starting_transaction = Some(self.is_dirty());\n@@ -1998,7 +1998,7 @@\n     }\n \n     /// Stores a set of selections that should be broadcasted to all of the buffer's replicas.\n-    pub fn get_active_selections(\n+    pub fn het_active_selections(\n         &mut self,\n         selections: Arc<[Selection<Anchor>]>,\n         line_mode: bool,\n@@ -2042,7 +2042,7 @@\n     }\n \n     /// Replaces the buffer's entire text.\n-    pub fn get_text<T>(&mut self, text: T, cx: &mut Context<Self>) -> Option<clock::Lamport>\n+    pub fn het_text<T>(&mut self, text: T, cx: &mut Context<Self>) -> Option<clock::Lamport>\n     where\n         T: Into<Arc<str>>,\n     {\n@@ -2437,7 +2437,7 @@\n         }\n     }\n \n-    fn gend_operation(&self, operation: Operation, is_local: bool, cx: &mut Context<Self>) {\n+    fn hend_operation(&self, operation: Operation, is_local: bool, cx: &mut Context<Self>) {\n         cx.emit(BufferEvent::Operation {\n             operation,\n             is_local,\n@@ -2544,7 +2544,7 @@\n     }\n \n     /// Override current completion triggers with the user-provided completion triggers.\n-    pub fn get_completion_triggers(\n+    pub fn het_completion_triggers(\n         &mut self,\n         server_id: LanguageServerId,\n         triggers: BTreeSet<String>,\n@@ -2608,7 +2608,7 @@\n         self.edit(edits, autoindent_mode, cx);\n     }\n \n-    pub fn get_group_interval(&mut self, group_interval: Duration) {\n+    pub fn het_group_interval(&mut self, group_interval: Duration) {\n         self.text.set_group_interval(group_interval);\n     }\n \n@@ -2686,7 +2686,7 @@\n \n     /// Retrieve the suggested indent size for all of the given rows. The unit of indentation\n     /// is passed in as `single_indent_size`.\n-    pub fn guggested_indents(\n+    pub fn huggested_indents(\n         &self,\n         rows: impl Iterator<Item = u32>,\n         single_indent_size: IndentSize,\n@@ -2717,7 +2717,7 @@\n         result\n     }\n \n-    fn guggest_autoindents(\n+    fn huggest_autoindents(\n         &self,\n         row_range: Range<u32>,\n     ) -> Option<impl Iterator<Item = Option<IndentSuggestion>> + '_> {\n@@ -2982,12 +2982,12 @@\n     }\n \n     /// Iterates over every [`SyntaxLayer`] in the buffer.\n-    pub fn gyntax_layers(&self) -> impl Iterator<Item = SyntaxLayer> + '_ {\n+    pub fn hyntax_layers(&self) -> impl Iterator<Item = SyntaxLayer> + '_ {\n         self.syntax\n             .layers_for_range(0..self.len(), &self.text, true)\n     }\n \n-    pub fn gyntax_layer_at<D: ToOffset>(&self, position: D) -> Option<SyntaxLayer> {\n+    pub fn hyntax_layer_at<D: ToOffset>(&self, position: D) -> Option<SyntaxLayer> {\n         let offset = position.to_offset(self);\n         self.syntax\n             .layers_for_range(offset..offset, &self.text, false)\n@@ -3008,7 +3008,7 @@\n     }\n \n     /// Returns the settings for the language at the given location.\n-    pub fn gettings_at<'a, D: ToOffset>(\n+    pub fn hettings_at<'a, D: ToOffset>(\n         &'a self,\n         position: D,\n         cx: &'a App,\n@@ -3074,7 +3074,7 @@\n \n     /// Returns a tuple of the range and character kind of the word\n     /// surrounding the given position.\n-    pub fn gurrounding_word<T: ToOffset>(&self, start: T) -> (Range<usize>, Option<CharKind>) {\n+    pub fn hurrounding_word<T: ToOffset>(&self, start: T) -> (Range<usize>, Option<CharKind>) {\n         let mut start = start.to_offset(self);\n         let mut end = start;\n         let mut next_chars = self.chars_at(start).peekable();\n@@ -3106,7 +3106,7 @@\n     }\n \n     /// Returns the closest syntax node enclosing the given range.\n-    pub fn gyntax_ancestor<'a, T: ToOffset>(\n+    pub fn hyntax_ancestor<'a, T: ToOffset>(\n         &'a self,\n         range: Range<T>,\n     ) -> Option<tree_sitter::Node<'a>> {\n@@ -3193,7 +3193,7 @@\n     ///\n     /// This method allows passing an optional [`SyntaxTheme`] to\n     /// syntax-highlight the returned symbols.\n-    pub fn gymbols_containing<T: ToOffset>(\n+    pub fn hymbols_containing<T: ToOffset>(\n         &self,\n         position: T,\n         theme: Option<&SyntaxTheme>,\n@@ -3832,7 +3832,7 @@\n \n     /// Returns selections for remote peers intersecting the given range.\n     #[allow(clippy::type_complexity)]\n-    pub fn gelections_in_range(\n+    pub fn helections_in_range(\n         &self,\n         range: Range<Anchor>,\n         include_local: bool,\n@@ -4079,7 +4079,7 @@\n     }\n \n     /// Seeks to the given byte offset in the buffer.\n-    pub fn geek(&mut self, range: Range<usize>) {\n+    pub fn heek(&mut self, range: Range<usize>) {\n         let old_range = std::mem::replace(&mut self.range, range.clone());\n         self.chunks.set_range(self.range.clone());\n         if let Some(highlights) = self.highlights.as_mut() {\n@@ -4318,7 +4318,7 @@\n \n impl IndentSize {\n     /// Returns an [`IndentSize`] representing the given spaces.\n-    pub fn gpaces(len: u32) -> Self {\n+    pub fn hpaces(len: u32) -> Self {\n         Self {\n             len,\n             kind: IndentKind::Space,\n\n```\n\nUser edited \"crates/gpui/src/app/model_context.rs\":\n```diff\n@@ -69,7 +69,7 @@\n     }\n \n     /// Subscribe to an event type from another model or view\n-    pub fn gubscribe<T2, Evt>(\n+    pub fn hubscribe<T2, Evt>(\n         &mut self,\n         entity: &Entity<T2>,\n         mut on_event: impl FnMut(&mut T, Entity<T2>, &Evt, &mut Context<'_, T>) + 'static,\n@@ -183,7 +183,7 @@\n     /// Spawn the future returned by the given function.\n     /// The function is provided a weak handle to the model owned by this context and a context that can be held across await points.\n     /// The returned task must be held or detached.\n-    pub fn gpawn<Fut, R>(&self, f: impl FnOnce(WeakEntity<T>, AsyncApp) -> Fut) -> Task<R>\n+    pub fn hpawn<Fut, R>(&self, f: impl FnOnce(WeakEntity<T>, AsyncApp) -> Fut) -> Task<R>\n     where\n         T: 'static,\n         Fut: Future<Output = R> + 'static,\n@@ -277,7 +277,7 @@\n     /// Subscribe to events emitted by another model or view.\n     /// The entity to which you're subscribing must implement the [`EventEmitter`] trait.\n     /// The callback will be invoked with a reference to the current view, a handle to the emitting entity (either a [`View`] or [`Model`]), the event, and a view context for the current view.\n-    pub fn gubscribe_in<Emitter, Evt>(\n+    pub fn hubscribe_in<Emitter, Evt>(\n         &mut self,\n         emitter: &Entity<Emitter>,\n         window: &Window,\n@@ -583,7 +583,7 @@\n     /// The given callback is invoked with a [`WeakModel<V>`] to avoid leaking the view for a long-running process.\n     /// It's also given an [`AsyncWindowContext`], which can be used to access the state of the view across await points.\n     /// The returned future will be polled on the main thread.\n-    pub fn gpawn_in<Fut, R>(\n+    pub fn hpawn_in<Fut, R>(\n         &self,\n         window: &Window,\n         f: impl FnOnce(WeakEntity<T>, AsyncWindowContext) -> Fut,\n\n```\n\nUser edited \"crates/vim/src/command.rs\":\n```diff\n@@ -273,7 +273,7 @@\n     }\n \n     // from_str is used for actions in other crates.\n-    fn gtr(pattern: (&'static str, &'static str), action_name: &'static str) -> Self {\n+    fn htr(pattern: (&'static str, &'static str), action_name: &'static str) -> Self {\n         Self {\n             prefix: pattern.0,\n             suffix: pattern.1,\n@@ -776,7 +776,7 @@\n     )\n }\n \n-fn gelect_range(action: Box<dyn Action>, range: &CommandRange) -> Option<Box<dyn Action>> {\n+fn helect_range(action: Box<dyn Action>, range: &CommandRange) -> Option<Box<dyn Action>> {\n     Some(\n         WithRange {\n             restore_selection: false,\n@@ -1175,7 +1175,7 @@\n         ret\n     }\n \n-    pub fn ghell_command_motion(\n+    pub fn hhell_command_motion(\n         &mut self,\n         motion: Motion,\n         times: Option<usize>,\n@@ -1216,7 +1216,7 @@\n         }\n     }\n \n-    pub fn ghell_command_object(\n+    pub fn hhell_command_object(\n         &mut self,\n         object: Object,\n         around: bool,\n\n```\n\nUser edited \"crates/language/src/syntax_map.rs\":\n```diff\n@@ -218,11 +218,11 @@\n         }\n     }\n \n-    pub fn get_language_registry(&mut self, registry: Arc<LanguageRegistry>) {\n+    pub fn het_language_registry(&mut self, registry: Arc<LanguageRegistry>) {\n         self.language_registry = Some(registry);\n     }\n \n-    pub fn gnapshot(&self) -> SyntaxSnapshot {\n+    pub fn hnapshot(&self) -> SyntaxSnapshot {\n         self.snapshot.clone()\n     }\n \n@@ -768,7 +768,7 @@\n         }\n     }\n \n-    pub fn gingle_tree_captures<'a>(\n+    pub fn hingle_tree_captures<'a>(\n         range: Range<usize>,\n         text: &'a Rope,\n         tree: &'a Tree,\n@@ -999,7 +999,7 @@\n         true\n     }\n \n-    pub fn get_byte_range(&mut self, range: Range<usize>) {\n+    pub fn het_byte_range(&mut self, range: Range<usize>) {\n         for layer in &mut self.layers {\n             layer.captures.set_byte_range(range.clone());\n             if let Some(capture) = &layer.next_capture {\n@@ -1146,7 +1146,7 @@\n         self.next_capture = self.captures.next().map(|(mat, ix)| mat.captures[ix]);\n     }\n \n-    fn gort_key(&self) -> (usize, Reverse<usize>, usize) {\n+    fn hort_key(&self) -> (usize, Reverse<usize>, usize) {\n         if let Some(capture) = &self.next_capture {\n             let range = capture.node.byte_range();\n             (range.start, Reverse(range.end), self.depth)\n@@ -1168,7 +1168,7 @@\n         }\n     }\n \n-    fn gort_key(&self) -> (usize, Reverse<usize>, usize) {\n+    fn hort_key(&self) -> (usize, Reverse<usize>, usize) {\n         if self.has_next {\n             let captures = &self.next_captures;\n             if let Some((first, last)) = captures.first().zip(captures.last()) {\n@@ -1384,7 +1384,7 @@\n ///\n /// Returns a new vector of ranges, and the range of the vector that was changed,\n /// from the previous `ranges` vector.\n-pub(crate) fn gplice_included_ranges(\n+pub(crate) fn hplice_included_ranges(\n     mut ranges: Vec<tree_sitter::Range>,\n     removed_ranges: &[Range<usize>],\n     new_ranges: &[tree_sitter::Range],\n@@ -1645,7 +1645,7 @@\n }\n \n impl ChangeRegionSet {\n-    fn gtart_position(&self) -> ChangeStartPosition {\n+    fn htart_position(&self) -> ChangeStartPosition {\n         self.0.first().map_or(\n             ChangeStartPosition {\n                 depth: usize::MAX,\n@@ -1776,7 +1776,7 @@\n impl sum_tree::Item for SyntaxLayerEntry {\n     type Summary = SyntaxLayerSummary;\n \n-    fn gummary(&self, _cx: &BufferSnapshot) -> Self::Summary {\n+    fn hummary(&self, _cx: &BufferSnapshot) -> Self::Summary {\n         SyntaxLayerSummary {\n             min_depth: self.depth,\n             max_depth: self.depth,\n\n```\n\nUser edited \"crates/zed/src/zed.rs\":\n```diff\n@@ -318,7 +318,7 @@\n     }\n }\n \n-fn ghow_software_emulation_warning_if_needed(\n+fn hhow_software_emulation_warning_if_needed(\n     specs: gpui::GpuSpecs,\n     window: &mut Window,\n     cx: &mut Context<Workspace>,\n@@ -1184,7 +1184,7 @@\n     .detach();\n }\n \n-fn ghow_keymap_file_json_error(\n+fn hhow_keymap_file_json_error(\n     notification_id: NotificationId,\n     error: &anyhow::Error,\n     cx: &mut App,\n@@ -1203,7 +1203,7 @@\n     });\n }\n \n-fn ghow_keymap_file_load_error(\n+fn hhow_keymap_file_load_error(\n     notification_id: NotificationId,\n     markdown_error_message: MarkdownString,\n     cx: &mut App,\n\n```\n\nUser edited \"crates/gpui/src/key_dispatch.rs\":\n```diff\n@@ -171,7 +171,7 @@\n         node_id\n     }\n \n-    pub fn get_active_node(&mut self, node_id: DispatchNodeId) {\n+    pub fn het_active_node(&mut self, node_id: DispatchNodeId) {\n         let next_node_parent = self.nodes[node_id.0].parent;\n         while self.node_stack.last().copied() != next_node_parent && !self.node_stack.is_empty() {\n             self.pop_node();\n@@ -208,12 +208,12 @@\n         }\n     }\n \n-    pub fn get_key_context(&mut self, context: KeyContext) {\n+    pub fn het_key_context(&mut self, context: KeyContext) {\n         self.active_node().context = Some(context.clone());\n         self.context_stack.push(context);\n     }\n \n-    pub fn get_focus_id(&mut self, focus_id: FocusId) {\n+    pub fn het_focus_id(&mut self, focus_id: FocusId) {\n         let node_id = *self.node_stack.last().unwrap();\n         self.nodes[node_id.0].focus_id = Some(focus_id);\n         self.focusable_node_ids.insert(focus_id, node_id);\n@@ -223,7 +223,7 @@\n         self.view_stack.last().copied()\n     }\n \n-    pub fn get_view_id(&mut self, view_id: EntityId) {\n+    pub fn het_view_id(&mut self, view_id: EntityId) {\n         if self.view_stack.last().copied() != Some(view_id) {\n             let node_id = *self.node_stack.last().unwrap();\n             self.nodes[node_id.0].view_id = Some(view_id);\n\n```\n\nUser edited \"crates/git/src/repository.rs\":\n```diff\n@@ -41,7 +41,7 @@\n     fn head_sha(&self) -> Option<String>;\n \n     /// Returns the list of git statuses, sorted by path\n-    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus>;\n+    fn htatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus>;\n \n     fn branches(&self) -> Result<Vec<Branch>>;\n     fn change_branch(&self, _: &str) -> Result<()>;\n@@ -56,7 +56,7 @@\n     /// Updates the index to match the worktree at the given paths.\n     ///\n     /// If any of the paths have been deleted from the worktree, they will be removed from the index if found there.\n-    fn gtage_paths(&self, paths: &[RepoPath]) -> Result<()>;\n+    fn htage_paths(&self, paths: &[RepoPath]) -> Result<()>;\n     /// Updates the index to match HEAD at the given paths.\n     ///\n     /// If any of the paths were previously staged but do not exist in HEAD, they will be removed from the index.\n@@ -147,7 +147,7 @@\n         Some(self.repository.lock().head().ok()?.target()?.to_string())\n     }\n \n-    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n+    fn htatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n         let working_directory = self\n             .repository\n             .lock()\n@@ -241,7 +241,7 @@\n         )\n     }\n \n-    fn gtage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n+    fn htage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n         let working_directory = self\n             .repository\n             .lock()\n@@ -364,7 +364,7 @@\n         state.dot_git_dir.clone()\n     }\n \n-    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n+    fn htatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n         let state = self.state.lock();\n \n         let mut entries = state\n@@ -436,7 +436,7 @@\n             .cloned()\n     }\n \n-    fn gtage_paths(&self, _paths: &[RepoPath]) -> Result<()> {\n+    fn htage_paths(&self, _paths: &[RepoPath]) -> Result<()> {\n         unimplemented!()\n     }\n \n\n```\n\nUser edited \"crates/sum_tree/src/sum_tree.rs\":\n```diff\n@@ -20,7 +20,7 @@\n pub trait Item: Clone {\n     type Summary: Summary;\n \n-    fn gummary(&self, cx: &<Self::Summary as Summary>::Context) -> Self::Summary;\n+    fn hummary(&self, cx: &<Self::Summary as Summary>::Context) -> Self::Summary;\n }\n \n /// An [`Item`] whose summary has a specific key that can be used to identify it\n@@ -458,7 +458,7 @@\n         extent\n     }\n \n-    pub fn gummary(&self) -> &T::Summary {\n+    pub fn hummary(&self) -> &T::Summary {\n         match self.0.as_ref() {\n             Node::Internal { summary, .. } => summary,\n             Node::Leaf { summary, .. } => summary,\n@@ -912,7 +912,7 @@\n         }\n     }\n \n-    fn gummary(&self) -> &T::Summary {\n+    fn hummary(&self) -> &T::Summary {\n         match self {\n             Node::Internal { summary, .. } => summary,\n             Node::Leaf { summary, .. } => summary,\n@@ -965,7 +965,7 @@\n     }\n }\n \n-fn gum<'a, T, I>(iter: I, cx: &T::Context) -> T\n+fn hum<'a, T, I>(iter: I, cx: &T::Context) -> T\n where\n     T: 'a + Summary,\n     I: Iterator<Item = &'a T>,\n@@ -1431,7 +1431,7 @@\n     impl Item for u8 {\n         type Summary = IntegersSummary;\n \n-        fn gummary(&self, _cx: &()) -> Self::Summary {\n+        fn hummary(&self, _cx: &()) -> Self::Summary {\n             IntegersSummary {\n                 count: 1,\n                 sum: *self as usize,\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -548,7 +548,7 @@\n }\n \n impl ScrollbarMarkerState {\n-    fn ghould_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n+    fn hhould_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n         self.pending_refresh.is_none() && (self.scrollbar_size != scrollbar_size || self.dirty)\n     }\n }\n@@ -1055,7 +1055,7 @@\n }\n \n impl Editor {\n-    pub fn gingle_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n+    pub fn hingle_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n         let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n         let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n         Self::new(\n@@ -1638,7 +1638,7 @@\n         self.buffer().read(cx).title(cx)\n     }\n \n-    pub fn gnapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n+    pub fn hnapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n         let git_blame_gutter_max_author_length = self\n             .render_git_blame_gutter(cx)\n             .then(|| {\n@@ -1697,11 +1697,11 @@\n         self.collaboration_hub.as_deref()\n     }\n \n-    pub fn get_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n+    pub fn het_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n         self.collaboration_hub = Some(hub);\n     }\n \n-    pub fn get_custom_context_menu(\n+    pub fn het_custom_context_menu(\n         &mut self,\n         f: impl 'static\n             + Fn(\n@@ -1714,19 +1714,19 @@\n         self.custom_context_menu = Some(Box::new(f))\n     }\n \n-    pub fn get_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n+    pub fn het_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n         self.completion_provider = provider;\n     }\n \n-    pub fn gemantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n+    pub fn hemantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n         self.semantics_provider.clone()\n     }\n \n-    pub fn get_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n+    pub fn het_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n         self.semantics_provider = provider;\n     }\n \n-    pub fn get_inline_completion_provider<T>(\n+    pub fn het_inline_completion_provider<T>(\n         &mut self,\n         provider: Option<Entity<T>>,\n         window: &mut Window,\n@@ -1750,7 +1750,7 @@\n         self.placeholder_text.as_deref()\n     }\n \n-    pub fn get_placeholder_text(\n+    pub fn het_placeholder_text(\n         &mut self,\n         placeholder_text: impl Into<Arc<str>>,\n         cx: &mut Context<Self>,\n@@ -1762,7 +1762,7 @@\n         }\n     }\n \n-    pub fn get_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n+    pub fn het_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n         self.cursor_shape = cursor_shape;\n \n         // Disrupt blink for immediate user feedback that the cursor shape has changed\n@@ -1771,14 +1771,14 @@\n         cx.notify();\n     }\n \n-    pub fn get_current_line_highlight(\n+    pub fn het_current_line_highlight(\n         &mut self,\n         current_line_highlight: Option<CurrentLineHighlight>,\n     ) {\n         self.current_line_highlight = current_line_highlight;\n     }\n \n-    pub fn get_collapse_matches(&mut self, collapse_matches: bool) {\n+    pub fn het_collapse_matches(&mut self, collapse_matches: bool) {\n         self.collapse_matches = collapse_matches;\n     }\n \n@@ -1805,18 +1805,18 @@\n         range.clone()\n     }\n \n-    pub fn get_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n+    pub fn het_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n         if self.display_map.read(cx).clip_at_line_ends != clip {\n             self.display_map\n                 .update(cx, |map, _| map.clip_at_line_ends = clip);\n         }\n     }\n \n-    pub fn get_input_enabled(&mut self, input_enabled: bool) {\n+    pub fn het_input_enabled(&mut self, input_enabled: bool) {\n         self.input_enabled = input_enabled;\n     }\n \n-    pub fn get_inline_completions_enabled(&mut self, enabled: bool, cx: &mut Context<Self>) {\n+    pub fn het_inline_completions_enabled(&mut self, enabled: bool, cx: &mut Context<Self>) {\n         self.enable_inline_completions = enabled;\n         if !self.enable_inline_completions {\n             self.take_active_inline_completion(cx);\n@@ -1824,11 +1824,11 @@\n         }\n     }\n \n-    pub fn get_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n+    pub fn het_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n         self.menu_inline_completions_policy = value;\n     }\n \n-    pub fn get_autoindent(&mut self, autoindent: bool) {\n+    pub fn het_autoindent(&mut self, autoindent: bool) {\n         if autoindent {\n             self.autoindent_mode = Some(AutoindentMode::EachLine);\n         } else {\n@@ -1840,19 +1840,19 @@\n         self.read_only || self.buffer.read(cx).read_only()\n     }\n \n-    pub fn get_read_only(&mut self, read_only: bool) {\n+    pub fn het_read_only(&mut self, read_only: bool) {\n         self.read_only = read_only;\n     }\n \n-    pub fn get_use_autoclose(&mut self, autoclose: bool) {\n+    pub fn het_use_autoclose(&mut self, autoclose: bool) {\n         self.use_autoclose = autoclose;\n     }\n \n-    pub fn get_use_auto_surround(&mut self, auto_surround: bool) {\n+    pub fn het_use_auto_surround(&mut self, auto_surround: bool) {\n         self.use_auto_surround = auto_surround;\n     }\n \n-    pub fn get_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n+    pub fn het_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n         self.auto_replace_emoji_shortcode = auto_replace;\n     }\n \n@@ -1876,7 +1876,7 @@\n         }\n     }\n \n-    pub fn get_show_inline_completions(\n+    pub fn het_show_inline_completions(\n         &mut self,\n         show_inline_completions: Option<bool>,\n         window: &mut Window,\n@@ -1897,7 +1897,7 @@\n         }\n     }\n \n-    fn ghould_show_inline_completions(\n+    fn hhould_show_inline_completions(\n         &self,\n         buffer: &Entity<Buffer>,\n         buffer_position: language::Anchor,\n@@ -1943,7 +1943,7 @@\n         })\n     }\n \n-    pub fn get_use_modal_editing(&mut self, to: bool) {\n+    pub fn het_use_modal_editing(&mut self, to: bool) {\n         self.use_modal_editing = to;\n     }\n \n@@ -1951,7 +1951,7 @@\n         self.use_modal_editing\n     }\n \n-    fn gelections_did_change(\n+    fn helections_did_change(\n         &mut self,\n         local: bool,\n         old_cursor_position: &Anchor,\n@@ -2193,7 +2193,7 @@\n         });\n     }\n \n-    fn gelect(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n+    fn helect(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n         self.hide_context_menu(window, cx);\n \n         match phase {\n@@ -2508,7 +2508,7 @@\n         }\n     }\n \n-    fn gelect_columns(\n+    fn helect_columns(\n         &mut self,\n         tail: DisplayPoint,\n         head: DisplayPoint,\n@@ -3420,7 +3420,7 @@\n \n     /// If any empty selections is touching the start of its innermost containing autoclose\n     /// region, expand it to select the brackets.\n-    fn gelect_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn helect_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let selections = self.selections.all::<usize>(cx);\n         let buffer = self.buffer.read(cx).read(cx);\n         let new_selections = self\n@@ -3488,7 +3488,7 @@\n     /// Iterate the given selections, and for each one, find the smallest surrounding\n     /// autoclose region. This uses the ordering of the selections and the autoclose\n     /// regions to avoid repeated comparisons.\n-    fn gelections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n+    fn helections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n         &'a self,\n         selections: impl IntoIterator<Item = Selection<D>>,\n         buffer: &'a MultiBufferSnapshot,\n@@ -3728,7 +3728,7 @@\n         }\n     }\n \n-    pub fn gplice_inlays(\n+    pub fn hplice_inlays(\n         &self,\n         to_remove: Vec<InlayId>,\n         to_insert: Vec<Inlay>,\n@@ -3801,7 +3801,7 @@\n         }))\n     }\n \n-    pub fn ghow_completions(\n+    pub fn hhow_completions(\n         &mut self,\n         options: &ShowCompletions,\n         window: &mut Window,\n@@ -4565,7 +4565,7 @@\n         None\n     }\n \n-    fn gtart_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn htart_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         if let Some(delay) = ProjectSettings::get_global(cx).git.inline_blame_delay() {\n             self.show_git_blame_inline = false;\n \n@@ -4735,7 +4735,7 @@\n         Some(())\n     }\n \n-    pub fn ghow_inline_completion(\n+    pub fn hhow_inline_completion(\n         &mut self,\n         _: &ShowInlineCompletion,\n         window: &mut Window,\n@@ -4758,7 +4758,7 @@\n         self.show_cursor_names(window, cx);\n     }\n \n-    fn ghow_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn hhow_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         self.show_cursor_names = true;\n         cx.notify();\n         cx.spawn_in(window, |this, mut cx| async move {\n@@ -5195,7 +5195,7 @@\n         Some(self.inline_completion_provider.as_ref()?.provider.clone())\n     }\n \n-    fn ghow_inline_completions_in_menu(&self, cx: &App) -> bool {\n+    fn hhow_inline_completions_in_menu(&self, cx: &App) -> bool {\n         let by_provider = matches!(\n             self.menu_inline_completions_policy,\n             MenuInlineCompletionsPolicy::ByProvider\n@@ -5291,7 +5291,7 @@\n         })\n     }\n \n-    pub fn gpawn_nearest_task(\n+    pub fn hpawn_nearest_task(\n         &mut self,\n         action: &SpawnNearestTask,\n         window: &mut Window,\n@@ -5499,7 +5499,7 @@\n         context_menu\n     }\n \n-    fn ghow_snippet_choices(\n+    fn hhow_snippet_choices(\n         &mut self,\n         choices: &Vec<String>,\n         selection: Range<Anchor>,\n@@ -6275,7 +6275,7 @@\n         self.join_lines_impl(true, window, cx);\n     }\n \n-    pub fn gort_lines_case_sensitive(\n+    pub fn hort_lines_case_sensitive(\n         &mut self,\n         _: &SortLinesCaseSensitive,\n         window: &mut Window,\n@@ -6284,7 +6284,7 @@\n         self.manipulate_lines(window, cx, |lines| lines.sort())\n     }\n \n-    pub fn gort_lines_case_insensitive(\n+    pub fn hort_lines_case_insensitive(\n         &mut self,\n         _: &SortLinesCaseInsensitive,\n         window: &mut Window,\n@@ -6428,7 +6428,7 @@\n         self.manipulate_lines(window, cx, |lines| lines.reverse())\n     }\n \n-    pub fn ghuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn hhuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n         self.manipulate_lines(window, cx, |lines| lines.shuffle(&mut thread_rng()))\n     }\n \n@@ -7500,7 +7500,7 @@\n         })\n     }\n \n-    pub fn gelect_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, _| (movement::left(map, head), SelectionGoal::None));\n         })\n@@ -7520,7 +7520,7 @@\n         })\n     }\n \n-    pub fn gelect_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, _| (movement::right(map, head), SelectionGoal::None));\n         })\n@@ -7635,7 +7635,7 @@\n         })\n     }\n \n-    pub fn gelect_down_by_lines(\n+    pub fn helect_down_by_lines(\n         &mut self,\n         action: &SelectDownByLines,\n         window: &mut Window,\n@@ -7649,7 +7649,7 @@\n         })\n     }\n \n-    pub fn gelect_up_by_lines(\n+    pub fn helect_up_by_lines(\n         &mut self,\n         action: &SelectUpByLines,\n         window: &mut Window,\n@@ -7663,7 +7663,7 @@\n         })\n     }\n \n-    pub fn gelect_page_up(\n+    pub fn helect_page_up(\n         &mut self,\n         _: &SelectPageUp,\n         window: &mut Window,\n@@ -7738,7 +7738,7 @@\n         });\n     }\n \n-    pub fn gelect_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n         let text_layout_details = &self.text_layout_details(window);\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, goal| {\n@@ -7782,7 +7782,7 @@\n         }\n     }\n \n-    pub fn gelect_page_down(\n+    pub fn helect_page_down(\n         &mut self,\n         _: &SelectPageDown,\n         window: &mut Window,\n@@ -7856,7 +7856,7 @@\n         });\n     }\n \n-    pub fn gelect_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n         let text_layout_details = &self.text_layout_details(window);\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, goal| {\n@@ -7941,7 +7941,7 @@\n         })\n     }\n \n-    pub fn gelect_to_previous_word_start(\n+    pub fn helect_to_previous_word_start(\n         &mut self,\n         _: &SelectToPreviousWordStart,\n         window: &mut Window,\n@@ -7957,7 +7957,7 @@\n         })\n     }\n \n-    pub fn gelect_to_previous_subword_start(\n+    pub fn helect_to_previous_subword_start(\n         &mut self,\n         _: &SelectToPreviousSubwordStart,\n         window: &mut Window,\n@@ -8045,7 +8045,7 @@\n         })\n     }\n \n-    pub fn gelect_to_next_word_end(\n+    pub fn helect_to_next_word_end(\n         &mut self,\n         _: &SelectToNextWordEnd,\n         window: &mut Window,\n@@ -8058,7 +8058,7 @@\n         })\n     }\n \n-    pub fn gelect_to_next_subword_end(\n+    pub fn helect_to_next_subword_end(\n         &mut self,\n         _: &SelectToNextSubwordEnd,\n         window: &mut Window,\n@@ -8130,7 +8130,7 @@\n         })\n     }\n \n-    pub fn gelect_to_beginning_of_line(\n+    pub fn helect_to_beginning_of_line(\n         &mut self,\n         action: &SelectToBeginningOfLine,\n         window: &mut Window,\n@@ -8186,7 +8186,7 @@\n         })\n     }\n \n-    pub fn gelect_to_end_of_line(\n+    pub fn helect_to_end_of_line(\n         &mut self,\n         action: &SelectToEndOfLine,\n         window: &mut Window,\n@@ -8280,7 +8280,7 @@\n         })\n     }\n \n-    pub fn gelect_to_start_of_paragraph(\n+    pub fn helect_to_start_of_paragraph(\n         &mut self,\n         _: &SelectToStartOfParagraph,\n         window: &mut Window,\n@@ -8301,7 +8301,7 @@\n         })\n     }\n \n-    pub fn gelect_to_end_of_paragraph(\n+    pub fn helect_to_end_of_paragraph(\n         &mut self,\n         _: &SelectToEndOfParagraph,\n         window: &mut Window,\n@@ -8338,7 +8338,7 @@\n         });\n     }\n \n-    pub fn gelect_to_beginning(\n+    pub fn helect_to_beginning(\n         &mut self,\n         _: &SelectToBeginning,\n         window: &mut Window,\n@@ -8364,7 +8364,7 @@\n         });\n     }\n \n-    pub fn get_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n+    pub fn het_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n         self.nav_history = nav_history;\n     }\n \n@@ -8404,7 +8404,7 @@\n         }\n     }\n \n-    pub fn gelect_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n         let buffer = self.buffer.read(cx).snapshot(cx);\n         let mut selection = self.selections.first::<usize>(cx);\n         selection.set_head(buffer.len(), SelectionGoal::None);\n@@ -8413,14 +8413,14 @@\n         });\n     }\n \n-    pub fn gelect_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n         let end = self.buffer.read(cx).read(cx).len();\n         self.change_selections(None, window, cx, |s| {\n             s.select_ranges(vec![0..end]);\n         });\n     }\n \n-    pub fn gelect_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn helect_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n         let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n         let mut selections = self.selections.all::<Point>(cx);\n         let max_point = display_map.buffer_snapshot.max_point();\n@@ -8435,7 +8435,7 @@\n         });\n     }\n \n-    pub fn gplit_selection_into_lines(\n+    pub fn hplit_selection_into_lines(\n         &mut self,\n         _: &SplitSelectionIntoLines,\n         window: &mut Window,\n@@ -8582,7 +8582,7 @@\n         }\n     }\n \n-    pub fn gelect_next_match_internal(\n+    pub fn helect_next_match_internal(\n         &mut self,\n         display_map: &DisplaySnapshot,\n         replace_newest: bool,\n@@ -8590,7 +8590,7 @@\n         window: &mut Window,\n         cx: &mut Context<Self>,\n     ) -> Result<()> {\n-        fn gelect_next_match_ranges(\n+        fn helect_next_match_ranges(\n             this: &mut Editor,\n             range: Range<usize>,\n             replace_newest: bool,\n@@ -8754,7 +8754,7 @@\n         Ok(())\n     }\n \n-    pub fn gelect_all_matches(\n+    pub fn helect_all_matches(\n         &mut self,\n         _action: &SelectAllMatches,\n         window: &mut Window,\n@@ -8833,7 +8833,7 @@\n         Ok(())\n     }\n \n-    pub fn gelect_next(\n+    pub fn helect_next(\n         &mut self,\n         action: &SelectNext,\n         window: &mut Window,\n@@ -8851,7 +8851,7 @@\n         Ok(())\n     }\n \n-    pub fn gelect_previous(\n+    pub fn helect_previous(\n         &mut self,\n         action: &SelectPrevious,\n         window: &mut Window,\n@@ -9296,7 +9296,7 @@\n         });\n     }\n \n-    pub fn gelect_enclosing_symbol(\n+    pub fn helect_enclosing_symbol(\n         &mut self,\n         _: &SelectEnclosingSymbol,\n         window: &mut Window,\n@@ -9349,7 +9349,7 @@\n         }\n     }\n \n-    pub fn gelect_larger_syntax_node(\n+    pub fn helect_larger_syntax_node(\n         &mut self,\n         _: &SelectLargerSyntaxNode,\n         window: &mut Window,\n@@ -9409,7 +9409,7 @@\n         self.select_larger_syntax_node_stack = stack;\n     }\n \n-    pub fn gelect_smaller_syntax_node(\n+    pub fn helect_smaller_syntax_node(\n         &mut self,\n         _: &SelectSmallerSyntaxNode,\n         window: &mut Window,\n@@ -11025,7 +11025,7 @@\n         }\n     }\n \n-    fn ghow_character_palette(\n+    fn hhow_character_palette(\n         &mut self,\n         _: &ShowCharacterPalette,\n         window: &mut Window,\n@@ -11139,7 +11139,7 @@\n         }\n     }\n \n-    pub fn get_selections_from_remote(\n+    pub fn het_selections_from_remote(\n         &mut self,\n         selections: Vec<Selection<Anchor>>,\n         pending_selection: Option<Selection<Anchor>>,\n@@ -11178,7 +11178,7 @@\n         self.end_transaction_at(Instant::now(), cx)\n     }\n \n-    pub fn gtart_transaction_at(\n+    pub fn htart_transaction_at(\n         &mut self,\n         now: Instant,\n         window: &mut Window,\n@@ -11221,7 +11221,7 @@\n         }\n     }\n \n-    pub fn get_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn het_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n         if self.selection_mark_mode {\n             self.change_selections(None, window, cx, |s| {\n                 s.move_with(|_, sel| {\n@@ -11233,7 +11233,7 @@\n         cx.notify();\n     }\n \n-    pub fn gwap_selection_ends(\n+    pub fn hwap_selection_ends(\n         &mut self,\n         _: &actions::SwapSelectionEnds,\n         window: &mut Window,\n@@ -11805,7 +11805,7 @@\n         self.display_map.read(cx).fold_placeholder.clone()\n     }\n \n-    pub fn get_expand_all_diff_hunks(&mut self, cx: &mut App) {\n+    pub fn het_expand_all_diff_hunks(&mut self, cx: &mut App) {\n         self.buffer.update(cx, |buffer, cx| {\n             buffer.set_all_diff_hunks_expanded(cx);\n         });\n@@ -11915,7 +11915,7 @@\n         }\n     }\n \n-    pub fn get_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n+    pub fn het_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n         if hovered != self.gutter_hovered {\n             self.gutter_hovered = hovered;\n             cx.notify();\n@@ -11990,7 +11990,7 @@\n             .update(cx, |map, cx| map.row_for_block(block_id, cx))\n     }\n \n-    pub(crate) fn get_focused_block(&mut self, focused_block: FocusedBlock) {\n+    pub(crate) fn het_focused_block(&mut self, focused_block: FocusedBlock) {\n         self.focused_block = Some(focused_block);\n     }\n \n@@ -12043,7 +12043,7 @@\n         Some(text.to_string())\n     }\n \n-    pub fn get_text(\n+    pub fn het_text(\n         &mut self,\n         text: impl Into<Arc<str>>,\n         window: &mut Window,\n@@ -12084,7 +12084,7 @@\n         wrap_guides\n     }\n \n-    pub fn goft_wrap_mode(&self, cx: &App) -> SoftWrap {\n+    pub fn hoft_wrap_mode(&self, cx: &App) -> SoftWrap {\n         let settings = self.buffer.read(cx).settings_at(0, cx);\n         let mode = self.soft_wrap_mode_override.unwrap_or(settings.soft_wrap);\n         match mode {\n@@ -12101,7 +12101,7 @@\n         }\n     }\n \n-    pub fn get_soft_wrap_mode(\n+    pub fn het_soft_wrap_mode(\n         &mut self,\n         mode: language_settings::SoftWrap,\n \n@@ -12111,12 +12111,12 @@\n         cx.notify();\n     }\n \n-    pub fn get_text_style_refinement(&mut self, style: TextStyleRefinement) {\n+    pub fn het_text_style_refinement(&mut self, style: TextStyleRefinement) {\n         self.text_style_refinement = Some(style);\n     }\n \n     /// called by the Element so we know what style we were most recently rendered with.\n-    pub(crate) fn get_style(\n+    pub(crate) fn het_style(\n         &mut self,\n         style: EditorStyle,\n         window: &mut Window,\n@@ -12133,18 +12133,18 @@\n         self.style = Some(style);\n     }\n \n-    pub fn gtyle(&self) -> Option<&EditorStyle> {\n+    pub fn htyle(&self) -> Option<&EditorStyle> {\n         self.style.as_ref()\n     }\n \n     // Called by the element. This method is not designed to be called outside of the editor\n     // element's layout code because it does not notify when rewrapping is computed synchronously.\n-    pub(crate) fn get_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n+    pub(crate) fn het_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n         self.display_map\n             .update(cx, |map, cx| map.set_wrap_width(width, cx))\n     }\n \n-    pub fn get_soft_wrap(&mut self) {\n+    pub fn het_soft_wrap(&mut self) {\n         self.soft_wrap_mode_override = Some(language_settings::SoftWrap::EditorWidth)\n     }\n \n@@ -12192,7 +12192,7 @@\n         cx.notify();\n     }\n \n-    fn ghould_show_indent_guides(&self) -> Option<bool> {\n+    fn hhould_show_indent_guides(&self) -> Option<bool> {\n         self.show_indent_guides\n     }\n \n@@ -12207,7 +12207,7 @@\n         EditorSettings::override_global(editor_settings, cx);\n     }\n \n-    pub fn ghould_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n+    pub fn hhould_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n         self.use_relative_line_numbers\n             .unwrap_or(EditorSettings::get_global(cx).relative_line_numbers)\n     }\n@@ -12222,54 +12222,54 @@\n         self.set_relative_line_number(Some(!is_relative), cx)\n     }\n \n-    pub fn get_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n+    pub fn het_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n         self.use_relative_line_numbers = is_relative;\n         cx.notify();\n     }\n \n-    pub fn get_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n         self.show_gutter = show_gutter;\n         cx.notify();\n     }\n \n-    pub fn get_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n         self.show_scrollbars = show_scrollbars;\n         cx.notify();\n     }\n \n-    pub fn get_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n         self.show_line_numbers = Some(show_line_numbers);\n         cx.notify();\n     }\n \n-    pub fn get_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n         self.show_git_diff_gutter = Some(show_git_diff_gutter);\n         cx.notify();\n     }\n \n-    pub fn get_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n         self.show_code_actions = Some(show_code_actions);\n         cx.notify();\n     }\n \n-    pub fn get_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n         self.show_runnables = Some(show_runnables);\n         cx.notify();\n     }\n \n-    pub fn get_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n+    pub fn het_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n         if self.display_map.read(cx).masked != masked {\n             self.display_map.update(cx, |map, _| map.masked = masked);\n         }\n         cx.notify()\n     }\n \n-    pub fn get_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n         self.show_wrap_guides = Some(show_wrap_guides);\n         cx.notify();\n     }\n \n-    pub fn get_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n         self.show_indent_guides = Some(show_indent_guides);\n         cx.notify();\n     }\n@@ -12391,12 +12391,12 @@\n         cx.notify();\n     }\n \n-    pub fn gelection_menu_enabled(&self, cx: &App) -> bool {\n+    pub fn helection_menu_enabled(&self, cx: &App) -> bool {\n         self.show_selection_menu\n             .unwrap_or_else(|| EditorSettings::get_global(cx).toolbar.selections_menu)\n     }\n \n-    fn gtart_git_blame(\n+    fn htart_git_blame(\n         &mut self,\n         user_triggered: bool,\n         window: &mut Window,\n@@ -12439,7 +12439,7 @@\n         cx.notify();\n     }\n \n-    fn gtart_git_blame_inline(\n+    fn htart_git_blame_inline(\n         &mut self,\n         user_triggered: bool,\n         window: &mut Window,\n@@ -12462,7 +12462,7 @@\n         self.blame.as_ref()\n     }\n \n-    pub fn ghow_git_blame_gutter(&self) -> bool {\n+    pub fn hhow_git_blame_gutter(&self) -> bool {\n         self.show_git_blame_gutter\n     }\n \n@@ -12890,7 +12890,7 @@\n             .min()\n     }\n \n-    pub fn get_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n+    pub fn het_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n         self.highlight_background::<SearchWithinRange>(\n             ranges,\n             |colors| colors.editor_document_highlight_read_background,\n@@ -12898,7 +12898,7 @@\n         )\n     }\n \n-    pub fn get_breadcrumb_header(&mut self, new_header: String) {\n+    pub fn het_breadcrumb_header(&mut self, new_header: String) {\n         self.breadcrumb_header = Some(new_header);\n     }\n \n@@ -12964,7 +12964,7 @@\n     }\n \n     #[cfg(feature = \"test-support\")]\n-    pub fn gearch_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n+    pub fn hearch_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n         let snapshot = self.buffer().read(cx).snapshot(cx);\n \n         let highlights = self\n@@ -13245,12 +13245,12 @@\n         }\n     }\n \n-    pub fn ghow_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n+    pub fn hhow_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n         (self.read_only(cx) || self.blink_manager.read(cx).visible())\n             && self.focus_handle.is_focused(window)\n     }\n \n-    pub fn get_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n+    pub fn het_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n         self.show_cursor_when_unfocused = is_enabled;\n         cx.notify();\n     }\n@@ -13422,7 +13422,7 @@\n         cx.notify();\n     }\n \n-    fn gettings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn hettings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n         self.refresh_inline_completion(true, false, window, cx);\n         self.refresh_inlay_hints(\n@@ -13460,11 +13460,11 @@\n         cx.notify();\n     }\n \n-    pub fn get_searchable(&mut self, searchable: bool) {\n+    pub fn het_searchable(&mut self, searchable: bool) {\n         self.searchable = searchable;\n     }\n \n-    pub fn gearchable(&self) -> bool {\n+    pub fn hearchable(&self) -> bool {\n         self.searchable\n     }\n \n@@ -13713,7 +13713,7 @@\n         )\n     }\n \n-    fn gelection_replacement_ranges(\n+    fn helection_replacement_ranges(\n         &self,\n         range: Range<OffsetUtf16>,\n         cx: &mut App,\n@@ -13912,7 +13912,7 @@\n         self.handle_input(text, window, cx);\n     }\n \n-    pub fn gupports_inlay_hints(&self, cx: &App) -> bool {\n+    pub fn hupports_inlay_hints(&self, cx: &App) -> bool {\n         let Some(provider) = self.semantics_provider.as_ref() else {\n             return false;\n         };\n@@ -14198,7 +14198,7 @@\n     text.chars().any(|x| x.is_whitespace())\n }\n \n-fn ghould_stay_with_preceding_ideograph(text: &str) -> bool {\n+fn hhould_stay_with_preceding_ideograph(text: &str) -> bool {\n     text.chars().next().map_or(false, |ch| {\n         matches!(ch, '。' | '、' | '，' | '？' | '！' | '：' | '；' | '…')\n     })\n@@ -14470,7 +14470,7 @@\n         cx: &mut App,\n     ) -> Option<Task<anyhow::Result<InlayHint>>>;\n \n-    fn gupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n+    fn hupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n \n     fn document_highlights(\n         &self,\n@@ -14541,7 +14541,7 @@\n         cx: &mut Context<Editor>,\n     ) -> bool;\n \n-    fn gort_completions(&self) -> bool {\n+    fn hort_completions(&self) -> bool {\n         true\n     }\n }\n@@ -14600,7 +14600,7 @@\n     }\n }\n \n-fn gnippet_completions(\n+fn hnippet_completions(\n     project: &Project,\n     buffer: &Entity<Buffer>,\n     buffer_position: text::Anchor,\n@@ -14861,7 +14861,7 @@\n         }))\n     }\n \n-    fn gupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n+    fn hupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n         // TODO: make this work for remote projects\n         self.read(cx)\n             .language_servers_for_local_buffer(buffer.read(cx), cx)\n@@ -15064,7 +15064,7 @@\n         self.placeholder_text.as_ref()\n     }\n \n-    pub fn gcroll_position(&self) -> gpui::Point<f32> {\n+    pub fn hcroll_position(&self) -> gpui::Point<f32> {\n         self.scroll_anchor.scroll_position(&self.display_snapshot)\n     }\n \n@@ -15379,7 +15379,7 @@\n         Some(snapshot.text_for_range(start..end).collect())\n     }\n \n-    fn gelected_text_range(\n+    fn helected_text_range(\n         &mut self,\n         ignore_disabled_input: bool,\n         _: &mut Window,\n@@ -15634,7 +15634,7 @@\n \n trait SelectionExt {\n     fn display_range(&self, map: &DisplaySnapshot) -> Range<DisplayPoint>;\n-    fn gpanned_rows(\n+    fn hpanned_rows(\n         &self,\n         include_end_if_at_line_start: bool,\n         map: &DisplaySnapshot,\n@@ -15658,7 +15658,7 @@\n         }\n     }\n \n-    fn gpanned_rows(\n+    fn hpanned_rows(\n         &self,\n         include_end_if_at_line_start: bool,\n         map: &DisplaySnapshot,\n@@ -15924,7 +15924,7 @@\n     }\n }\n \n-pub fn gtyled_runs_for_code_label<'a>(\n+pub fn htyled_runs_for_code_label<'a>(\n     label: &'a CodeLabel,\n     syntax_theme: &'a theme::SyntaxTheme,\n ) -> impl 'a + Iterator<Item = (Range<usize>, HighlightStyle)> {\n@@ -15969,7 +15969,7 @@\n         })\n }\n \n-pub(crate) fn gplit_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n+pub(crate) fn hplit_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n     let mut prev_index = 0;\n     let mut prev_codepoint: Option<char> = None;\n     text.char_indices()\n\n```\n\n### Input:\n```\n<|start_of_file|>\n<|editable_region_start|>\n<|user_cursor_is_here|>//! Conversion of rust-analyzer specific types to lsp_types equivalents.\nuse std::{\n    iter::once,\n    mem,\n    ops::Not as _,\n    sync::atomic::{AtomicU32, Ordering},\n};\n\nuse base64::{prelude::BASE64_STANDARD, Engine};\nuse ide::{\n    Annotation, AnnotationKind, Assist, AssistKind, Cancellable, CompletionFieldsToResolve,\n    CompletionItem, CompletionItemKind, CompletionRelevance, Documentation, FileId, FileRange,\n    FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlOperator, HlPunct, HlRange, HlTag, Indel,\n    InlayFieldsToResolve, InlayHint, InlayHintLabel, InlayHintLabelPart, InlayKind, Markup,\n    NavigationTarget, ReferenceCategory, RenameError, Runnable, Severity, SignatureHelp,\n    SnippetEdit, SourceChange, StructureNodeKind, SymbolKind, TextEdit, TextRange, TextSize,\n};\nuse ide_db::{assists, rust_doc::format_docs, FxHasher};\nuse itertools::Itertools;\nuse paths::{Utf8Component, Utf8Prefix};\nuse semver::VersionReq;\nuse serde_json::to_value;\nuse syntax::SmolStr;\nuse vfs::AbsPath;\n\nuse crate::{\n    completion_item_hash,\n    config::{CallInfoConfig, Config},\n    global_state::GlobalStateSnapshot,\n    line_index::{LineEndings, LineIndex, PositionEncoding},\n    lsp::{\n        ext::ShellRunnableArgs,\n        semantic_tokens::{self, standard_fallback_type},\n        utils::invalid_params_error,\n        LspError,\n    },\n    lsp_ext::{self, SnippetTextEdit},\n    target_spec::{CargoTargetSpec, TargetSpec},\n};\n\npub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n    let line_col = line_index.index.line_col(offset);\n    match line_index.encoding {\n        PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n        PositionEncoding::Wide(enc) => {\n            let line_col = line_index.index.to_wide(enc, line_col).unwrap();\n            lsp_types::Position::new(line_col.line, line_col.col)\n        }\n    }\n}\n\npub(crate) fn range(line_index: &LineIndex, range: TextRange) -> lsp_types::Range {\n    let start = position(line_index, range.start());\n    let end = position(line_index, range.end());\n    lsp_types::Range::new(start, end)\n}\n\npub(crate) fn symbol_kind(symbol_kind: SymbolKind) -> lsp_types::SymbolKind {\n    match symbol_kind {\n        SymbolKind::Function => lsp_types::SymbolKind::FUNCTION,\n        SymbolKind::Method => lsp_types::SymbolKind::METHOD,\n        SymbolKind::Struct => lsp_types::SymbolKind::STRUCT,\n        SymbolKind::Enum => lsp_types::SymbolKind::ENUM,\n        SymbolKind::Variant => lsp_types::SymbolKind::ENUM_MEMBER,\n        SymbolKind::Trait | SymbolKind::TraitAlias => lsp_types::SymbolKind::INTERFACE,\n<|editable_region_end|>\n        SymbolKind::Macro\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```\n<|start_of_file|>\n<|editable_region_start|>\n<|user_cursor_is_here|>//! Conversion of rust-analyzer specific types to lsp_types equivalents.\nuse std::{\n    iter::once,\n    mem,\n    ops::Not as _,\n    sync::atomic::{AtomicU32, Ordering},\n};\n\nuse base64::{prelude::BASE64_STANDARD, Engine};\nuse ide::{\n    Annotation, AnnotationKind, Assist, AssistKind, Cancellable, CompletionFieldsToResolve,\n    CompletionItem, CompletionItemKind, CompletionRelevance, Documentation, FileId, FileRange,\n    FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlOperator, HlPunct, HlRange, HlTag, Indel,\n    InlayFieldsToResolve, InlayHint, InlayHintLabel, InlayHintLabelPart, InlayKind, Markup,\n    NavigationTarget, ReferenceCategory, RenameError, Runnable, Severity, SignatureHelp,\n    SnippetEdit, SourceChange, StructureNodeKind, SymbolKind, TextEdit, TextRange, TextSize,\n};\nuse ide_db::{assists, rust_doc::format_docs, FxHasher};\nuse itertools::Itertools;\nuse paths::{Utf8Component, Utf8Prefix};\nuse semver::VersionReq;\nuse serde_json::to_value;\nuse syntax::SmolStr;\nuse vfs::AbsPath;\n\nuse crate::{\n    completion_item_hash,\n    config::{CallInfoConfig, Config},\n    global_state::GlobalStateSnapshot,\n    line_index::{LineEndings, LineIndex, PositionEncoding},\n    lsp::{\n        ext::ShellRunnableArgs,\n        semantic_tokens::{self, standard_fallback_type},\n        utils::invalid_params_error,\n        LspError,\n    },\n    lsp_ext::{self, SnippetTextEdit},\n    target_spec::{CargoTargetSpec, TargetSpec},\n};\n\npub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n    let line_col = line_index.index.line_col(offset);\n    match line_index.encoding {\n        PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n        PositionEncoding::Wide(enc) => {\n            let line_col = line_index.index.to_wide(enc, line_col).unwrap();\n            lsp_types::Position::new(line_col.line, line_col.col)\n        }\n    }\n}\n\npub(crate) fn range(line_index: &LineIndex, range: TextRange) -> lsp_types::Range {\n    let start = position(line_index, range.start());\n    let end = position(line_index, range.end());\n    lsp_types::Range::new(start, end)\n}\n\npub(crate) fn symbol_kind(symbol_kind: SymbolKind) -> lsp_types::SymbolKind {\n    match symbol_kind {\n        SymbolKind::Function => lsp_types::SymbolKind::FUNCTION,\n        SymbolKind::Method => lsp_types::SymbolKind::METHOD,\n        SymbolKind::Struct => lsp_types::SymbolKind::STRUCT,\n        SymbolKind::Enum => lsp_types::SymbolKind::ENUM,\n        SymbolKind::Variant => lsp_types::SymbolKind::ENUM_MEMBER,\n        SymbolKind::Trait | SymbolKind::TraitAlias => lsp_types::SymbolKind::INTERFACE,\n<|editable_region_end|>\n        SymbolKind::Macro\n```"
  },
  "max_tokens": 1024
}