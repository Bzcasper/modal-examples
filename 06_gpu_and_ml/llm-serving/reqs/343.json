{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\n\n\n### Input:\n```crates/editor/src/inline_completion_tests.rs\n<|start_of_file|>\n<|editable_region_start|>\nuse gpui::{prelude::*, Entity};\nuse indoc::indoc;\nuse inline_completion::InlineCompletionProvider;\nuse language::{L<|user_cursor_is_here|>anguage, LanguageConfig};\nuse multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\nuse std::{num::NonZeroU32, ops::Range, sync::Arc};\nuse text::{Point, ToOffset};\n\nuse crate::{\n    editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n};\n\n#[gpui::test]\nasync fn test_inline_completion_insert(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let absolute_zero_celsius = ˇ;\");\n\n    propose_edits(&provider, vec![(28..28, \"-273.15\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"-273.15\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let absolute_zero_celsius = -273.15ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_modification(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let pi = ˇ\\\"foo\\\";\");\n\n    propose_edits(&provider, vec![(9..14, \"3.14159\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"3.14159\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let pi = 3.14159ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_jump_button(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n\n    // Cursor is 2+ lines above the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line ˇ1\n        line 2\n        line 3\n        line\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(4, 3)..Point::new(4, 3), \" 4\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(4, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        line 1\n        line 2\n        line 3\n        linˇe\n    \"});\n\n    // Cursor is 2+ lines below the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line\n        line 2\n        line 3\n        line ˇ4\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(1, 3)..Point::new(1, 3), \" 1\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(1, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        linˇe\n        line 2\n        line 3\n        line 4\n    \"});\n}\n\n#[gpui::test]\nasync fn test_indentation(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(\n        Language::new(\n<|editable_region_end|>\n    let language = Arc::new(\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/editor/src/inline_completion_tests.rs\n<|start_of_file|>\n<|editable_region_start|>\nuse gpui::{prelude::*, Entity};\nuse indoc::indoc;\nuse inline_completion::InlineCompletionProvider;\nuse language::{L<|user_cursor_is_here|>anguage, LanguageConfig};\nuse multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\nuse std::{num::NonZeroU32, ops::Range, sync::Arc};\nuse text::{Point, ToOffset};\n\nuse crate::{\n    editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n};\n\n#[gpui::test]\nasync fn test_inline_completion_insert(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let absolute_zero_celsius = ˇ;\");\n\n    propose_edits(&provider, vec![(28..28, \"-273.15\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"-273.15\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let absolute_zero_celsius = -273.15ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_modification(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let pi = ˇ\\\"foo\\\";\");\n\n    propose_edits(&provider, vec![(9..14, \"3.14159\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"3.14159\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let pi = 3.14159ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_jump_button(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n\n    // Cursor is 2+ lines above the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line ˇ1\n        line 2\n        line 3\n        line\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(4, 3)..Point::new(4, 3), \" 4\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(4, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        line 1\n        line 2\n        line 3\n        linˇe\n    \"});\n\n    // Cursor is 2+ lines below the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line\n        line 2\n        line 3\n        line ˇ4\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(1, 3)..Point::new(1, 3), \" 1\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(1, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        linˇe\n        line 2\n        line 3\n        line 4\n    \"});\n}\n\n#[gpui::test]\nasync fn test_indentation(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n    let language = Arc::new(\n        Language::new(\n<|editable_region_end|>\n    let language = Arc::new(\n```"
  },
  "max_tokens": 1024
}