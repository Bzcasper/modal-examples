{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -451,6 +451,7 @@\n                 menu = menu.separator().item(\n                     ContextMenuEntry::new(\"Data Collection\")\n                         .toggleable(IconPosition::Start, data_collection.is_enabled())\n+                        .disabled\n                         .handler(move |_, cx| {\n                             provider.toggle_data_collection(cx);\n                         }),\n\n```\n\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -451,7 +451,7 @@\n                 menu = menu.separator().item(\n                     ContextMenuEntry::new(\"Data Collection\")\n                         .toggleable(IconPosition::Start, data_collection.is_enabled())\n-                        .disabled\n+                        .disabled(!data_collection.is_supported())\n                         .handler(move |_, cx| {\n                             provider.toggle_data_collection(cx);\n                         }),\n\n```\n\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -20,7 +20,10 @@\n use settings::{update_settings_file, Settings, SettingsStore};\n use std::{path::Path, sync::Arc, time::Duration};\n use supermaven::{AccountStatus, Supermaven};\n-use ui::{prelude::*, ButtonLike, Color, Icon, IconWithIndicator, Indicator, PopoverMenuHandle};\n+use ui::{\n+    prelude::*, ButtonLike, Color, ContextMenuEntry, Icon, IconWithIndicator, Indicator,\n+    PopoverMenuHandle,\n+};\n use workspace::{\n     create_and_open_local_file,\n     item::ItemHandle,\n\n```\n\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -454,7 +454,7 @@\n                 menu = menu.separator().item(\n                     ContextMenuEntry::new(\"Data Collection\")\n                         .toggleable(IconPosition::Start, data_collection.is_enabled())\n-                        .disabled(!data_collection.is_supported())\n+                        .disabled(!data_collection.())\n                         .handler(move |_, cx| {\n                             provider.toggle_data_collection(cx);\n                         }),\n\n```\n\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -454,7 +454,7 @@\n                 menu = menu.separator().item(\n                     ContextMenuEntry::new(\"Data Collection\")\n                         .toggleable(IconPosition::Start, data_collection.is_enabled())\n-                        .disabled(!data_collection.())\n+                        .disabled(!data_collection.is_unknown())\n                         .handler(move |_, cx| {\n                             provider.toggle_data_collection(cx);\n                         }),\n\n```\n\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -454,7 +454,7 @@\n                 menu = menu.separator().item(\n                     ContextMenuEntry::new(\"Data Collection\")\n                         .toggleable(IconPosition::Start, data_collection.is_enabled())\n-                        .disabled(!data_collection.is_unknown())\n+                        .disabled(data_collection.is_unknown())\n                         .handler(move |_, cx| {\n                             provider.toggle_data_collection(cx);\n                         }),\n\n```\n\nUser edited \"crates/inline_completion_button/src/inline_completion_button.rs\":\n```diff\n@@ -450,7 +450,6 @@\n         if let Some(provider) = &self.inline_completion_provider {\n             let data_collection = provider.data_collection_state(cx);\n             if data_collection.is_supported() {\n-                let provider = provider.clone();\n                 menu = menu.separator().item(\n                     ContextMenuEntry::new(\"Data Collection\")\n                         .toggleable(IconPosition::Start, data_collection.is_enabled())\n\n```\n\n### Input:\n```crates/ui/src/components/context_menu.rs\n            handler: Rc::new(move |_, window, cx| handler(window, cx)),\n<|editable_region_start|>\n            selectable: true,\n        }\n    }\n}\n\npub struct ContextMenuEntry {\n    toggle: Option<(IconPosition, bool)>,\n    label: SharedString,\n    icon: Option<IconName>,\n    icon_position: IconPosition,\n    icon_size: IconSize,\n    icon_color: Option<Color>,\n    handler: Rc<dyn Fn(Option<&FocusHandle>, &mut Window, &mut App)>,\n    action: Option<Box<dyn Action>>,\n    disabled: bool,\n}\n\nimpl ContextMenuEntry {\n    pub fn new(label: impl Into<SharedString>) -> Self {\n        ContextMenuEntry {\n            toggle: None,\n            label: label.into(),\n            icon: None,\n            icon_position: IconPosition::Start,\n            icon_size: IconSize::Small,\n            icon_color: None,\n            handler: Rc::new(|_, _, _| {}),\n            action: None,\n            disabled: false,\n        }\n    }\n\n    pub fn toggleable(mut self, toggle_position: IconPosition, toggled: bool) -> Self {\n        self.toggle = Some((toggle_position, toggled));\n        self\n    }\n\n    pub fn icon(mut self, icon: IconName) -> Self {\n        self.icon = Some(icon);\n        self\n    }\n\n    pub fn icon_position(mut self, position: IconPosition) -> Self {\n        self.icon_position = position;\n        self\n    }\n\n    pub fn icon_size(mut self, icon_size: IconSize) -> Self {\n        self.icon_size = icon_size;\n        self\n    }\n\n    pub fn icon_color(mut self, icon_color: Color) -> Self {\n        self.icon_color = Some(icon_color);\n        self\n    }\n\n    pub fn toggle(mut self, toggle_position: IconPosition, toggled: bool) -> Self {\n        self.toggle = Some((toggle_position, toggled));\n        self\n    }\n\n    pub fn action(mut self, action: Option<Box<dyn Action>>) -> Self {\n        self.action = action;\n        self\n    }\n\n    pub fn handler(mut self, handler: impl Fn(&mut Window, &mut App) + 'static) -> Self {\n        self.handler = Rc::new(move |_, window, cx| handler(window, cx));\n        self\n    }\n<|user_cursor_is_here|>\n    pub fn disabled(mut self, disabled: bool) -> Self {\n        self.disabled = disabled;\n        self\n    }\n}\n\nimpl From<ContextMenuEntry> for ContextMenuItem {\n    fn from(entry: ContextMenuEntry) -> Self {\n        ContextMenuItem::Entry(entry)\n    }\n}\n\npub struct ContextMenu {\n    items: Vec<ContextMenuItem>,\n    focus_handle: FocusHandle,\n    action_context: Option<FocusHandle>,\n    selected_index: Option<usize>,\n    delayed: bool,\n    clicked: bool,\n    _on_blur_subscription: Subscription,\n    keep_open_on_confirm: bool,\n}\n\nimpl Focusable for ContextMenu {\n    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl EventEmitter<DismissEvent> for ContextMenu {}\n\nimpl FluentBuilder for ContextMenu {}\n\nimpl ContextMenu {\n    pub fn build(\n        window: &mut Window,\n        cx: &mut App,\n        f: impl FnOnce(Self, &mut Window, &mut Context<Self>) -> Self,\n    ) -> Entity<Self> {\n        cx.new(|cx| {\n            let focus_handle = cx.focus_handle();\n            let _on_blur_subscription = cx.on_blur(\n                &focus_handle,\n                window,\n                |this: &mut ContextMenu, window, cx| this.cancel(&menu::Cancel, window, cx),\n            );\n            window.refresh();\n            f(\n                Self {\n                    items: Default::default(),\n                    focus_handle,\n                    action_context: None,\n                    selected_index: None,\n                    delayed: false,\n                    clicked: false,\n                    _on_blur_subscription,\n                    keep_open_on_confirm: false,\n                },\n                window,\n                cx,\n            )\n        })\n    }\n\n    pub fn context(mut self, focus: FocusHandle) -> Self {\n        self.action_context = Some(focus);\n        self\n    }\n\n    pub fn header(mut self, title: impl Into<SharedString>) -> Self {\n        self.items.push(ContextMenuItem::Header(title.into()));\n        self\n<|editable_region_end|>\n        self.items.push(ContextMenuItem::Header(title.into()));\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/ui/src/components/context_menu.rs\n            handler: Rc::new(move |_, window, cx| handler(window, cx)),\n<|editable_region_start|>\n            selectable: true,\n        }\n    }\n}\n\npub struct ContextMenuEntry {\n    toggle: Option<(IconPosition, bool)>,\n    label: SharedString,\n    icon: Option<IconName>,\n    icon_position: IconPosition,\n    icon_size: IconSize,\n    icon_color: Option<Color>,\n    handler: Rc<dyn Fn(Option<&FocusHandle>, &mut Window, &mut App)>,\n    action: Option<Box<dyn Action>>,\n    disabled: bool,\n}\n\nimpl ContextMenuEntry {\n    pub fn new(label: impl Into<SharedString>) -> Self {\n        ContextMenuEntry {\n            toggle: None,\n            label: label.into(),\n            icon: None,\n            icon_position: IconPosition::Start,\n            icon_size: IconSize::Small,\n            icon_color: None,\n            handler: Rc::new(|_, _, _| {}),\n            action: None,\n            disabled: false,\n        }\n    }\n\n    pub fn toggleable(mut self, toggle_position: IconPosition, toggled: bool) -> Self {\n        self.toggle = Some((toggle_position, toggled));\n        self\n    }\n\n    pub fn icon(mut self, icon: IconName) -> Self {\n        self.icon = Some(icon);\n        self\n    }\n\n    pub fn icon_position(mut self, position: IconPosition) -> Self {\n        self.icon_position = position;\n        self\n    }\n\n    pub fn icon_size(mut self, icon_size: IconSize) -> Self {\n        self.icon_size = icon_size;\n        self\n    }\n\n    pub fn icon_color(mut self, icon_color: Color) -> Self {\n        self.icon_color = Some(icon_color);\n        self\n    }\n\n    pub fn toggle(mut self, toggle_position: IconPosition, toggled: bool) -> Self {\n        self.toggle = Some((toggle_position, toggled));\n        self\n    }\n\n    pub fn action(mut self, action: Option<Box<dyn Action>>) -> Self {\n        self.action = action;\n        self\n    }\n\n    pub fn handler(mut self, handler: impl Fn(&mut Window, &mut App) + 'static) -> Self {\n        self.handler = Rc::new(move |_, window, cx| handler(window, cx));\n        self\n    }\n<|user_cursor_is_here|>\n    pub fn disabled(mut self, disabled: bool) -> Self {\n        self.disabled = disabled;\n        self\n    }\n}\n\nimpl From<ContextMenuEntry> for ContextMenuItem {\n    fn from(entry: ContextMenuEntry) -> Self {\n        ContextMenuItem::Entry(entry)\n    }\n}\n\npub struct ContextMenu {\n    items: Vec<ContextMenuItem>,\n    focus_handle: FocusHandle,\n    action_context: Option<FocusHandle>,\n    selected_index: Option<usize>,\n    delayed: bool,\n    clicked: bool,\n    _on_blur_subscription: Subscription,\n    keep_open_on_confirm: bool,\n}\n\nimpl Focusable for ContextMenu {\n    fn focus_handle(&self, _cx: &App) -> FocusHandle {\n        self.focus_handle.clone()\n    }\n}\n\nimpl EventEmitter<DismissEvent> for ContextMenu {}\n\nimpl FluentBuilder for ContextMenu {}\n\nimpl ContextMenu {\n    pub fn build(\n        window: &mut Window,\n        cx: &mut App,\n        f: impl FnOnce(Self, &mut Window, &mut Context<Self>) -> Self,\n    ) -> Entity<Self> {\n        cx.new(|cx| {\n            let focus_handle = cx.focus_handle();\n            let _on_blur_subscription = cx.on_blur(\n                &focus_handle,\n                window,\n                |this: &mut ContextMenu, window, cx| this.cancel(&menu::Cancel, window, cx),\n            );\n            window.refresh();\n            f(\n                Self {\n                    items: Default::default(),\n                    focus_handle,\n                    action_context: None,\n                    selected_index: None,\n                    delayed: false,\n                    clicked: false,\n                    _on_blur_subscription,\n                    keep_open_on_confirm: false,\n                },\n                window,\n                cx,\n            )\n        })\n    }\n\n    pub fn context(mut self, focus: FocusHandle) -> Self {\n        self.action_context = Some(focus);\n        self\n    }\n\n    pub fn header(mut self, title: impl Into<SharedString>) -> Self {\n        self.items.push(ContextMenuItem::Header(title.into()));\n        self\n<|editable_region_end|>\n        self.items.push(ContextMenuItem::Header(title.into()));\n```"
  },
  "max_tokens": 1024
}