{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"untitled\":\n```diff\n@@ -83,7 +83,7 @@\n - [ ] Linux-wayland (64)              https://github.com/zed-industries/zed/issues?q=is%3Aopen%20label%3Alinux-wayland%20no%3Atype%20%20\n - [ ] Linux not:x11,wayland (159)     https://github.com/zed-industries/zed/issues?q=is%3Aopen%20-label%3Alinux-wayland%20-label%3Alinux-x11%20label%3Alinux%20no%3Atype%20%20%20\n - [ ] AI (168)                        https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3Aai%20no%3Atype\n-- [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22 (65 -> )\n+- [joseph] Panics: https://github.com/zed-industries/zed/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22panic%20%2F%20crash%22\n - [joseph] awaiting-info issues: https://github.com/zed-industries/zed/issues?q=state%3Aopen%20label%3A%22awaiting%20info%22 \n - \n \n\n```\n\n\n\nUser edited \"untitled\":\n```diff\n@@ -41,7 +41,7 @@\n   - Sorry about this! I can't easily reproduce the problem. Does this happen on all projects, or just some? Is there anything relevant in the Zed logs?\n       tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - That doesn't sound good... Can you please clarify the steps you took to make this happen?\n-      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n+e      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - Looks like a recent regression, cc @victim - could you please take a look?\n   - Makes sense. We're working on Windows/Git/AI/etc. and will look into this as part of that (tag:\"windows\", e.g.)\n   \n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -41,7 +41,7 @@\n   - Sorry about this! I can't easily reproduce the problem. Does this happen on all projects, or just some? Is there anything relevant in the Zed logs?\n       tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - That doesn't sound good... Can you please clarify the steps you took to make this happen?\n-e      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n+      tag:\"awaiting info\" so we can close if they don't reply in a month or so\n   - Looks like a recent regression, cc @victim - could you please take a look?\n   - Makes sense. We're working on Windows/Git/AI/etc. and will look into this as part of that (tag:\"windows\", e.g.)\n   \n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUser edited \"src/lib/collab.ts\":\n```diff\n@@ -300,6 +300,8 @@\n     if (response.status === 404) {\n         return null\n     }\n+    \n+    r\n \n     if (response.status != 200) {\n         let error: Error & { response?: Response } = new Error(\n\n```\n\n### Input:\n```src/lib/collab.ts\n): Promise<undefined> {\n<|editable_region_start|>\n    let url = \"/contributors\"\n    return await request(url, {\n        method: \"POST\",\n        body: {\n            github_login: githubLogin,\n            github_user_id: githubUserId,\n            github_email: githubEmail,\n            github_user_created_at: githubUserCreatedAt,\n        },\n    })\n}\n\nexport async function getClaSignatureDate(\n    githubUserId: number,\n): Promise<Date | null> {\n    let url = `/contributor?github_user_id=${githubUserId}`\n    const response = await request(url)\n    if (response?.signed_at) {\n        return new Date(response.signed_at)\n    } else {\n        return null\n    }\n}\n\nexport async function getClaSignatureDateByGitHubLogin(\n    githubLogin: string,\n): Promise<Date | null> {\n    let url = `/contributor?github_login=${githubLogin}`\n    const response = await request(url)\n    if (response?.signed_at) {\n        return new Date(response.signed_at)\n    } else {\n        return null\n    }\n}\n\ntype CreateAccessTokenResponse = {\n    user_id: number\n    encrypted_access_token: string\n}\n\nexport async function createAccessToken(\n    userId: number,\n    nativeAppPublicKey: string,\n    impersonate: string | undefined,\n): Promise<CreateAccessTokenResponse> {\n    let endpoint = `/users/${userId}/access_tokens?public_key=${nativeAppPublicKey}`\n    if (impersonate) endpoint += `&impersonate=${impersonate}`\n\n    return await request(endpoint, { method: \"post\" })\n}\n\nexport interface GetExtensionsParams {\n    maxSchemaVersion?: number\n    filter?: string\n    zedApiUrl?: string\n}\n\nexport async function getExtensions(\n    params: GetExtensionsParams = {},\n): Promise<any> {\n    let endpoint = \"/extensions\"\n    const query = new URLSearchParams()\n\n    if (typeof params.maxSchemaVersion !== \"undefined\") {\n        query.set(\"max_schema_version\", params.maxSchemaVersion.toString())\n    }\n\n    if (params.filter) {\n        query.set(\"filter\", params.filter)\n    }\n\n    if (query.size > 0) {\n        endpoint += `?${query.toString()}`\n    }\n\n    return await request(endpoint, { zedApiUrl: params.zedApiUrl })\n}\n\nexport async function getExtensionDownloadUrl(\n    extensionId: string,\n    extensionVersion: string,\n): Promise<string | null> {\n    const { response, body } = await rawRequest(\n        `/extensions/${extensionId}/${extensionVersion}/download`,\n        { redirect: \"manual\" },\n    )\n    if (response.status < 300 || response.status > 399) {\n        throw new Error(\n            `Expected a redirect, got ${response.status}: ${\n                response.statusText\n            }${body ? \": \" + body : \"\"}`,\n        )\n    }\n    return response.headers.get(\"location\")\n}\n\nexport async function request(endpoint: string, options?: any) {\n    const { response, body } = await rawRequest(endpoint, options)\n    if (response.status === 404) {\n        return null\n    }\n    \n    r<|user_cursor_is_here|>\n\n    if (response.status != 200) {\n        let error: Error & { response?: Response } = new Error(\n            `Error fetching ${endpoint}: ${response.status} ${\n                response.statusText\n            }${body ? \": \" + body : \"\"}`,\n        )\n        error.response = response\n        throw error\n    }\n\n    if (body.length > 0) {\n        return JSON.parse(body as string)\n    }\n}\n\nasync function rawRequest(endpoint: string, options?: any) {\n    if (options) {\n        options = { ...options }\n    } else {\n        options = {}\n    }\n    if (!options.headers) options.headers = {}\n    options.headers.Authorization = `token ${zedApiToken}`\n    options.headers[\"Content-Type\"] = \"application/json\"\n\n    if (options.body) {\n        options.body = JSON.stringify(options.body)\n    }\n\n    console.log(\"collab API request: %s %s\", options.method || \"GET\", endpoint)\n    const response = await fetch(\n        `${options.zedApiUrl || zedApiUrl}${endpoint}`,\n        options,\n    )\n    const body = await response.text()\n    console.log(\"collab API response: %o\", response.status, body.length)\n\n    return { response, body }\n}\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```src/lib/collab.ts\n): Promise<undefined> {\n<|editable_region_start|>\n    let url = \"/contributors\"\n    return await request(url, {\n        method: \"POST\",\n        body: {\n            github_login: githubLogin,\n            github_user_id: githubUserId,\n            github_email: githubEmail,\n            github_user_created_at: githubUserCreatedAt,\n        },\n    })\n}\n\nexport async function getClaSignatureDate(\n    githubUserId: number,\n): Promise<Date | null> {\n    let url = `/contributor?github_user_id=${githubUserId}`\n    const response = await request(url)\n    if (response?.signed_at) {\n        return new Date(response.signed_at)\n    } else {\n        return null\n    }\n}\n\nexport async function getClaSignatureDateByGitHubLogin(\n    githubLogin: string,\n): Promise<Date | null> {\n    let url = `/contributor?github_login=${githubLogin}`\n    const response = await request(url)\n    if (response?.signed_at) {\n        return new Date(response.signed_at)\n    } else {\n        return null\n    }\n}\n\ntype CreateAccessTokenResponse = {\n    user_id: number\n    encrypted_access_token: string\n}\n\nexport async function createAccessToken(\n    userId: number,\n    nativeAppPublicKey: string,\n    impersonate: string | undefined,\n): Promise<CreateAccessTokenResponse> {\n    let endpoint = `/users/${userId}/access_tokens?public_key=${nativeAppPublicKey}`\n    if (impersonate) endpoint += `&impersonate=${impersonate}`\n\n    return await request(endpoint, { method: \"post\" })\n}\n\nexport interface GetExtensionsParams {\n    maxSchemaVersion?: number\n    filter?: string\n    zedApiUrl?: string\n}\n\nexport async function getExtensions(\n    params: GetExtensionsParams = {},\n): Promise<any> {\n    let endpoint = \"/extensions\"\n    const query = new URLSearchParams()\n\n    if (typeof params.maxSchemaVersion !== \"undefined\") {\n        query.set(\"max_schema_version\", params.maxSchemaVersion.toString())\n    }\n\n    if (params.filter) {\n        query.set(\"filter\", params.filter)\n    }\n\n    if (query.size > 0) {\n        endpoint += `?${query.toString()}`\n    }\n\n    return await request(endpoint, { zedApiUrl: params.zedApiUrl })\n}\n\nexport async function getExtensionDownloadUrl(\n    extensionId: string,\n    extensionVersion: string,\n): Promise<string | null> {\n    const { response, body } = await rawRequest(\n        `/extensions/${extensionId}/${extensionVersion}/download`,\n        { redirect: \"manual\" },\n    )\n    if (response.status < 300 || response.status > 399) {\n        throw new Error(\n            `Expected a redirect, got ${response.status}: ${\n                response.statusText\n            }${body ? \": \" + body : \"\"}`,\n        )\n    }\n    return response.headers.get(\"location\")\n}\n\nexport async function request(endpoint: string, options?: any) {\n    const { response, body } = await rawRequest(endpoint, options)\n    if (response.status === 404) {\n        return null\n    }\n    \n    r<|user_cursor_is_here|>\n\n    if (response.status != 200) {\n        let error: Error & { response?: Response } = new Error(\n            `Error fetching ${endpoint}: ${response.status} ${\n                response.statusText\n            }${body ? \": \" + body : \"\"}`,\n        )\n        error.response = response\n        throw error\n    }\n\n    if (body.length > 0) {\n        return JSON.parse(body as string)\n    }\n}\n\nasync function rawRequest(endpoint: string, options?: any) {\n    if (options) {\n        options = { ...options }\n    } else {\n        options = {}\n    }\n    if (!options.headers) options.headers = {}\n    options.headers.Authorization = `token ${zedApiToken}`\n    options.headers[\"Content-Type\"] = \"application/json\"\n\n    if (options.body) {\n        options.body = JSON.stringify(options.body)\n    }\n\n    console.log(\"collab API request: %s %s\", options.method || \"GET\", endpoint)\n    const response = await fetch(\n        `${options.zedApiUrl || zedApiUrl}${endpoint}`,\n        options,\n    )\n    const body = await response.text()\n    console.log(\"collab API response: %o\", response.status, body.length)\n\n    return { response, body }\n}\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}