{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8077,10 +8077,7 @@\n         };\n \n         let mut label = label.unwrap_or_else(|| {\n-            CodeLabel::plain(\n-                lsp_completion.label.clone(),\n-                lsp_completion.filter_text.as_deref(),\n-            )\n+            CodeLabel::fallback_for_completion(&completion_item, language.as_deref())\n         });\n         ensure_uniform_list_compatible_label(&mut label);\n \n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8878,7 +8878,7 @@\n /// Completion items are displayed in a `UniformList`.\n /// Usually, those items are single-line strings, but in LSP responses,\n /// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n-/// Many language plugins construct these items by joining these parts together, and we may fall back to `CodeLabel::plain` that uses `label`.\n+/// Many language plugins construct these items by joining these parts together, and we may fall back to `CodeLabel::fallback_for_completion` that uses `label`.\n /// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n /// breaking the completions menu presentation.\n ///\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8878,7 +8878,7 @@\n /// Completion items are displayed in a `UniformList`.\n /// Usually, those items are single-line strings, but in LSP responses,\n /// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n-/// Many language plugins construct these items by joining these parts together, and we may fall back to `CodeLabel::fallback_for_completion` that uses `label`.\n+/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label`.\n /// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n /// breaking the completions menu presentation.\n ///\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8878,7 +8878,7 @@\n /// Completion items are displayed in a `UniformList`.\n /// Usually, those items are single-line strings, but in LSP responses,\n /// completion items `label`, `detail` and `label_details.description` may contain newlines or long spaces.\n-/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label`.\n+/// Many language plugins construct these items by joining these parts together, and we may use `CodeLabel::fallback_for_completion` that uses `label` at least.\n /// All that may lead to a newline being inserted into resulting `CodeLabel.text`, which will force `UniformList` to bloat each entry to occupy more space,\n /// breaking the completions menu presentation.\n ///\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -8077,7 +8077,7 @@\n         };\n \n         let mut label = label.unwrap_or_else(|| {\n-            CodeLabel::fallback_for_completion(&completion_item, language.as_deref())\n+            CodeLabel::fallback_for_completion(&lsp_completion, language.as_deref())\n         });\n         ensure_uniform_list_compatible_label(&mut label);\n \n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -4392,7 +4392,7 @@\n         .pop()\n         .flatten()\n         .unwrap_or_else(|| {\n-            CodeLabel::fallback_for_completion(&completion_item, language.as_deref())\n+            CodeLabel::fallback_for_completion(&completion_item, language.map(|language| language.as_))\n         });\n         ensure_uniform_list_compatible_label(&mut new_label);\n \n\n```\n\n### Input:\n```crates/language/src/language.rs\n                    &mut move |offset, _| {\n<|editable_region_start|>\n                        chunks.seek(offset);\n                        chunks.next().unwrap_or(\"\").as_bytes()\n                    },\n                    old_tree.as_ref(),\n                )\n                .unwrap()\n        })\n    }\n\n    pub fn highlight_map(&self) -> HighlightMap {\n        self.highlight_map.lock().clone()\n    }\n\n    pub fn highlight_id_for_name(&self, name: &str) -> Option<HighlightId> {\n        let capture_id = self\n            .highlights_query\n            .as_ref()?\n            .capture_index_for_name(name)?;\n        Some(self.highlight_map.lock().get(capture_id))\n    }\n}\n\nimpl CodeLabel {\n    pub fn fallback_for_completion(\n        item: &lsp::CompletionItem,\n        language: Option<&Language>,\n    ) -> Self {\n        let highlight_id = item.kind.and_then(|kind| {\n            let grammar = language?.grammar()?;\n            use lsp::CompletionItemKind as Kind;\n            match kind {\n                Kind::CLASS => grammar.highlight_id_for_name(\"type\"),\n                Kind::CONSTANT => grammar.highlight_id_for_name(\"constant\"),\n                Kind::CONSTRUCTOR => grammar.highlight_id_for_name(\"constructor\"),\n                Kind::ENUM => grammar\n                    .highlight_id_for_name(\"enum\")\n                    .or_else(|| grammar.highlight_id_for_name(\"type\")),\n                Kind::FIELD => grammar.highlight_id_for_name(\"property\"),\n                Kind::FUNCTION => grammar.highlight_id_for_name(\"function\"),\n                Kind::INTERFACE => grammar.highlight_id_for_name(\"type\"),\n                Kind::METHOD => grammar\n                    .highlight_id_for_name(\"function.method\")\n                    .or_else(|| grammar.highlight_id_for_name(\"function\")),\n                Kind::OPERATOR => grammar.highlight_id_for_name(\"operator\"),\n                Kind::PROPERTY => grammar.highlight_id_for_name(\"property\"),\n                Kind::STRUCT => grammar.highlight_id_for_name(\"type\"),\n                Kind::VARIABLE => grammar.highlight_id_for_name(\"variable\"),\n                Kind::KEYWORD => grammar.highlight_id_for_name(\"keyword\"),\n                _ => None,\n            }\n        });\n\n        let label = &item.label;\n        let label_length = label.len();\n        let runs = highlight_id\n            .map(|highlight_id| vec![(0..label_length, highlight_id)])\n            .unwrap_or_default();\n        let text = if let Some(detail) = &item.detail {\n            format!(\"{label} {detail}\")\n        } else <|user_cursor_is_here|>\n            format!(\"{label} {description}\")\n        // TODO kb use detail first?\n        } else  else {\n            label.clone()\n        };\n        Self {\n            text,\n            runs,\n            filter_range: 0..label_length,\n        }\n    }\n\n    pub fn plain(text: String, filter_text: Option<&str>) -> Self {\n        let mut result = Self {\n            runs: Vec::new(),\n            filter_range: 0..text.len(),\n            text,\n        };\n        if let Some(filter_text) = filter_text {\n            if let Some(ix) = result.text.find(filter_text) {\n                result.filter_range = ix..ix + filter_text.len();\n            }\n        }\n        result\n    }\n\n    pub fn push_str(&mut self, text: &str, highlight: Option<HighlightId>) {\n        let start_ix = self.text.len();\n        self.text.push_str(text);\n        let end_ix = self.text.len();\n        if let Some(highlight) = highlight {\n            self.runs.push((start_ix..end_ix, highlight));\n        }\n    }\n\n    pub fn text(&self) -> &str {\n        self.text.as_str()\n    }\n\n    pub fn filter_text(&self) -> &str {\n        &self.text[self.filter_range.clone()]\n    }\n}\n\nimpl From<String> for CodeLabel {\n    fn from(value: String) -> Self {\n        Self::plain(value, None)\n    }\n}\n\nimpl From<&str> for CodeLabel {\n    fn from(value: &str) -> Self {\n        Self::plain(value.to_string(), None)\n    }\n}\n\nimpl Ord for LanguageMatcher {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.path_suffixes.cmp(&other.path_suffixes).then_with(|| {\n<|editable_region_end|>\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/language/src/language.rs\n                    &mut move |offset, _| {\n<|editable_region_start|>\n                        chunks.seek(offset);\n                        chunks.next().unwrap_or(\"\").as_bytes()\n                    },\n                    old_tree.as_ref(),\n                )\n                .unwrap()\n        })\n    }\n\n    pub fn highlight_map(&self) -> HighlightMap {\n        self.highlight_map.lock().clone()\n    }\n\n    pub fn highlight_id_for_name(&self, name: &str) -> Option<HighlightId> {\n        let capture_id = self\n            .highlights_query\n            .as_ref()?\n            .capture_index_for_name(name)?;\n        Some(self.highlight_map.lock().get(capture_id))\n    }\n}\n\nimpl CodeLabel {\n    pub fn fallback_for_completion(\n        item: &lsp::CompletionItem,\n        language: Option<&Language>,\n    ) -> Self {\n        let highlight_id = item.kind.and_then(|kind| {\n            let grammar = language?.grammar()?;\n            use lsp::CompletionItemKind as Kind;\n            match kind {\n                Kind::CLASS => grammar.highlight_id_for_name(\"type\"),\n                Kind::CONSTANT => grammar.highlight_id_for_name(\"constant\"),\n                Kind::CONSTRUCTOR => grammar.highlight_id_for_name(\"constructor\"),\n                Kind::ENUM => grammar\n                    .highlight_id_for_name(\"enum\")\n                    .or_else(|| grammar.highlight_id_for_name(\"type\")),\n                Kind::FIELD => grammar.highlight_id_for_name(\"property\"),\n                Kind::FUNCTION => grammar.highlight_id_for_name(\"function\"),\n                Kind::INTERFACE => grammar.highlight_id_for_name(\"type\"),\n                Kind::METHOD => grammar\n                    .highlight_id_for_name(\"function.method\")\n                    .or_else(|| grammar.highlight_id_for_name(\"function\")),\n                Kind::OPERATOR => grammar.highlight_id_for_name(\"operator\"),\n                Kind::PROPERTY => grammar.highlight_id_for_name(\"property\"),\n                Kind::STRUCT => grammar.highlight_id_for_name(\"type\"),\n                Kind::VARIABLE => grammar.highlight_id_for_name(\"variable\"),\n                Kind::KEYWORD => grammar.highlight_id_for_name(\"keyword\"),\n                _ => None,\n            }\n        });\n\n        let label = &item.label;\n        let label_length = label.len();\n        let runs = highlight_id\n            .map(|highlight_id| vec![(0..label_length, highlight_id)])\n            .unwrap_or_default();\n        let text = if let Some(detail) = &item.detail {\n            format!(\"{label} {detail}\")\n        } else <|user_cursor_is_here|>\n            format!(\"{label} {description}\")\n        // TODO kb use detail first?\n        } else  else {\n            label.clone()\n        };\n        Self {\n            text,\n            runs,\n            filter_range: 0..label_length,\n        }\n    }\n\n    pub fn plain(text: String, filter_text: Option<&str>) -> Self {\n        let mut result = Self {\n            runs: Vec::new(),\n            filter_range: 0..text.len(),\n            text,\n        };\n        if let Some(filter_text) = filter_text {\n            if let Some(ix) = result.text.find(filter_text) {\n                result.filter_range = ix..ix + filter_text.len();\n            }\n        }\n        result\n    }\n\n    pub fn push_str(&mut self, text: &str, highlight: Option<HighlightId>) {\n        let start_ix = self.text.len();\n        self.text.push_str(text);\n        let end_ix = self.text.len();\n        if let Some(highlight) = highlight {\n            self.runs.push((start_ix..end_ix, highlight));\n        }\n    }\n\n    pub fn text(&self) -> &str {\n        self.text.as_str()\n    }\n\n    pub fn filter_text(&self) -> &str {\n        &self.text[self.filter_range.clone()]\n    }\n}\n\nimpl From<String> for CodeLabel {\n    fn from(value: String) -> Self {\n        Self::plain(value, None)\n    }\n}\n\nimpl From<&str> for CodeLabel {\n    fn from(value: &str) -> Self {\n        Self::plain(value.to_string(), None)\n    }\n}\n\nimpl Ord for LanguageMatcher {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.path_suffixes.cmp(&other.path_suffixes).then_with(|| {\n<|editable_region_end|>\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n```"
  },
  "max_tokens": 1024
}