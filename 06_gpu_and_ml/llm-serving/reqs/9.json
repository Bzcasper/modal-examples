{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1791,9 +1791,7 @@\n         {\n             format!(\"{label} {description}\")\n         // TODO kb use detail first?\n-        } else if let Some(detail) = &item.detail {\n-            format!(\"{label} {detail}\")\n-        } else {\n+        } else  else {\n             label.clone()\n         };\n         Self {\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1784,7 +1784,9 @@\n         let runs = highlight_id\n             .map(|highlight_id| vec![(0..label_length, highlight_id)])\n             .unwrap_or_default();\n-        let text = if let Some(description) = item\n+        let text = if let Some(detail) = &item.detail {\n+            format!(\"{label} {detail}\")\n+        }if let Some(description) = item\n             .label_details\n             .as_ref()\n             .and_then(|label_details| label_details.description.as_ref())\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1786,11 +1786,7 @@\n             .unwrap_or_default();\n         let text = if let Some(detail) = &item.detail {\n             format!(\"{label} {detail}\")\n-        }if let Some(description) = item\n-            .label_details\n-            .as_ref()\n-            .and_then(|label_details| label_details.description.as_ref())\n-        {\n+        }\n             format!(\"{label} {description}\")\n         // TODO kb use detail first?\n         } else  else {\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1786,7 +1786,11 @@\n             .unwrap_or_default();\n         let text = if let Some(detail) = &item.detail {\n             format!(\"{label} {detail}\")\n-        }\n+        } else if let Some(description) = item\n+            .label_details\n+            .as_ref()\n+            .and_then(|label_details| label_details.description.as_ref())\n+        {\n             format!(\"{label} {description}\")\n         // TODO kb use detail first?\n         } else  else {\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1792,8 +1792,7 @@\n             .and_then(|label_details| label_details.description.as_ref())\n         {\n             format!(\"{label} {description}\")\n-        // TODO kb use detail first?\n-        } else  else {\n+        } else  {\n             label.clone()\n         };\n         Self {\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1792,7 +1792,7 @@\n             .and_then(|label_details| label_details.description.as_ref())\n         {\n             format!(\"{label} {description}\")\n-        } else  {\n+        } else \n             label.clone()\n         };\n         Self {\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1792,7 +1792,7 @@\n             .and_then(|label_details| label_details.description.as_ref())\n         {\n             format!(\"{label} {description}\")\n-        } else \n+        } else  {\n             label.clone()\n         };\n         Self {\n\n```\n\n### Input:\n```crates/language/src/language.rs\n        })\n<|editable_region_start|>\n    }\n\n    pub fn highlight_map(&self) -> HighlightMap {\n        self.highlight_map.lock().clone()\n    }\n\n    pub fn highlight_id_for_name(&self, name: &str) -> Option<HighlightId> {\n        let capture_id = self\n            .highlights_query\n            .as_ref()?\n            .capture_index_for_name(name)?;\n        Some(self.highlight_map.lock().get(capture_id))\n    }\n}\n\nimpl CodeLabel {\n    pub fn fallback_for_completion(\n        item: &lsp::CompletionItem,\n        language: Option<&Language>,\n    ) -> Self {\n        let highlight_id = item.kind.and_then(|kind| {\n            let grammar = language?.grammar()?;\n            use lsp::CompletionItemKind as Kind;\n            match kind {\n                Kind::CLASS => grammar.highlight_id_for_name(\"type\"),\n                Kind::CONSTANT => grammar.highlight_id_for_name(\"constant\"),\n                Kind::CONSTRUCTOR => grammar.highlight_id_for_name(\"constructor\"),\n                Kind::ENUM => grammar\n                    .highlight_id_for_name(\"enum\")\n                    .or_else(|| grammar.highlight_id_for_name(\"type\")),\n                Kind::FIELD => grammar.highlight_id_for_name(\"property\"),\n                Kind::FUNCTION => grammar.highlight_id_for_name(\"function\"),\n                Kind::INTERFACE => grammar.highlight_id_for_name(\"type\"),\n                Kind::METHOD => grammar\n                    .highlight_id_for_name(\"function.method\")\n                    .or_else(|| grammar.highlight_id_for_name(\"function\")),\n                Kind::OPERATOR => grammar.highlight_id_for_name(\"operator\"),\n                Kind::PROPERTY => grammar.highlight_id_for_name(\"property\"),\n                Kind::STRUCT => grammar.highlight_id_for_name(\"type\"),\n                Kind::VARIABLE => grammar.highlight_id_for_name(\"variable\"),\n                Kind::KEYWORD => grammar.highlight_id_for_name(\"keyword\"),\n                _ => None,\n            }\n        });\n\n        let label = &item.label;\n        let label_length = label.len();\n        let runs = highlight_id\n            .map(|highlight_id| vec![(0..label_length, highlight_id)])\n            .unwrap_or_default();\n        let text = if let Some(detail) = &item.detail {\n            format!(\"{label} {detail}\")\n        } else if let Some(description) = item\n            .label_details\n            .as_ref()\n            .and_then(|label_details| label_details.description.as_ref())\n        {\n            format!(\"{label} {description}\")\n        } else  <|user_cursor_is_here|>{\n            label.clone()\n        };\n        Self {\n            text,\n            runs,\n            filter_range: 0..label_length,\n        }\n    }\n\n    pub fn plain(text: String, filter_text: Option<&str>) -> Self {\n        let mut result = Self {\n            runs: Vec::new(),\n            filter_range: 0..text.len(),\n            text,\n        };\n        if let Some(filter_text) = filter_text {\n            if let Some(ix) = result.text.find(filter_text) {\n                result.filter_range = ix..ix + filter_text.len();\n            }\n        }\n        result\n    }\n\n    pub fn push_str(&mut self, text: &str, highlight: Option<HighlightId>) {\n        let start_ix = self.text.len();\n        self.text.push_str(text);\n        let end_ix = self.text.len();\n        if let Some(highlight) = highlight {\n            self.runs.push((start_ix..end_ix, highlight));\n        }\n    }\n\n    pub fn text(&self) -> &str {\n        self.text.as_str()\n    }\n\n    pub fn filter_text(&self) -> &str {\n        &self.text[self.filter_range.clone()]\n    }\n}\n\nimpl From<String> for CodeLabel {\n    fn from(value: String) -> Self {\n        Self::plain(value, None)\n    }\n}\n\nimpl From<&str> for CodeLabel {\n    fn from(value: &str) -> Self {\n        Self::plain(value.to_string(), None)\n    }\n}\n\nimpl Ord for LanguageMatcher {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.path_suffixes.cmp(&other.path_suffixes).then_with(|| {\n            self.first_line_pattern\n                .as_ref()\n                .map(Regex::as_str)\n<|editable_region_end|>\n                .as_ref()\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/language/src/language.rs\n        })\n<|editable_region_start|>\n    }\n\n    pub fn highlight_map(&self) -> HighlightMap {\n        self.highlight_map.lock().clone()\n    }\n\n    pub fn highlight_id_for_name(&self, name: &str) -> Option<HighlightId> {\n        let capture_id = self\n            .highlights_query\n            .as_ref()?\n            .capture_index_for_name(name)?;\n        Some(self.highlight_map.lock().get(capture_id))\n    }\n}\n\nimpl CodeLabel {\n    pub fn fallback_for_completion(\n        item: &lsp::CompletionItem,\n        language: Option<&Language>,\n    ) -> Self {\n        let highlight_id = item.kind.and_then(|kind| {\n            let grammar = language?.grammar()?;\n            use lsp::CompletionItemKind as Kind;\n            match kind {\n                Kind::CLASS => grammar.highlight_id_for_name(\"type\"),\n                Kind::CONSTANT => grammar.highlight_id_for_name(\"constant\"),\n                Kind::CONSTRUCTOR => grammar.highlight_id_for_name(\"constructor\"),\n                Kind::ENUM => grammar\n                    .highlight_id_for_name(\"enum\")\n                    .or_else(|| grammar.highlight_id_for_name(\"type\")),\n                Kind::FIELD => grammar.highlight_id_for_name(\"property\"),\n                Kind::FUNCTION => grammar.highlight_id_for_name(\"function\"),\n                Kind::INTERFACE => grammar.highlight_id_for_name(\"type\"),\n                Kind::METHOD => grammar\n                    .highlight_id_for_name(\"function.method\")\n                    .or_else(|| grammar.highlight_id_for_name(\"function\")),\n                Kind::OPERATOR => grammar.highlight_id_for_name(\"operator\"),\n                Kind::PROPERTY => grammar.highlight_id_for_name(\"property\"),\n                Kind::STRUCT => grammar.highlight_id_for_name(\"type\"),\n                Kind::VARIABLE => grammar.highlight_id_for_name(\"variable\"),\n                Kind::KEYWORD => grammar.highlight_id_for_name(\"keyword\"),\n                _ => None,\n            }\n        });\n\n        let label = &item.label;\n        let label_length = label.len();\n        let runs = highlight_id\n            .map(|highlight_id| vec![(0..label_length, highlight_id)])\n            .unwrap_or_default();\n        let text = if let Some(detail) = &item.detail {\n            format!(\"{label} {detail}\")\n        } else if let Some(description) = item\n            .label_details\n            .as_ref()\n            .and_then(|label_details| label_details.description.as_ref())\n        {\n            format!(\"{label} {description}\")\n        } else  <|user_cursor_is_here|>{\n            label.clone()\n        };\n        Self {\n            text,\n            runs,\n            filter_range: 0..label_length,\n        }\n    }\n\n    pub fn plain(text: String, filter_text: Option<&str>) -> Self {\n        let mut result = Self {\n            runs: Vec::new(),\n            filter_range: 0..text.len(),\n            text,\n        };\n        if let Some(filter_text) = filter_text {\n            if let Some(ix) = result.text.find(filter_text) {\n                result.filter_range = ix..ix + filter_text.len();\n            }\n        }\n        result\n    }\n\n    pub fn push_str(&mut self, text: &str, highlight: Option<HighlightId>) {\n        let start_ix = self.text.len();\n        self.text.push_str(text);\n        let end_ix = self.text.len();\n        if let Some(highlight) = highlight {\n            self.runs.push((start_ix..end_ix, highlight));\n        }\n    }\n\n    pub fn text(&self) -> &str {\n        self.text.as_str()\n    }\n\n    pub fn filter_text(&self) -> &str {\n        &self.text[self.filter_range.clone()]\n    }\n}\n\nimpl From<String> for CodeLabel {\n    fn from(value: String) -> Self {\n        Self::plain(value, None)\n    }\n}\n\nimpl From<&str> for CodeLabel {\n    fn from(value: &str) -> Self {\n        Self::plain(value.to_string(), None)\n    }\n}\n\nimpl Ord for LanguageMatcher {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.path_suffixes.cmp(&other.path_suffixes).then_with(|| {\n            self.first_line_pattern\n                .as_ref()\n                .map(Regex::as_str)\n<|editable_region_end|>\n                .as_ref()\n```"
  },
  "max_tokens": 1024
}