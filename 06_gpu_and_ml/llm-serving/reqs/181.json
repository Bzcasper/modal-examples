{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -202,7 +202,7 @@\n                 code,\n                 spans,\n                 filter_range: Range {\n-                    0,\n+                    start,\n                     end: start + completion_len as u32,\n                 },\n             });\n\n```\n\n\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -216,7 +216,7 @@\n                         )],\n                         code: completion.label,\n                         filter_range: Range {\n-                            start,\n+                            start: 0,\n                             end: completion_len as u32,\n                         },\n                     })\n\n```\n\n\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -200,7 +200,6 @@\n             });\n         }\n         if let Some(kind) = completion.kind {\n-            dbg!(&completion);\n             match kind {\n                 CompletionKind::Keyword => {\n                     return Some(zed_extension_api::CodeLabel {\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -194,7 +194,7 @@\n                 code,\n                 spans,\n                 filter_range: Range {\n-                    0,\n+                    start: 0,\n                     end: completion_len as u32,\n                 },\n             });\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -194,7 +194,7 @@\n                 code,\n                 spans,\n                 filter_range: Range {\n-                    start: 0,\n+                    start,\n                     end: completion_len as u32,\n                 },\n             });\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -178,7 +178,10 @@\n         completion: Completion,\n     ) -> Option<zed_extension_api::CodeLabel> {\n         let completion_len = completion.label.len();\n-        fn format_function(completion: &Completion, add_fn_prefix: bool) -> Option<zed_extension_api::CodeLabel> {\n+        fn format_function(\n+            completion: &Completion)\n+            -> Option<zed_exten,\n+        sion_api::CodeLabel> {\n             let completion_len = completion.label.len();\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -178,11 +178,7 @@\n         completion: Completion,\n     ) -> Option<zed_extension_api::CodeLabel> {\n         let completion_len = completion.label.len();\n-        fn format_function(\n-            completion: &Completion)\n-            -> Option<zed_exten,\n-        sion_api::CodeLabel> {\n-            let completion_len = completion.label.len();\n+        fn format_function(completion: &Completion) -> Option<zed_extens     let completion_len = completion.label.len();\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -178,7 +178,8 @@\n         completion: Completion,\n     ) -> Option<zed_extension_api::CodeLabel> {\n         let completion_len = completion.label.len();\n-        fn format_function(completion: &Completion) -> Option<zed_extens     let completion_len = completion.label.len();\n+        fn format_function(completion: &Completion) -> Option<zed_extens\n+            let completion_len = completion.label.len();\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n\n```\n\n### Input:\n```extensions/zig/src/zig.rs\n            for entry in entries {\n<|editable_region_start|>\n                let entry = entry.map_err(|e| format!(\"failed to load directory entry {e}\"))?;\n                if entry.file_name().to_str() != Some(&version_dir) {\n                    fs::remove_dir_all(entry.path()).ok();\n                }\n            }\n        }\n\n        self.cached_binary_path = Some(binary_path.clone());\n        Ok(ZlsBinary {\n            path: binary_path,\n            args,\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion) -> Option<zed_extenstion_a<|user_cursor_is_here|>\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n            let start = \"fn \".len() as u32;\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n                (vec![CodeLabelSpan::literal(code.clone(), None)], code_label)\n            };\n\n            return Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    start,\n                    end: completion_len as u32,\n                },\n            });\n        }\n        if let Some(kind) = completion.kind {\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Struct => {\n                    if completion\n                        .detail\n                        .as_ref()\n                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                    {\n                        if let Some(label) = format_function(&completion) {\n                            return Some(label);\n                        }\n                    }\n                }\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n<|editable_region_end|>\n        Some(zed_extension_api::CodeLabel {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```extensions/zig/src/zig.rs\n            for entry in entries {\n<|editable_region_start|>\n                let entry = entry.map_err(|e| format!(\"failed to load directory entry {e}\"))?;\n                if entry.file_name().to_str() != Some(&version_dir) {\n                    fs::remove_dir_all(entry.path()).ok();\n                }\n            }\n        }\n\n        self.cached_binary_path = Some(binary_path.clone());\n        Ok(ZlsBinary {\n            path: binary_path,\n            args,\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion) -> Option<zed_extenstion_a<|user_cursor_is_here|>\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n            let start = \"fn \".len() as u32;\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n                (vec![CodeLabelSpan::literal(code.clone(), None)], code_label)\n            };\n\n            return Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    start,\n                    end: completion_len as u32,\n                },\n            });\n        }\n        if let Some(kind) = completion.kind {\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Struct => {\n                    if completion\n                        .detail\n                        .as_ref()\n                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                    {\n                        if let Some(label) = format_function(&completion) {\n                            return Some(label);\n                        }\n                    }\n                }\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n<|editable_region_end|>\n        Some(zed_extension_api::CodeLabel {\n```"
  },
  "max_tokens": 1024
}