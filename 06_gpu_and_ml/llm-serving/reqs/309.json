{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,6 +1,5 @@\n Use more LSP data when falling back to regular completions label\n \n-\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,3 +1,4 @@\n+Cargo fmt\n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1784,7 +1784,7 @@\n         let runs = highlight_id\n             .map(|highlight_id| vec![(0..label_length, highlight_id)])\n             .unwrap_or_default();\n-        let text = if let Some(detail) = dbg!(&item.detail) {\n+        let text = if let Some(detail) = &item.detail {\n             format!(\"{label} {detail}\")\n         } else if let Some(description) = item\n             .label_details\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1791,7 +1791,6 @@\n             .as_ref()\n             .and_then(|label_details| label_details.description.as_ref())\n         {\n-            dbg!(description);\n             format!(\"{label} {description}\")\n         } else {\n             label.clone()\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-Cargo fmt\n+Style fixes\n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11387,7 +11387,7 @@\n                         .iter()\n                         .map(|completion| &completion.label.text)\n                         .collect::<Vec<_>>(),\n-                    vec![\"method id()\", \"other\"],\n+                    vec![\"id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n                 );\n             }\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11387,7 +11387,7 @@\n                         .iter()\n                         .map(|completion| &completion.label.text)\n                         .collect::<Vec<_>>(),\n-                    vec![\"id()\", \"other\"],\n+                    vec![\"id\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n                 );\n             }\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11387,7 +11387,7 @@\n                         .iter()\n                         .map(|completion| &completion.label.text)\n                         .collect::<Vec<_>>(),\n-                    vec![\"id\", \"other\"],\n+                    vec![\"method id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n                 );\n             }\n\n```\n\n\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1795,6 +1795,7 @@\n         } else {\n             label.clone()\n         };\n+        dbg!((&label, &text));\n         Self {\n             text,\n             runs,\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -4397,6 +4397,7 @@\n                 language.map(|language| language.as_ref()),\n             )\n         });\n+        db\n         ensure_uniform_list_compatible_label(&mut new_label);\n \n         let mut completions = completions.borrow_mut();\n\n```\n\n### Input:\n```crates/project/src/lsp_store.rs\n        let completion = &mut completions[completion_index];\n<|editable_region_start|>\n        completion.lsp_completion = completion_item;\n        completion.resolved = true;\n        Ok(())\n    }\n\n    async fn regenerate_completion_labels(\n        adapter: Arc<CachedLspAdapter>,\n        snapshot: &BufferSnapshot,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let completion_item = completions.borrow()[completion_index]\n            .lsp_completion\n            .clone();\n        if let Some(lsp_documentation) = completion_item.documentation.as_ref() {\n            let documentation = language::prepare_completion_documentation(\n                lsp_documentation,\n                &language_registry,\n                snapshot.language().cloned(),\n            )\n            .await;\n\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(documentation);\n        } else {\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(Documentation::Undocumented);\n        }\n\n        // NB: Zed does not have `details` inside the completion resolve capabilities, but certain language servers violate the spec and do not return `details` immediately, e.g. https://github.com/yioneko/vtsls/issues/213\n        // So we have to update the label here anyway...\n        let language = snapshot.language();\n        let mut new_label = match language {\n            Some(language) => {\n                adapter\n                    .labels_for_completions(&[completion_item.clone()], language)\n                    .await?\n            }\n            None => Vec::new(),\n        }\n        .pop()\n        .flatten()\n        .unwrap_or_else(|| {\n            CodeLabel::fallback_for_completion(\n                &completion_item,\n                language.map(|language| language.as_ref()),\n            )\n        });\n        db<|user_cursor_is_here|>\n        ensure_uniform_list_compatible_label(&mut new_label);\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        if completion.label.filter_text() == new_label.filter_text() {\n            completion.label = new_label;\n        } else {\n            log::error!(\n                \"Resolved completion changed display label from {} to {}. \\\n                 Refusing to apply this because it changes the fuzzy match text from {} to {}\",\n                completion.label.text(),\n                new_label.text(),\n                completion.label.filter_text(),\n                new_label.filter_text()\n            );\n        }\n\n        Ok(())\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    async fn resolve_completion_remote(\n        project_id: u64,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        client: AnyProtoClient,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let lsp_completion = {\n            let completion = &completions.borrow()[completion_index];\n            if completion.resolved {\n                return Ok(());\n            }\n            serde_json::to_string(&completion.lsp_completion)\n                .unwrap()\n                .into_bytes()\n        };\n        let request = proto::ResolveCompletionDocumentation {\n            project_id,\n            language_server_id: server_id.0 as u64,\n            lsp_completion,\n            buffer_id: buffer_id.into(),\n        };\n\n        let response = client\n            .request(request)\n            .await\n            .context(\"completion documentation resolve proto request\")?;\n        let lsp_completion = serde_json::from_slice(&response.lsp_completion)?;\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/lsp_store.rs\n        let completion = &mut completions[completion_index];\n<|editable_region_start|>\n        completion.lsp_completion = completion_item;\n        completion.resolved = true;\n        Ok(())\n    }\n\n    async fn regenerate_completion_labels(\n        adapter: Arc<CachedLspAdapter>,\n        snapshot: &BufferSnapshot,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let completion_item = completions.borrow()[completion_index]\n            .lsp_completion\n            .clone();\n        if let Some(lsp_documentation) = completion_item.documentation.as_ref() {\n            let documentation = language::prepare_completion_documentation(\n                lsp_documentation,\n                &language_registry,\n                snapshot.language().cloned(),\n            )\n            .await;\n\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(documentation);\n        } else {\n            let mut completions = completions.borrow_mut();\n            let completion = &mut completions[completion_index];\n            completion.documentation = Some(Documentation::Undocumented);\n        }\n\n        // NB: Zed does not have `details` inside the completion resolve capabilities, but certain language servers violate the spec and do not return `details` immediately, e.g. https://github.com/yioneko/vtsls/issues/213\n        // So we have to update the label here anyway...\n        let language = snapshot.language();\n        let mut new_label = match language {\n            Some(language) => {\n                adapter\n                    .labels_for_completions(&[completion_item.clone()], language)\n                    .await?\n            }\n            None => Vec::new(),\n        }\n        .pop()\n        .flatten()\n        .unwrap_or_else(|| {\n            CodeLabel::fallback_for_completion(\n                &completion_item,\n                language.map(|language| language.as_ref()),\n            )\n        });\n        db<|user_cursor_is_here|>\n        ensure_uniform_list_compatible_label(&mut new_label);\n\n        let mut completions = completions.borrow_mut();\n        let completion = &mut completions[completion_index];\n        if completion.label.filter_text() == new_label.filter_text() {\n            completion.label = new_label;\n        } else {\n            log::error!(\n                \"Resolved completion changed display label from {} to {}. \\\n                 Refusing to apply this because it changes the fuzzy match text from {} to {}\",\n                completion.label.text(),\n                new_label.text(),\n                completion.label.filter_text(),\n                new_label.filter_text()\n            );\n        }\n\n        Ok(())\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    async fn resolve_completion_remote(\n        project_id: u64,\n        server_id: LanguageServerId,\n        buffer_id: BufferId,\n        completions: Rc<RefCell<Box<[Completion]>>>,\n        completion_index: usize,\n        client: AnyProtoClient,\n        language_registry: Arc<LanguageRegistry>,\n    ) -> Result<()> {\n        let lsp_completion = {\n            let completion = &completions.borrow()[completion_index];\n            if completion.resolved {\n                return Ok(());\n            }\n            serde_json::to_string(&completion.lsp_completion)\n                .unwrap()\n                .into_bytes()\n        };\n        let request = proto::ResolveCompletionDocumentation {\n            project_id,\n            language_server_id: server_id.0 as u64,\n            lsp_completion,\n            buffer_id: buffer_id.into(),\n        };\n\n        let response = client\n            .request(request)\n            .await\n            .context(\"completion documentation resolve proto request\")?;\n        let lsp_completion = serde_json::from_slice(&response.lsp_completion)?;\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}