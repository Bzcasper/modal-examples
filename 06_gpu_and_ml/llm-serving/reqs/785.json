{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1947,6 +1947,7 @@\n                                 unreachable!(\"Language server ID should be available, as it's registered on demand\")\n                             }\n                         }\n+                         }\n                     },\n                 )?;\n                 let server_state = self.language_servers.get(&server_id)?;\n\n```\n\n\n\n\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1845,6 +1845,7 @@\n         }\n \n         let abs_path = file.abs_path(cx);\n+        dbg!(&abs_path);\n         let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n             return;\n         };\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1855,6 +1855,7 @@\n         let Some(language) = buffer.language().cloned() else {\n             return;\n         };\n+        dbg!(\":)\");\n         let path: Arc<Path> = file\n             .path()\n             .parent()\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1868,6 +1868,7 @@\n         else {\n             return;\n         };\n+        dbg!(&language.name())\n         let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n         let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n             this.get(\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1868,7 +1868,7 @@\n         else {\n             return;\n         };\n-        dbg!(&language.name())\n+        dbg!(&language.name());\n         let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n         let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n             this.get(\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1879,6 +1879,7 @@\n             )\n             .collect::<Vec<_>>()\n         });\n+        dbg!(servers.len());\n         let servers = servers\n             .into_iter()\n             .filter_map(|server_node| {\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -185,6 +185,7 @@\n                     .map(|adapter| (adapter, (LspSettings::default(), BTreeSet::new()))),\n             ),\n         };\n+        dbg!(&adapters.len());\n         self.get_with_adapters(path, adapters, delegate, cx)\n     }\n \n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -271,6 +271,7 @@\n         if !settings.enable_language_server {\n             return Default::default();\n         }\n+        dbg!(\"Ay\");\n         let available_lsp_adapters = self.languages.lsp_adapters(&language_name);\n         let available_language_servers = available_lsp_adapters\n             .iter()\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -277,7 +277,7 @@\n             .iter()\n             .map(|lsp_adapter| lsp_adapter.name.clone())\n             .collect::<Vec<_>>();\n-\n+        dbg!(\":)\");\n         let desired_language_servers =\n             settings.customized_language_servers(&available_language_servers);\n         let adapters_with_settings = desired_language_servers\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -271,13 +271,12 @@\n         if !settings.enable_language_server {\n             return Default::default();\n         }\n-        dbg!(\"Ay\");\n         let available_lsp_adapters = self.languages.lsp_adapters(&language_name);\n         let available_language_servers = available_lsp_adapters\n             .iter()\n             .map(|lsp_adapter| lsp_adapter.name.clone())\n             .collect::<Vec<_>>();\n-        dbg!(\":)\");\n+\n         let desired_language_servers =\n             settings.customized_language_servers(&available_language_servers);\n         let adapters_with_settings = desired_language_servers\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -222,6 +222,7 @@\n             });\n         }\n \n+        dbg!(&roots);\n         roots\n             .into_iter()\n             .filter_map(move |(adapter, root_path)| {\n\n```\n\n### Input:\n```src/apprt/embedded.zig\n        self.instant = now;\n<|editable_region_start|>\n    }\n};\n\n// C API\npub const CAPI = struct {\n    const global = &@import(\"../global.zig\").state;\n\n    /// This is the same as Surface.KeyEvent but this is the raw C API version.\n    const KeyEvent = extern struct {\n        action: input.Action,\n        mods: c_int,\n        keycode: u32,\n        text: ?[*:0]const u8,\n        composing: bool,\n\n        /// Convert to surface key event.\n        fn keyEvent(self: KeyEvent) App.KeyEvent {\n            return .{\n                .action = self.action,\n                .mods = @bitCast(@as(\n                    input.Mods.Backing,\n                    @truncate(@as(c_uint, @bitCast(self.mods))),\n                )),\n                .keycode = self.keycode,\n                .text = if (self.text) |ptr| std.mem.sliceTo(ptr, 0) else null,\n                .composing = self.composing,\n            };\n        }\n    };\n\n    const Selection = extern struct {\n        tl_x_px: f64,\n        tl_y_px: f64,\n        offset_start: u32,\n        offset_len: u32,\n    };\n\n    const SurfaceSize = extern struct {\n        columns: u16,\n        rows: u16,\n        width_px: u32,\n        height_px: u32,\n        cell_width_px: u32,\n        cell_height_px: u32,\n    };\n\n    // Reference the conditional exports based on target platform\n    // so they're included in the C API.\n    comptime {\n        if (builtin.target.isDarwin()) {\n            _ = Darwin;\n        }\n    }\n\n    /// Create a new app.\n    export fn ghostty_app_new(\n        opts: *const apprt.runtime.App.Options,\n        config: *const Config,\n    ) ?*App {\n        return app_new_(opts, config) catch |err| {\n            log.err(\"error initializing app err={}\", .{err});\n            return null;\n        };\n    }\n\n    fn app_new_(\n        opts: *const apprt.runtime.App.Options,\n        config: *const Config,\n    ) !*App {\n        std.<|user_cursor_is_here|>\n        var core_app = try CoreApp.create(global.alloc);\n        errdefer core_app.destroy();\n\n        // Create our runtime app\n        var app = try global.alloc.create(App);\n        errdefer global.alloc.destroy(app);\n        app.* = try App.init(core_app, config, opts.*);\n        errdefer app.terminate();\n\n        return app;\n    }\n\n    /// Tick the event loop. This should be called whenever the \"wakeup\"\n    /// callback is invoked for the runtime.\n    export fn ghostty_app_tick(v: *App) void {\n        v.core_app.tick(v) catch |err| {\n            log.err(\"error app tick err={}\", .{err});\n        };\n    }\n\n    /// Return the userdata associated with the app.\n    export fn ghostty_app_userdata(v: *App) ?*anyopaque {\n        return v.opts.userdata;\n    }\n\n    export fn ghostty_app_free(v: *App) void {\n        const core_app = v.core_app;\n        v.terminate();\n        global.alloc.destroy(v);\n        core_app.destroy();\n    }\n\n    /// Update the focused state of the app.\n    export fn ghostty_app_set_focus(\n        app: *App,\n        focused: bool,\n    ) void {\n        app.focusEvent(focused);\n    }\n\n    /// Notify the app of a global keypress capture. This will return\n    /// true if the key was captured by the app, in which case the caller\n    /// should not process the key.\n    export fn ghostty_app_key(\n        app: *App,\n        event: KeyEvent,\n    ) bool {\n        return app.keyEvent(.app, event.keyEvent()) catch |err| {\n            log.warn(\"error processing key event err={}\", .{err});\n            return false;\n        };\n    }\n\n    /// Returns true if the given key event would trigger a binding\n    /// if it were sent to the surface right now. The \"right now\"\n    /// is important because things like trigger sequences are only\n    /// valid until the next key event.\n    export fn ghostty_app_key_is_binding(\n        app: *App,\n        event: KeyEvent,\n    ) bool {\n        const core_event = app.coreKeyEvent(\n            .app,\n            event.keyEvent(),\n        ) catch |err| {\n            log.warn(\"error processing key event err={}\", .{err});\n            return false;\n        } orelse {\n            log.warn(\"error processing key event\", .{});\n<|editable_region_end|>\n        } orelse {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```src/apprt/embedded.zig\n        self.instant = now;\n<|editable_region_start|>\n    }\n};\n\n// C API\npub const CAPI = struct {\n    const global = &@import(\"../global.zig\").state;\n\n    /// This is the same as Surface.KeyEvent but this is the raw C API version.\n    const KeyEvent = extern struct {\n        action: input.Action,\n        mods: c_int,\n        keycode: u32,\n        text: ?[*:0]const u8,\n        composing: bool,\n\n        /// Convert to surface key event.\n        fn keyEvent(self: KeyEvent) App.KeyEvent {\n            return .{\n                .action = self.action,\n                .mods = @bitCast(@as(\n                    input.Mods.Backing,\n                    @truncate(@as(c_uint, @bitCast(self.mods))),\n                )),\n                .keycode = self.keycode,\n                .text = if (self.text) |ptr| std.mem.sliceTo(ptr, 0) else null,\n                .composing = self.composing,\n            };\n        }\n    };\n\n    const Selection = extern struct {\n        tl_x_px: f64,\n        tl_y_px: f64,\n        offset_start: u32,\n        offset_len: u32,\n    };\n\n    const SurfaceSize = extern struct {\n        columns: u16,\n        rows: u16,\n        width_px: u32,\n        height_px: u32,\n        cell_width_px: u32,\n        cell_height_px: u32,\n    };\n\n    // Reference the conditional exports based on target platform\n    // so they're included in the C API.\n    comptime {\n        if (builtin.target.isDarwin()) {\n            _ = Darwin;\n        }\n    }\n\n    /// Create a new app.\n    export fn ghostty_app_new(\n        opts: *const apprt.runtime.App.Options,\n        config: *const Config,\n    ) ?*App {\n        return app_new_(opts, config) catch |err| {\n            log.err(\"error initializing app err={}\", .{err});\n            return null;\n        };\n    }\n\n    fn app_new_(\n        opts: *const apprt.runtime.App.Options,\n        config: *const Config,\n    ) !*App {\n        std.<|user_cursor_is_here|>\n        var core_app = try CoreApp.create(global.alloc);\n        errdefer core_app.destroy();\n\n        // Create our runtime app\n        var app = try global.alloc.create(App);\n        errdefer global.alloc.destroy(app);\n        app.* = try App.init(core_app, config, opts.*);\n        errdefer app.terminate();\n\n        return app;\n    }\n\n    /// Tick the event loop. This should be called whenever the \"wakeup\"\n    /// callback is invoked for the runtime.\n    export fn ghostty_app_tick(v: *App) void {\n        v.core_app.tick(v) catch |err| {\n            log.err(\"error app tick err={}\", .{err});\n        };\n    }\n\n    /// Return the userdata associated with the app.\n    export fn ghostty_app_userdata(v: *App) ?*anyopaque {\n        return v.opts.userdata;\n    }\n\n    export fn ghostty_app_free(v: *App) void {\n        const core_app = v.core_app;\n        v.terminate();\n        global.alloc.destroy(v);\n        core_app.destroy();\n    }\n\n    /// Update the focused state of the app.\n    export fn ghostty_app_set_focus(\n        app: *App,\n        focused: bool,\n    ) void {\n        app.focusEvent(focused);\n    }\n\n    /// Notify the app of a global keypress capture. This will return\n    /// true if the key was captured by the app, in which case the caller\n    /// should not process the key.\n    export fn ghostty_app_key(\n        app: *App,\n        event: KeyEvent,\n    ) bool {\n        return app.keyEvent(.app, event.keyEvent()) catch |err| {\n            log.warn(\"error processing key event err={}\", .{err});\n            return false;\n        };\n    }\n\n    /// Returns true if the given key event would trigger a binding\n    /// if it were sent to the surface right now. The \"right now\"\n    /// is important because things like trigger sequences are only\n    /// valid until the next key event.\n    export fn ghostty_app_key_is_binding(\n        app: *App,\n        event: KeyEvent,\n    ) bool {\n        const core_event = app.coreKeyEvent(\n            .app,\n            event.keyEvent(),\n        ) catch |err| {\n            log.warn(\"error processing key event err={}\", .{err});\n            return false;\n        } orelse {\n            log.warn(\"error processing key event\", .{});\n<|editable_region_end|>\n        } orelse {\n```"
  },
  "max_tokens": 1024
}