{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -191,7 +191,7 @@\n                     code,\n                 )\n             };\n-CodeLabelSpan {\n+CodeLabe {\n                 spans,\n                 filter_range: Range {\n                     start,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -191,7 +191,7 @@\n                     code,\n                 )\n             };\n-CodeLabe {\n+CodeLabel {\n                 spans,\n                 filter_range: Range {\n                     start,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -191,7 +191,7 @@\n                     code,\n                 )\n             };\n-CodeLabel {\n+zed_extension_api::CodeLabel {\n                 spans,\n                 filter_range: Range {\n                     start,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -191,7 +191,7 @@\n                     code,\n                 )\n             };\n-zed_extension_api::CodeLabel {\n+            zed_extension_api::CodeLabel {\n                 spans,\n                 filter_range: Range {\n                     start,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -197,7 +197,7 @@\n                     start,\n                     end: completion_len as u32,\n                 },\n-            });\n+            })\n         }\n         if let Some(kind) = completion.kind {\n             match kind {\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -197,7 +197,7 @@\n                     start,\n                     end: completion_len as u32,\n                 },\n-            })\n+            }\n         }\n         if let Some(kind) = completion.kind {\n             match kind {\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -197,7 +197,7 @@\n                     start,\n                     end: completion_len as u32,\n                 },\n-            }\n+            })\n         }\n         if let Some(kind) = completion.kind {\n             match kind {\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -191,7 +191,7 @@\n                     code,\n                 )\n             };\n-            zed_extension_api::CodeLabel {\n+            Some(zed_extension_api::CodeLabel {\n                 spans,\n                 filter_range: Range {\n                     start,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -187,7 +187,10 @@\n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 (\n-                    vec![CodeLabelSpan::code_range(Range {start: 0, end: code.len()})],\n+                    vec![CodeLabelSpan::code_range(Range {\n+                        start: 0,\n+                        end: code.len(),\n+                    .try_into().expect(\"Label to not overflow u32\")})],\n                     code,\n                 )\n             };\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -189,7 +189,7 @@\n                 (\n                     vec![CodeLabelSpan::code_range(Range {\n                         start: 0,\n-                        end: code.len(),\n+                        end: code.len()\n                     .try_into().expect(\"Label to not overflow u32\")})],\n                     code,\n                 )\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -189,12 +189,13 @@\n                 (\n                     vec![CodeLabelSpan::code_range(Range {\n                         start: 0,\n-                        end: code.len()\n-                    .try_into().expect(\"Label to not overflow u32\")})],\n+                        end: code.len().try_into().expect(\"Label to not overflow u32\"),\n+                    })],\n                     code,\n                 )\n             };\n             Some(zed_extension_api::CodeLabel {\n+                code,\n                 spans,\n                 filter_range: Range {\n                     start,\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -234,6 +234,7 @@\n                         }\n                     }\n                 }\n+                Completio\n \n                 _ => {}\n             }\n\n```\n\n### Input:\n```extensions/zig/src/zig.rs\n            path: binary_path,\n<|editable_region_start|>\n            args,\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion) -> Option<zed_extension_api::CodeLabel> {\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n            let start = \"fn \".len() as u32;\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                (\n                    vec![CodeLabelSpan::code_range(Range {\n                        start: 0,\n                        end: code.len().try_into().expect(\"Label to not overflow u32\"),\n                    })],\n                    code,\n                )\n            };\n            Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    start,\n                    end: completion_len as u32,\n                },\n            })\n        }\n        if let Some(kind) = completion.kind {\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Struct => {\n                    if completion\n                        .detail\n                        .as_ref()\n                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                    {\n                        if let Some(label) = format_function(&completion) {\n                            return Some(label);\n                        }\n                    }\n                }\n                Completio<|user_cursor_is_here|>\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n            spans: vec![],\n            filter_range: Range {\n                start: 0,\n                end: completion_len as u32,\n            },\n        })\n    }\n}\n\nzed::register_extension!(ZigExtension);\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```extensions/zig/src/zig.rs\n            path: binary_path,\n<|editable_region_start|>\n            args,\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion) -> Option<zed_extension_api::CodeLabel> {\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n            let start = \"fn \".len() as u32;\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                (\n                    vec![CodeLabelSpan::code_range(Range {\n                        start: 0,\n                        end: code.len().try_into().expect(\"Label to not overflow u32\"),\n                    })],\n                    code,\n                )\n            };\n            Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    start,\n                    end: completion_len as u32,\n                },\n            })\n        }\n        if let Some(kind) = completion.kind {\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Struct => {\n                    if completion\n                        .detail\n                        .as_ref()\n                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                    {\n                        if let Some(label) = format_function(&completion) {\n                            return Some(label);\n                        }\n                    }\n                }\n                Completio<|user_cursor_is_here|>\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n            spans: vec![],\n            filter_range: Range {\n                start: 0,\n                end: completion_len as u32,\n            },\n        })\n    }\n}\n\nzed::register_extension!(ZigExtension);\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}