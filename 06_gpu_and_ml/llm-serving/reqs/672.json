{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -232,7 +232,11 @@\n                         if let Some(label) = format_function(&completion) {\n                             return Some(label);\n                         }\n-                    } else if completion.detail.as_ref().map_or(false, |detail| detail.eq(\"type\"){\n+                    } else if completion\n+                        .detail\n+                        .as_ref()\n+                        .map_or(false, |detail| detail.eq(\"type\"))\n+                    {\n                         let code = format!(\"struct {}\", completion.label);\n                         return Some(zed_extension_api::CodeLabel {\n                             spans: vec![CodeLabelSpan::code_range(Range {\n\n```\n\nUser edited \"src/apprt/embedded.zig\":\n```diff\n@@ -1338,6 +1338,7 @@\n         opts: *const apprt.runtime.App.Options,\n         config: *const Config,\n     ) !*App {\n+        \n         var core_app = try CoreApp.create(global.alloc);\n         errdefer core_app.destroy();\n \n\n```\n\nUser edited \"src/apprt/embedded.zig\":\n```diff\n@@ -1338,7 +1338,7 @@\n         opts: *const apprt.runtime.App.Options,\n         config: *const Config,\n     ) !*App {\n-        \n+        e\n         var core_app = try CoreApp.create(global.alloc);\n         errdefer core_app.destroy();\n \n\n```\n\nUser edited \"src/apprt/embedded.zig\":\n```diff\n@@ -1338,7 +1338,7 @@\n         opts: *const apprt.runtime.App.Options,\n         config: *const Config,\n     ) !*App {\n-        e\n+        std.\n         var core_app = try CoreApp.create(global.alloc);\n         errdefer core_app.destroy();\n \n\n```\n\n\n\n\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1885,7 +1885,9 @@\n                          attach,\n                          path,\n                          settings,\n-                     }| match attach {\n+                     }| {\n+                         dbg!(&path, )\n+                         match attach {\n                         language::Attach::InstancePerRoot => {\n                             // todo: handle instance per root proper.\n                             if let Some(server_ids) = self\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1886,7 +1886,7 @@\n                          path,\n                          settings,\n                      }| {\n-                         dbg!(&path, )\n+                         dbg!(&path, &server_name);\n                          match attach {\n                         language::Attach::InstancePerRoot => {\n                             // todo: handle instance per root proper.\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1947,6 +1947,7 @@\n                                 unreachable!(\"Language server ID should be available, as it's registered on demand\")\n                             }\n                         }\n+                         }\n                     },\n                 )?;\n                 let server_state = self.language_servers.get(&server_id)?;\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -1851,6 +1851,7 @@\n         let initial_snapshot = buffer.text_snapshot();\n         let worktree_id = file.worktree_id(cx);\n \n+        dbg!(&lan\n         let Some(language) = buffer.language().cloned() else {\n             return;\n         };\n\n```\n\n### Input:\n```crates/project/src/lsp_store.rs\n                start = entry.range.start;\n<|editable_region_start|>\n                end = entry.range.end;\n            }\n\n            let mut range = snapshot.clip_point_utf16(start, Bias::Left)\n                ..snapshot.clip_point_utf16(end, Bias::Right);\n\n            // Expand empty ranges by one codepoint\n            if range.start == range.end {\n                // This will be go to the next boundary when being clipped\n                range.end.column += 1;\n                range.end = snapshot.clip_point_utf16(Unclipped(range.end), Bias::Right);\n                if range.start == range.end && range.end.column > 0 {\n                    range.start.column -= 1;\n                    range.start = snapshot.clip_point_utf16(Unclipped(range.start), Bias::Left);\n                }\n            }\n\n            sanitized_diagnostics.push(DiagnosticEntry {\n                range,\n                diagnostic: entry.diagnostic,\n            });\n        }\n        drop(edits_since_save);\n\n        let set = DiagnosticSet::new(sanitized_diagnostics, &snapshot);\n        buffer.update(cx, |buffer, cx| {\n            buffer.update_diagnostics(server_id, set, cx)\n        });\n        Ok(())\n    }\n\n    fn register_buffer_with_language_servers(\n        &mut self,\n        buffer_handle: &Entity<Buffer>,\n        cx: &mut Context<LspStore>,\n    ) {\n        let buffer = buffer_handle.read(cx);\n        let buffer_id = buffer.remote_id();\n\n        let Some(file) = File::from_dyn(buffer.file()) else {\n            return;\n        };\n        if !file.is_local() {\n            return;\n        }\n\n        let abs_path = file.abs_path(cx);\n        let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n            return;\n        };\n        let initial_snapshot = buffer.text_snapshot();\n        let worktree_id = file.worktree_id(cx);\n\n        dbg!(&lan<|user_cursor_is_here|>\n        let Some(language) = buffer.language().cloned() else {\n            return;\n        };\n        let path: Arc<Path> = file\n            .path()\n            .parent()\n            .map(Arc::from)\n            .unwrap_or_else(|| file.path().clone());\n        let Some(worktree) = self\n            .worktree_store\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n        else {\n            return;\n        };\n        let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n        let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n            this.get(\n                ProjectPath { worktree_id, path },\n                AdapterQuery::Language(&language.name()),\n                delegate.clone(),\n                cx,\n            )\n            .collect::<Vec<_>>()\n        });\n        let servers = servers\n            .into_iter()\n            .filter_map(|server_node| {\n                let server_id = server_node.server_id_or_init(\n                    |LaunchDisposition {\n                         server_name,\n                         attach,\n                         path,\n                         settings,\n                     }| {\n                         dbg!(&path, &server_name);\n                         match attach {\n                        language::Attach::InstancePerRoot => {\n                            // todo: handle instance per root proper.\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&(worktree_id, server_name.clone()))\n                            {\n                                server_ids.iter().cloned().next().unwrap()\n                            } else {\n                                let language_name = language.name();\n\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n<|editable_region_end|>\n                                        .into_iter()\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/lsp_store.rs\n                start = entry.range.start;\n<|editable_region_start|>\n                end = entry.range.end;\n            }\n\n            let mut range = snapshot.clip_point_utf16(start, Bias::Left)\n                ..snapshot.clip_point_utf16(end, Bias::Right);\n\n            // Expand empty ranges by one codepoint\n            if range.start == range.end {\n                // This will be go to the next boundary when being clipped\n                range.end.column += 1;\n                range.end = snapshot.clip_point_utf16(Unclipped(range.end), Bias::Right);\n                if range.start == range.end && range.end.column > 0 {\n                    range.start.column -= 1;\n                    range.start = snapshot.clip_point_utf16(Unclipped(range.start), Bias::Left);\n                }\n            }\n\n            sanitized_diagnostics.push(DiagnosticEntry {\n                range,\n                diagnostic: entry.diagnostic,\n            });\n        }\n        drop(edits_since_save);\n\n        let set = DiagnosticSet::new(sanitized_diagnostics, &snapshot);\n        buffer.update(cx, |buffer, cx| {\n            buffer.update_diagnostics(server_id, set, cx)\n        });\n        Ok(())\n    }\n\n    fn register_buffer_with_language_servers(\n        &mut self,\n        buffer_handle: &Entity<Buffer>,\n        cx: &mut Context<LspStore>,\n    ) {\n        let buffer = buffer_handle.read(cx);\n        let buffer_id = buffer.remote_id();\n\n        let Some(file) = File::from_dyn(buffer.file()) else {\n            return;\n        };\n        if !file.is_local() {\n            return;\n        }\n\n        let abs_path = file.abs_path(cx);\n        let Some(uri) = lsp::Url::from_file_path(&abs_path).log_err() else {\n            return;\n        };\n        let initial_snapshot = buffer.text_snapshot();\n        let worktree_id = file.worktree_id(cx);\n\n        dbg!(&lan<|user_cursor_is_here|>\n        let Some(language) = buffer.language().cloned() else {\n            return;\n        };\n        let path: Arc<Path> = file\n            .path()\n            .parent()\n            .map(Arc::from)\n            .unwrap_or_else(|| file.path().clone());\n        let Some(worktree) = self\n            .worktree_store\n            .read(cx)\n            .worktree_for_id(worktree_id, cx)\n        else {\n            return;\n        };\n        let delegate = LocalLspAdapterDelegate::from_local_lsp(self, &worktree, cx);\n        let servers = self.lsp_tree.clone().update(cx, |this, cx| {\n            this.get(\n                ProjectPath { worktree_id, path },\n                AdapterQuery::Language(&language.name()),\n                delegate.clone(),\n                cx,\n            )\n            .collect::<Vec<_>>()\n        });\n        let servers = servers\n            .into_iter()\n            .filter_map(|server_node| {\n                let server_id = server_node.server_id_or_init(\n                    |LaunchDisposition {\n                         server_name,\n                         attach,\n                         path,\n                         settings,\n                     }| {\n                         dbg!(&path, &server_name);\n                         match attach {\n                        language::Attach::InstancePerRoot => {\n                            // todo: handle instance per root proper.\n                            if let Some(server_ids) = self\n                                .language_server_ids\n                                .get(&(worktree_id, server_name.clone()))\n                            {\n                                server_ids.iter().cloned().next().unwrap()\n                            } else {\n                                let language_name = language.name();\n\n                                self.start_language_server(\n                                    &worktree,\n                                    delegate.clone(),\n                                    self.languages\n                                        .lsp_adapters(&language_name)\n                                        .into_iter()\n                                        .find(|adapter| &adapter.name() == server_name)\n<|editable_region_end|>\n                                        .into_iter()\n```"
  },
  "max_tokens": 1024
}