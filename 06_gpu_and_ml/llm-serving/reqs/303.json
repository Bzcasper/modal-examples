{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"\":\n```diff\n@@ -918,7 +918,7 @@\n \n     if $no_releases {\n         # $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n-        $tags = $tags | where not {$in.tag | str starts-with \"v0.\"}\n+        $tags = $tags | where (not {$in.tag | str starts-with \"v0.\"}\n     }\n \n     if $no_collab {\n\n```\n\nUser edited \"\":\n```diff\n@@ -918,7 +918,7 @@\n \n     if $no_releases {\n         # $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n-        $tags = $tags | where (not {$in.tag | str starts-with \"v0.\"}\n+        $tags = $tags | where (not {$in.tag | str starts-with \"v0.\"})\n     }\n \n     if $no_collab {\n\n```\n\nUser edited \"\":\n```diff\n@@ -918,7 +918,7 @@\n \n     if $no_releases {\n         # $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n-        $tags = $tags | where (not {$in.tag | str starts-with \"v0.\"})\n+        $tags = $tags | where not {$in.tag | str starts-with \"v0.\"}\n     }\n \n     if $no_collab {\n\n```\n\nUser edited \"\":\n```diff\n@@ -918,7 +918,7 @@\n \n     if $no_releases {\n         # $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n-        $tags = $tags | where not {$in.tag | str starts-with \"v0.\"}\n+        $tags = $tags | where not {not ($in.tag | str starts-with \"v0.\"}\n     }\n \n     if $no_collab {\n\n```\n\nUser edited \"\":\n```diff\n@@ -918,7 +918,7 @@\n \n     if $no_releases {\n         # $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n-        $tags = $tags | where not {not ($in.tag | str starts-with \"v0.\"}\n+        $tags = $tags | where not {not ($in.tag | str starts-with \"v0.\")}\n     }\n \n     if $no_collab {\n\n```\n\nUser edited \"\":\n```diff\n@@ -917,8 +917,7 @@\n     mut tags = git-tags\n \n     if $no_releases {\n-        # $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n-        $tags = $tags | where not {not ($in.tag | str starts-with \"v0.\")}\n+        $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n     }\n \n     if $no_collab {\n\n```\n\nUser edited \"\":\n```diff\n@@ -914,7 +914,7 @@\n }\n \n def \"git-tags zed\" [--no-releases (-r), --no-collab (-c)]: any -> list<any> {\n-    mut tags = git-tags\n+    let tags = git-tags\n \n     if $no_releases {\n         $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n\n```\n\nUser edited \"\":\n```diff\n@@ -914,7 +914,7 @@\n }\n \n def \"git-tags zed\" [--no-releases (-r), --no-collab (-c)]: any -> list<any> {\n-    let tags = git-tags\n+    mut tags = git-tags\n \n     if $no_releases {\n         $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n\n```\n\n### Input:\n```\n            keycode: char_b\n<|editable_region_start|>\n            mode: emacs\n            event: { edit: movewordleft }\n        }\n        {\n            name: move_one_word_right_or_take_history_hint\n            modifier: alt\n            keycode: char_f\n            mode: emacs\n            event: {\n                until: [\n                    { send: historyhintwordcomplete }\n                    { edit: movewordright }\n                ]\n            }\n        }\n        {\n            name: delete_one_word_forward\n            modifier: alt\n            keycode: delete\n            mode: emacs\n            event: { edit: deleteword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: backspace\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: char_m\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: cut_word_to_right\n            modifier: alt\n            keycode: char_d\n            mode: emacs\n            event: { edit: cutwordright }\n        }\n        {\n            name: upper_case_word\n            modifier: alt\n            keycode: char_u\n            mode: emacs\n            event: { edit: uppercaseword }\n        }\n        {\n            name: lower_case_word\n            modifier: alt\n            keycode: char_l\n            mode: emacs\n            event: { edit: lowercaseword }\n        }\n        {\n            name: capitalize_char\n            modifier: alt\n            keycode: char_c\n            mode: emacs\n            event: { edit: capitalizechar }\n        }\n        # The following bindings with `*system` events require that Nushell has\n        # been compiled with the `system-clipboard` feature.\n        # If you want to use the system clipboard for visual selection or to\n        # paste directly, uncomment the respective lines and replace the version\n        # using the internal clipboard.\n        {\n            name: copy_selection\n            modifier: control_shift\n            keycode: char_c\n            mode: emacs\n            event: { edit: copyselection }\n            # event: { edit: copyselectionsystem }\n        }\n        {\n            name: cut_selection\n            modifier: control_shift\n            keycode: char_x\n            mode: emacs\n            event: { edit: cutselection }\n            # event: { edit: cutselectionsystem }\n        }\n        # {\n        #     name: paste_system\n        #     modifier: control_shift\n        #     keycode: char_v\n        #     mode: emacs\n        #     event: { edit: pastesystem }\n        # }\n        {\n            name: select_all\n            modifier: control_shift\n            keycode: char_a\n            mode: emacs\n            event: { edit: selectall }\n        }\n    ]\n}\n\n# Custom config\n\n$env.config.buffer_editor = \"zed\"\n\ndef \"restart\" []: nothing -> nothing {\n    exec $nu.current-exe\n}\n\n# git\n\ndef git-tags []: any -> list<any> {\n    git tag -n --sort=version:refname\n        | from ssv -n\n        | rename tag \"commit description\"\n}\n\ndef \"git-tags zed\" [--no-releases (-r), --no-collab (-c)]: any -> list<any> {\n    mut<|user_cursor_is_here|> tags = git-tags\n\n    if $no_releases {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n    }\n\n    if $no_collab {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"collab\")}\n    }\n\n    $tags\n}\n\n# TODO - error recovery when encountering a binary file\n\ndef file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {\n    let pattern = if ($extension | is-empty) {\n        \"**/*\"\n    } else {\n        $\"**/*.{($extension | str join \",\")}\"\n    }\n\n    ls ...(glob $pattern) | each {\n        let file = if $name_only {\n            $in.name | path split | last\n        } else {\n            $in.name\n        }\n\n        {\n            file: $file\n            line_count: ($in.name | open | lines | length)\n        }\n    }\n}\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```\n            keycode: char_b\n<|editable_region_start|>\n            mode: emacs\n            event: { edit: movewordleft }\n        }\n        {\n            name: move_one_word_right_or_take_history_hint\n            modifier: alt\n            keycode: char_f\n            mode: emacs\n            event: {\n                until: [\n                    { send: historyhintwordcomplete }\n                    { edit: movewordright }\n                ]\n            }\n        }\n        {\n            name: delete_one_word_forward\n            modifier: alt\n            keycode: delete\n            mode: emacs\n            event: { edit: deleteword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: backspace\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: delete_one_word_backward\n            modifier: alt\n            keycode: char_m\n            mode: emacs\n            event: { edit: backspaceword }\n        }\n        {\n            name: cut_word_to_right\n            modifier: alt\n            keycode: char_d\n            mode: emacs\n            event: { edit: cutwordright }\n        }\n        {\n            name: upper_case_word\n            modifier: alt\n            keycode: char_u\n            mode: emacs\n            event: { edit: uppercaseword }\n        }\n        {\n            name: lower_case_word\n            modifier: alt\n            keycode: char_l\n            mode: emacs\n            event: { edit: lowercaseword }\n        }\n        {\n            name: capitalize_char\n            modifier: alt\n            keycode: char_c\n            mode: emacs\n            event: { edit: capitalizechar }\n        }\n        # The following bindings with `*system` events require that Nushell has\n        # been compiled with the `system-clipboard` feature.\n        # If you want to use the system clipboard for visual selection or to\n        # paste directly, uncomment the respective lines and replace the version\n        # using the internal clipboard.\n        {\n            name: copy_selection\n            modifier: control_shift\n            keycode: char_c\n            mode: emacs\n            event: { edit: copyselection }\n            # event: { edit: copyselectionsystem }\n        }\n        {\n            name: cut_selection\n            modifier: control_shift\n            keycode: char_x\n            mode: emacs\n            event: { edit: cutselection }\n            # event: { edit: cutselectionsystem }\n        }\n        # {\n        #     name: paste_system\n        #     modifier: control_shift\n        #     keycode: char_v\n        #     mode: emacs\n        #     event: { edit: pastesystem }\n        # }\n        {\n            name: select_all\n            modifier: control_shift\n            keycode: char_a\n            mode: emacs\n            event: { edit: selectall }\n        }\n    ]\n}\n\n# Custom config\n\n$env.config.buffer_editor = \"zed\"\n\ndef \"restart\" []: nothing -> nothing {\n    exec $nu.current-exe\n}\n\n# git\n\ndef git-tags []: any -> list<any> {\n    git tag -n --sort=version:refname\n        | from ssv -n\n        | rename tag \"commit description\"\n}\n\ndef \"git-tags zed\" [--no-releases (-r), --no-collab (-c)]: any -> list<any> {\n    mut<|user_cursor_is_here|> tags = git-tags\n\n    if $no_releases {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"v0.\")}\n    }\n\n    if $no_collab {\n        $tags = $tags | filter {not ($in.tag | str starts-with \"collab\")}\n    }\n\n    $tags\n}\n\n# TODO - error recovery when encountering a binary file\n\ndef file-line-counts [...extension: string, --name-only (-n)]: nothing -> list<any> {\n    let pattern = if ($extension | is-empty) {\n        \"**/*\"\n    } else {\n        $\"**/*.{($extension | str join \",\")}\"\n    }\n\n    ls ...(glob $pattern) | each {\n        let file = if $name_only {\n            $in.name | path split | last\n        } else {\n            $in.name\n        }\n\n        {\n            file: $file\n            line_count: ($in.name | open | lines | length)\n        }\n    }\n}\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}