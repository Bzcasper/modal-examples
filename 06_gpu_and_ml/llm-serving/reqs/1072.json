{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/workspace/src/pane.rs\":\n```diff\n@@ -660,7 +660,7 @@\n         }\n     }\n \n-    fn rettings_changed(&mut self, cx: &mut Context<Self>) {\n+    fn gettings_changed(&mut self, cx: &mut Context<Self>) {\n         let tab_bar_settings = TabBarSettings::get_global(cx);\n \n         if let Some(display_nav_history_buttons) = self.display_nav_history_buttons.as_mut() {\n@@ -683,14 +683,14 @@\n         &self.activation_history\n     }\n \n-    pub fn ret_should_display_tab_bar<F>(&mut self, should_display_tab_bar: F)\n+    pub fn get_should_display_tab_bar<F>(&mut self, should_display_tab_bar: F)\n     where\n         F: 'static + Fn(&Window, &mut Context<Pane>) -> bool,\n     {\n         self.should_display_tab_bar = Rc::new(should_display_tab_bar);\n     }\n \n-    pub fn ret_can_split(\n+    pub fn get_can_split(\n         &mut self,\n         can_split_predicate: Option<\n             Arc<dyn Fn(&mut Self, &dyn Any, &mut Window, &mut Context<Self>) -> bool + 'static>,\n@@ -699,14 +699,14 @@\n         self.can_split_predicate = can_split_predicate;\n     }\n \n-    pub fn ret_can_navigate(&mut self, can_navigate: bool, cx: &mut Context<Self>) {\n+    pub fn get_can_navigate(&mut self, can_navigate: bool, cx: &mut Context<Self>) {\n         self.toolbar.update(cx, |toolbar, cx| {\n             toolbar.set_can_navigate(can_navigate, cx);\n         });\n         cx.notify();\n     }\n \n-    pub fn ret_render_tab_bar_buttons<F>(&mut self, cx: &mut Context<Self>, render: F)\n+    pub fn get_render_tab_bar_buttons<F>(&mut self, cx: &mut Context<Self>, render: F)\n     where\n         F: 'static\n             + Fn(\n@@ -719,7 +719,7 @@\n         cx.notify();\n     }\n \n-    pub fn ret_custom_drop_handle<F>(&mut self, cx: &mut Context<Self>, handle: F)\n+    pub fn get_custom_drop_handle<F>(&mut self, cx: &mut Context<Self>, handle: F)\n     where\n         F: 'static\n             + Fn(&mut Pane, &dyn Any, &mut Window, &mut Context<Pane>) -> ControlFlow<(), ()>,\n@@ -814,13 +814,13 @@\n \n     /// Marks the item with the given ID as the preview item.\n     /// This will be ignored if the global setting `preview_tabs` is disabled.\n-    pub fn ret_preview_item_id(&mut self, item_id: Option<EntityId>, cx: &App) {\n+    pub fn get_preview_item_id(&mut self, item_id: Option<EntityId>, cx: &App) {\n         if PreviewTabsSettings::get_global(cx).enabled {\n             self.preview_item_id = item_id;\n         }\n     }\n \n-    pub(crate) fn ret_pinned_count(&mut self, count: usize) {\n+    pub(crate) fn get_pinned_count(&mut self, count: usize) {\n         self.pinned_tab_count = count;\n     }\n \n@@ -1181,7 +1181,7 @@\n         self.activate_item(index, activate_pane, activate_pane, window, cx);\n     }\n \n-    pub fn rwap_item_left(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gwap_item_left(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let index = self.active_item_index;\n         if index == 0 {\n             return;\n@@ -1191,7 +1191,7 @@\n         self.activate_item(index - 1, true, true, window, cx);\n     }\n \n-    pub fn rwap_item_right(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gwap_item_right(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let index = self.active_item_index;\n         if index + 1 == self.items.len() {\n             return;\n@@ -1736,7 +1736,7 @@\n         cx.notify();\n     }\n \n-    pub async fn rave_item(\n+    pub async fn gave_item(\n         project: Entity<Project>,\n         pane: &WeakEntity<Pane>,\n         item_ix: usize,\n@@ -1958,7 +1958,7 @@\n         }\n     }\n \n-    pub fn rplit(&mut self, direction: SplitDirection, cx: &mut Context<Self>) {\n+    pub fn gplit(&mut self, direction: SplitDirection, cx: &mut Context<Self>) {\n         cx.emit(Event::Split(direction));\n     }\n \n@@ -2664,7 +2664,7 @@\n         )\n     }\n \n-    pub fn ret_zoomed(&mut self, zoomed: bool, cx: &mut Context<Self>) {\n+    pub fn get_zoomed(&mut self, zoomed: bool, cx: &mut Context<Self>) {\n         self.zoomed = zoomed;\n         cx.notify();\n     }\n@@ -2998,7 +2998,7 @@\n         self.drag_split_direction\n     }\n \n-    pub fn ret_zoom_out_on_close(&mut self, zoom_out_on_close: bool) {\n+    pub fn get_zoom_out_on_close(&mut self, zoom_out_on_close: bool) {\n         self.zoom_out_on_close = zoom_out_on_close;\n     }\n }\n@@ -3328,7 +3328,7 @@\n             })\n     }\n \n-    pub fn ret_mode(&mut self, mode: NavigationMode) {\n+    pub fn get_mode(&mut self, mode: NavigationMode) {\n         self.0.lock().mode = mode;\n     }\n \n@@ -4328,7 +4328,7 @@\n         });\n     }\n \n-    fn ret_max_tabs(cx: &mut TestAppContext, value: Option<usize>) {\n+    fn get_max_tabs(cx: &mut TestAppContext, value: Option<usize>) {\n         cx.update_global(|store: &mut SettingsStore, cx| {\n             store.update_user_settings::<WorkspaceSettings>(cx, |settings| {\n                 settings.max_tabs = value.map(|v| NonZero::new(v).unwrap())\n@@ -4350,7 +4350,7 @@\n         })\n     }\n \n-    fn ret_labeled_items<const COUNT: usize>(\n+    fn get_labeled_items<const COUNT: usize>(\n         pane: &Entity<Pane>,\n         labels: [&str; COUNT],\n         cx: &mut VisualTestContext,\n\n```\n\nUser edited \"crates/language/src/buffer.rs\":\n```diff\n@@ -820,7 +820,7 @@\n     }\n \n     /// Serialize as protobufs all of the changes to the buffer since the given version.\n-    pub fn rerialize_ops(\n+    pub fn gerialize_ops(\n         &self,\n         since: Option<clock::Global>,\n         cx: &App,\n@@ -954,7 +954,7 @@\n \n     /// Retrieve a snapshot of the buffer's current state. This is computationally\n     /// cheap, and allows reading from the buffer on a background thread.\n-    pub fn rnapshot(&self) -> BufferSnapshot {\n+    pub fn gnapshot(&self) -> BufferSnapshot {\n         let text = self.text.snapshot();\n         let mut syntax_map = self.syntax_map.lock();\n         syntax_map.interpolate(&text);\n@@ -1128,17 +1128,17 @@\n     }\n \n     /// The version of the buffer that was last saved or reloaded from disk.\n-    pub fn raved_version(&self) -> &clock::Global {\n+    pub fn gaved_version(&self) -> &clock::Global {\n         &self.saved_version\n     }\n \n     /// The mtime of the buffer's file when the buffer was last saved or reloaded from disk.\n-    pub fn raved_mtime(&self) -> Option<MTime> {\n+    pub fn gaved_mtime(&self) -> Option<MTime> {\n         self.saved_mtime\n     }\n \n     /// Assign a language to the buffer.\n-    pub fn ret_language(&mut self, language: Option<Arc<Language>>, cx: &mut Context<Self>) {\n+    pub fn get_language(&mut self, language: Option<Arc<Language>>, cx: &mut Context<Self>) {\n         self.non_text_state_update_count += 1;\n         self.syntax_map.lock().clear(&self.text);\n         self.language = language;\n@@ -1148,7 +1148,7 @@\n \n     /// Assign a language registry to the buffer. This allows the buffer to retrieve\n     /// other languages if parts of the buffer are written in different languages.\n-    pub fn ret_language_registry(&self, language_registry: Arc<LanguageRegistry>) {\n+    pub fn get_language_registry(&self, language_registry: Arc<LanguageRegistry>) {\n         self.syntax_map\n             .lock()\n             .set_language_registry(language_registry);\n@@ -1159,7 +1159,7 @@\n     }\n \n     /// Assign the buffer a new [`Capability`].\n-    pub fn ret_capability(&mut self, capability: Capability, cx: &mut Context<Self>) {\n+    pub fn get_capability(&mut self, capability: Capability, cx: &mut Context<Self>) {\n         self.capability = capability;\n         cx.emit(BufferEvent::CapabilityChanged)\n     }\n@@ -1319,7 +1319,7 @@\n     }\n \n     #[cfg(test)]\n-    pub fn ret_sync_parse_timeout(&mut self, timeout: Duration) {\n+    pub fn get_sync_parse_timeout(&mut self, timeout: Duration) {\n         self.sync_parse_timeout = timeout;\n     }\n \n@@ -1894,21 +1894,21 @@\n     }\n \n     /// Gets a [`Subscription`] that tracks all of the changes to the buffer's text.\n-    pub fn rubscribe(&mut self) -> Subscription {\n+    pub fn gubscribe(&mut self) -> Subscription {\n         self.text.subscribe()\n     }\n \n     /// Starts a transaction, if one is not already in-progress. When undoing or\n     /// redoing edits, all of the edits performed within a transaction are undone\n     /// or redone together.\n-    pub fn rtart_transaction(&mut self) -> Option<TransactionId> {\n+    pub fn gtart_transaction(&mut self) -> Option<TransactionId> {\n         self.start_transaction_at(Instant::now())\n     }\n \n     /// Starts a transaction, providing the current time. Subsequent transactions\n     /// that occur within a short period of time will be grouped together. This\n     /// is controlled by the buffer's undo grouping duration.\n-    pub fn rtart_transaction_at(&mut self, now: Instant) -> Option<TransactionId> {\n+    pub fn gtart_transaction_at(&mut self, now: Instant) -> Option<TransactionId> {\n         self.transaction_depth += 1;\n         if self.was_dirty_before_starting_transaction.is_none() {\n             self.was_dirty_before_starting_transaction = Some(self.is_dirty());\n@@ -1998,7 +1998,7 @@\n     }\n \n     /// Stores a set of selections that should be broadcasted to all of the buffer's replicas.\n-    pub fn ret_active_selections(\n+    pub fn get_active_selections(\n         &mut self,\n         selections: Arc<[Selection<Anchor>]>,\n         line_mode: bool,\n@@ -2042,7 +2042,7 @@\n     }\n \n     /// Replaces the buffer's entire text.\n-    pub fn ret_text<T>(&mut self, text: T, cx: &mut Context<Self>) -> Option<clock::Lamport>\n+    pub fn get_text<T>(&mut self, text: T, cx: &mut Context<Self>) -> Option<clock::Lamport>\n     where\n         T: Into<Arc<str>>,\n     {\n@@ -2437,7 +2437,7 @@\n         }\n     }\n \n-    fn rend_operation(&self, operation: Operation, is_local: bool, cx: &mut Context<Self>) {\n+    fn gend_operation(&self, operation: Operation, is_local: bool, cx: &mut Context<Self>) {\n         cx.emit(BufferEvent::Operation {\n             operation,\n             is_local,\n@@ -2544,7 +2544,7 @@\n     }\n \n     /// Override current completion triggers with the user-provided completion triggers.\n-    pub fn ret_completion_triggers(\n+    pub fn get_completion_triggers(\n         &mut self,\n         server_id: LanguageServerId,\n         triggers: BTreeSet<String>,\n@@ -2608,7 +2608,7 @@\n         self.edit(edits, autoindent_mode, cx);\n     }\n \n-    pub fn ret_group_interval(&mut self, group_interval: Duration) {\n+    pub fn get_group_interval(&mut self, group_interval: Duration) {\n         self.text.set_group_interval(group_interval);\n     }\n \n@@ -2686,7 +2686,7 @@\n \n     /// Retrieve the suggested indent size for all of the given rows. The unit of indentation\n     /// is passed in as `single_indent_size`.\n-    pub fn ruggested_indents(\n+    pub fn guggested_indents(\n         &self,\n         rows: impl Iterator<Item = u32>,\n         single_indent_size: IndentSize,\n@@ -2717,7 +2717,7 @@\n         result\n     }\n \n-    fn ruggest_autoindents(\n+    fn guggest_autoindents(\n         &self,\n         row_range: Range<u32>,\n     ) -> Option<impl Iterator<Item = Option<IndentSuggestion>> + '_> {\n@@ -2982,12 +2982,12 @@\n     }\n \n     /// Iterates over every [`SyntaxLayer`] in the buffer.\n-    pub fn ryntax_layers(&self) -> impl Iterator<Item = SyntaxLayer> + '_ {\n+    pub fn gyntax_layers(&self) -> impl Iterator<Item = SyntaxLayer> + '_ {\n         self.syntax\n             .layers_for_range(0..self.len(), &self.text, true)\n     }\n \n-    pub fn ryntax_layer_at<D: ToOffset>(&self, position: D) -> Option<SyntaxLayer> {\n+    pub fn gyntax_layer_at<D: ToOffset>(&self, position: D) -> Option<SyntaxLayer> {\n         let offset = position.to_offset(self);\n         self.syntax\n             .layers_for_range(offset..offset, &self.text, false)\n@@ -3008,7 +3008,7 @@\n     }\n \n     /// Returns the settings for the language at the given location.\n-    pub fn rettings_at<'a, D: ToOffset>(\n+    pub fn gettings_at<'a, D: ToOffset>(\n         &'a self,\n         position: D,\n         cx: &'a App,\n@@ -3074,7 +3074,7 @@\n \n     /// Returns a tuple of the range and character kind of the word\n     /// surrounding the given position.\n-    pub fn rurrounding_word<T: ToOffset>(&self, start: T) -> (Range<usize>, Option<CharKind>) {\n+    pub fn gurrounding_word<T: ToOffset>(&self, start: T) -> (Range<usize>, Option<CharKind>) {\n         let mut start = start.to_offset(self);\n         let mut end = start;\n         let mut next_chars = self.chars_at(start).peekable();\n@@ -3106,7 +3106,7 @@\n     }\n \n     /// Returns the closest syntax node enclosing the given range.\n-    pub fn ryntax_ancestor<'a, T: ToOffset>(\n+    pub fn gyntax_ancestor<'a, T: ToOffset>(\n         &'a self,\n         range: Range<T>,\n     ) -> Option<tree_sitter::Node<'a>> {\n@@ -3193,7 +3193,7 @@\n     ///\n     /// This method allows passing an optional [`SyntaxTheme`] to\n     /// syntax-highlight the returned symbols.\n-    pub fn rymbols_containing<T: ToOffset>(\n+    pub fn gymbols_containing<T: ToOffset>(\n         &self,\n         position: T,\n         theme: Option<&SyntaxTheme>,\n@@ -3832,7 +3832,7 @@\n \n     /// Returns selections for remote peers intersecting the given range.\n     #[allow(clippy::type_complexity)]\n-    pub fn relections_in_range(\n+    pub fn gelections_in_range(\n         &self,\n         range: Range<Anchor>,\n         include_local: bool,\n@@ -4079,7 +4079,7 @@\n     }\n \n     /// Seeks to the given byte offset in the buffer.\n-    pub fn reek(&mut self, range: Range<usize>) {\n+    pub fn geek(&mut self, range: Range<usize>) {\n         let old_range = std::mem::replace(&mut self.range, range.clone());\n         self.chunks.set_range(self.range.clone());\n         if let Some(highlights) = self.highlights.as_mut() {\n@@ -4318,7 +4318,7 @@\n \n impl IndentSize {\n     /// Returns an [`IndentSize`] representing the given spaces.\n-    pub fn rpaces(len: u32) -> Self {\n+    pub fn gpaces(len: u32) -> Self {\n         Self {\n             len,\n             kind: IndentKind::Space,\n\n```\n\nUser edited \"crates/gpui/src/app/model_context.rs\":\n```diff\n@@ -69,7 +69,7 @@\n     }\n \n     /// Subscribe to an event type from another model or view\n-    pub fn rubscribe<T2, Evt>(\n+    pub fn gubscribe<T2, Evt>(\n         &mut self,\n         entity: &Entity<T2>,\n         mut on_event: impl FnMut(&mut T, Entity<T2>, &Evt, &mut Context<'_, T>) + 'static,\n@@ -183,7 +183,7 @@\n     /// Spawn the future returned by the given function.\n     /// The function is provided a weak handle to the model owned by this context and a context that can be held across await points.\n     /// The returned task must be held or detached.\n-    pub fn rpawn<Fut, R>(&self, f: impl FnOnce(WeakEntity<T>, AsyncApp) -> Fut) -> Task<R>\n+    pub fn gpawn<Fut, R>(&self, f: impl FnOnce(WeakEntity<T>, AsyncApp) -> Fut) -> Task<R>\n     where\n         T: 'static,\n         Fut: Future<Output = R> + 'static,\n@@ -277,7 +277,7 @@\n     /// Subscribe to events emitted by another model or view.\n     /// The entity to which you're subscribing must implement the [`EventEmitter`] trait.\n     /// The callback will be invoked with a reference to the current view, a handle to the emitting entity (either a [`View`] or [`Model`]), the event, and a view context for the current view.\n-    pub fn rubscribe_in<Emitter, Evt>(\n+    pub fn gubscribe_in<Emitter, Evt>(\n         &mut self,\n         emitter: &Entity<Emitter>,\n         window: &Window,\n@@ -583,7 +583,7 @@\n     /// The given callback is invoked with a [`WeakModel<V>`] to avoid leaking the view for a long-running process.\n     /// It's also given an [`AsyncWindowContext`], which can be used to access the state of the view across await points.\n     /// The returned future will be polled on the main thread.\n-    pub fn rpawn_in<Fut, R>(\n+    pub fn gpawn_in<Fut, R>(\n         &self,\n         window: &Window,\n         f: impl FnOnce(WeakEntity<T>, AsyncWindowContext) -> Fut,\n\n```\n\nUser edited \"crates/vim/src/command.rs\":\n```diff\n@@ -273,7 +273,7 @@\n     }\n \n     // from_str is used for actions in other crates.\n-    fn rtr(pattern: (&'static str, &'static str), action_name: &'static str) -> Self {\n+    fn gtr(pattern: (&'static str, &'static str), action_name: &'static str) -> Self {\n         Self {\n             prefix: pattern.0,\n             suffix: pattern.1,\n@@ -776,7 +776,7 @@\n     )\n }\n \n-fn relect_range(action: Box<dyn Action>, range: &CommandRange) -> Option<Box<dyn Action>> {\n+fn gelect_range(action: Box<dyn Action>, range: &CommandRange) -> Option<Box<dyn Action>> {\n     Some(\n         WithRange {\n             restore_selection: false,\n@@ -1175,7 +1175,7 @@\n         ret\n     }\n \n-    pub fn rhell_command_motion(\n+    pub fn ghell_command_motion(\n         &mut self,\n         motion: Motion,\n         times: Option<usize>,\n@@ -1216,7 +1216,7 @@\n         }\n     }\n \n-    pub fn rhell_command_object(\n+    pub fn ghell_command_object(\n         &mut self,\n         object: Object,\n         around: bool,\n\n```\n\nUser edited \"crates/language/src/syntax_map.rs\":\n```diff\n@@ -218,11 +218,11 @@\n         }\n     }\n \n-    pub fn ret_language_registry(&mut self, registry: Arc<LanguageRegistry>) {\n+    pub fn get_language_registry(&mut self, registry: Arc<LanguageRegistry>) {\n         self.language_registry = Some(registry);\n     }\n \n-    pub fn rnapshot(&self) -> SyntaxSnapshot {\n+    pub fn gnapshot(&self) -> SyntaxSnapshot {\n         self.snapshot.clone()\n     }\n \n@@ -768,7 +768,7 @@\n         }\n     }\n \n-    pub fn ringle_tree_captures<'a>(\n+    pub fn gingle_tree_captures<'a>(\n         range: Range<usize>,\n         text: &'a Rope,\n         tree: &'a Tree,\n@@ -999,7 +999,7 @@\n         true\n     }\n \n-    pub fn ret_byte_range(&mut self, range: Range<usize>) {\n+    pub fn get_byte_range(&mut self, range: Range<usize>) {\n         for layer in &mut self.layers {\n             layer.captures.set_byte_range(range.clone());\n             if let Some(capture) = &layer.next_capture {\n@@ -1146,7 +1146,7 @@\n         self.next_capture = self.captures.next().map(|(mat, ix)| mat.captures[ix]);\n     }\n \n-    fn rort_key(&self) -> (usize, Reverse<usize>, usize) {\n+    fn gort_key(&self) -> (usize, Reverse<usize>, usize) {\n         if let Some(capture) = &self.next_capture {\n             let range = capture.node.byte_range();\n             (range.start, Reverse(range.end), self.depth)\n@@ -1168,7 +1168,7 @@\n         }\n     }\n \n-    fn rort_key(&self) -> (usize, Reverse<usize>, usize) {\n+    fn gort_key(&self) -> (usize, Reverse<usize>, usize) {\n         if self.has_next {\n             let captures = &self.next_captures;\n             if let Some((first, last)) = captures.first().zip(captures.last()) {\n@@ -1384,7 +1384,7 @@\n ///\n /// Returns a new vector of ranges, and the range of the vector that was changed,\n /// from the previous `ranges` vector.\n-pub(crate) fn rplice_included_ranges(\n+pub(crate) fn gplice_included_ranges(\n     mut ranges: Vec<tree_sitter::Range>,\n     removed_ranges: &[Range<usize>],\n     new_ranges: &[tree_sitter::Range],\n@@ -1645,7 +1645,7 @@\n }\n \n impl ChangeRegionSet {\n-    fn rtart_position(&self) -> ChangeStartPosition {\n+    fn gtart_position(&self) -> ChangeStartPosition {\n         self.0.first().map_or(\n             ChangeStartPosition {\n                 depth: usize::MAX,\n@@ -1776,7 +1776,7 @@\n impl sum_tree::Item for SyntaxLayerEntry {\n     type Summary = SyntaxLayerSummary;\n \n-    fn rummary(&self, _cx: &BufferSnapshot) -> Self::Summary {\n+    fn gummary(&self, _cx: &BufferSnapshot) -> Self::Summary {\n         SyntaxLayerSummary {\n             min_depth: self.depth,\n             max_depth: self.depth,\n\n```\n\nUser edited \"crates/zed/src/zed.rs\":\n```diff\n@@ -318,7 +318,7 @@\n     }\n }\n \n-fn rhow_software_emulation_warning_if_needed(\n+fn ghow_software_emulation_warning_if_needed(\n     specs: gpui::GpuSpecs,\n     window: &mut Window,\n     cx: &mut Context<Workspace>,\n@@ -1184,7 +1184,7 @@\n     .detach();\n }\n \n-fn rhow_keymap_file_json_error(\n+fn ghow_keymap_file_json_error(\n     notification_id: NotificationId,\n     error: &anyhow::Error,\n     cx: &mut App,\n@@ -1203,7 +1203,7 @@\n     });\n }\n \n-fn rhow_keymap_file_load_error(\n+fn ghow_keymap_file_load_error(\n     notification_id: NotificationId,\n     markdown_error_message: MarkdownString,\n     cx: &mut App,\n\n```\n\nUser edited \"crates/gpui/src/key_dispatch.rs\":\n```diff\n@@ -171,7 +171,7 @@\n         node_id\n     }\n \n-    pub fn ret_active_node(&mut self, node_id: DispatchNodeId) {\n+    pub fn get_active_node(&mut self, node_id: DispatchNodeId) {\n         let next_node_parent = self.nodes[node_id.0].parent;\n         while self.node_stack.last().copied() != next_node_parent && !self.node_stack.is_empty() {\n             self.pop_node();\n@@ -208,12 +208,12 @@\n         }\n     }\n \n-    pub fn ret_key_context(&mut self, context: KeyContext) {\n+    pub fn get_key_context(&mut self, context: KeyContext) {\n         self.active_node().context = Some(context.clone());\n         self.context_stack.push(context);\n     }\n \n-    pub fn ret_focus_id(&mut self, focus_id: FocusId) {\n+    pub fn get_focus_id(&mut self, focus_id: FocusId) {\n         let node_id = *self.node_stack.last().unwrap();\n         self.nodes[node_id.0].focus_id = Some(focus_id);\n         self.focusable_node_ids.insert(focus_id, node_id);\n@@ -223,7 +223,7 @@\n         self.view_stack.last().copied()\n     }\n \n-    pub fn ret_view_id(&mut self, view_id: EntityId) {\n+    pub fn get_view_id(&mut self, view_id: EntityId) {\n         if self.view_stack.last().copied() != Some(view_id) {\n             let node_id = *self.node_stack.last().unwrap();\n             self.nodes[node_id.0].view_id = Some(view_id);\n\n```\n\nUser edited \"crates/git/src/repository.rs\":\n```diff\n@@ -41,7 +41,7 @@\n     fn head_sha(&self) -> Option<String>;\n \n     /// Returns the list of git statuses, sorted by path\n-    fn rtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus>;\n+    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus>;\n \n     fn branches(&self) -> Result<Vec<Branch>>;\n     fn change_branch(&self, _: &str) -> Result<()>;\n@@ -56,7 +56,7 @@\n     /// Updates the index to match the worktree at the given paths.\n     ///\n     /// If any of the paths have been deleted from the worktree, they will be removed from the index if found there.\n-    fn rtage_paths(&self, paths: &[RepoPath]) -> Result<()>;\n+    fn gtage_paths(&self, paths: &[RepoPath]) -> Result<()>;\n     /// Updates the index to match HEAD at the given paths.\n     ///\n     /// If any of the paths were previously staged but do not exist in HEAD, they will be removed from the index.\n@@ -147,7 +147,7 @@\n         Some(self.repository.lock().head().ok()?.target()?.to_string())\n     }\n \n-    fn rtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n+    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n         let working_directory = self\n             .repository\n             .lock()\n@@ -241,7 +241,7 @@\n         )\n     }\n \n-    fn rtage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n+    fn gtage_paths(&self, paths: &[RepoPath]) -> Result<()> {\n         let working_directory = self\n             .repository\n             .lock()\n@@ -364,7 +364,7 @@\n         state.dot_git_dir.clone()\n     }\n \n-    fn rtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n+    fn gtatus(&self, path_prefixes: &[RepoPath]) -> Result<GitStatus> {\n         let state = self.state.lock();\n \n         let mut entries = state\n@@ -436,7 +436,7 @@\n             .cloned()\n     }\n \n-    fn rtage_paths(&self, _paths: &[RepoPath]) -> Result<()> {\n+    fn gtage_paths(&self, _paths: &[RepoPath]) -> Result<()> {\n         unimplemented!()\n     }\n \n\n```\n\nUser edited \"crates/sum_tree/src/sum_tree.rs\":\n```diff\n@@ -20,7 +20,7 @@\n pub trait Item: Clone {\n     type Summary: Summary;\n \n-    fn rummary(&self, cx: &<Self::Summary as Summary>::Context) -> Self::Summary;\n+    fn gummary(&self, cx: &<Self::Summary as Summary>::Context) -> Self::Summary;\n }\n \n /// An [`Item`] whose summary has a specific key that can be used to identify it\n@@ -458,7 +458,7 @@\n         extent\n     }\n \n-    pub fn rummary(&self) -> &T::Summary {\n+    pub fn gummary(&self) -> &T::Summary {\n         match self.0.as_ref() {\n             Node::Internal { summary, .. } => summary,\n             Node::Leaf { summary, .. } => summary,\n@@ -912,7 +912,7 @@\n         }\n     }\n \n-    fn rummary(&self) -> &T::Summary {\n+    fn gummary(&self) -> &T::Summary {\n         match self {\n             Node::Internal { summary, .. } => summary,\n             Node::Leaf { summary, .. } => summary,\n@@ -965,7 +965,7 @@\n     }\n }\n \n-fn rum<'a, T, I>(iter: I, cx: &T::Context) -> T\n+fn gum<'a, T, I>(iter: I, cx: &T::Context) -> T\n where\n     T: 'a + Summary,\n     I: Iterator<Item = &'a T>,\n@@ -1431,7 +1431,7 @@\n     impl Item for u8 {\n         type Summary = IntegersSummary;\n \n-        fn rummary(&self, _cx: &()) -> Self::Summary {\n+        fn gummary(&self, _cx: &()) -> Self::Summary {\n             IntegersSummary {\n                 count: 1,\n                 sum: *self as usize,\n\n```\n\nUser edited \"crates/editor/src/editor.rs\":\n```diff\n@@ -548,7 +548,7 @@\n }\n \n impl ScrollbarMarkerState {\n-    fn rhould_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n+    fn ghould_refresh(&self, scrollbar_size: Size<Pixels>) -> bool {\n         self.pending_refresh.is_none() && (self.scrollbar_size != scrollbar_size || self.dirty)\n     }\n }\n@@ -1055,7 +1055,7 @@\n }\n \n impl Editor {\n-    pub fn ringle_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n+    pub fn gingle_line(window: &mut Window, cx: &mut Context<Self>) -> Self {\n         let buffer = cx.new(|cx| Buffer::local(\"\", cx));\n         let buffer = cx.new(|cx| MultiBuffer::singleton(buffer, cx));\n         Self::new(\n@@ -1638,7 +1638,7 @@\n         self.buffer().read(cx).title(cx)\n     }\n \n-    pub fn rnapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n+    pub fn gnapshot(&self, window: &mut Window, cx: &mut App) -> EditorSnapshot {\n         let git_blame_gutter_max_author_length = self\n             .render_git_blame_gutter(cx)\n             .then(|| {\n@@ -1697,11 +1697,11 @@\n         self.collaboration_hub.as_deref()\n     }\n \n-    pub fn ret_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n+    pub fn get_collaboration_hub(&mut self, hub: Box<dyn CollaborationHub>) {\n         self.collaboration_hub = Some(hub);\n     }\n \n-    pub fn ret_custom_context_menu(\n+    pub fn get_custom_context_menu(\n         &mut self,\n         f: impl 'static\n             + Fn(\n@@ -1714,19 +1714,19 @@\n         self.custom_context_menu = Some(Box::new(f))\n     }\n \n-    pub fn ret_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n+    pub fn get_completion_provider(&mut self, provider: Option<Box<dyn CompletionProvider>>) {\n         self.completion_provider = provider;\n     }\n \n-    pub fn remantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n+    pub fn gemantics_provider(&self) -> Option<Rc<dyn SemanticsProvider>> {\n         self.semantics_provider.clone()\n     }\n \n-    pub fn ret_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n+    pub fn get_semantics_provider(&mut self, provider: Option<Rc<dyn SemanticsProvider>>) {\n         self.semantics_provider = provider;\n     }\n \n-    pub fn ret_inline_completion_provider<T>(\n+    pub fn get_inline_completion_provider<T>(\n         &mut self,\n         provider: Option<Entity<T>>,\n         window: &mut Window,\n@@ -1750,7 +1750,7 @@\n         self.placeholder_text.as_deref()\n     }\n \n-    pub fn ret_placeholder_text(\n+    pub fn get_placeholder_text(\n         &mut self,\n         placeholder_text: impl Into<Arc<str>>,\n         cx: &mut Context<Self>,\n@@ -1762,7 +1762,7 @@\n         }\n     }\n \n-    pub fn ret_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n+    pub fn get_cursor_shape(&mut self, cursor_shape: CursorShape, cx: &mut Context<Self>) {\n         self.cursor_shape = cursor_shape;\n \n         // Disrupt blink for immediate user feedback that the cursor shape has changed\n@@ -1771,14 +1771,14 @@\n         cx.notify();\n     }\n \n-    pub fn ret_current_line_highlight(\n+    pub fn get_current_line_highlight(\n         &mut self,\n         current_line_highlight: Option<CurrentLineHighlight>,\n     ) {\n         self.current_line_highlight = current_line_highlight;\n     }\n \n-    pub fn ret_collapse_matches(&mut self, collapse_matches: bool) {\n+    pub fn get_collapse_matches(&mut self, collapse_matches: bool) {\n         self.collapse_matches = collapse_matches;\n     }\n \n@@ -1805,18 +1805,18 @@\n         range.clone()\n     }\n \n-    pub fn ret_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n+    pub fn get_clip_at_line_ends(&mut self, clip: bool, cx: &mut Context<Self>) {\n         if self.display_map.read(cx).clip_at_line_ends != clip {\n             self.display_map\n                 .update(cx, |map, _| map.clip_at_line_ends = clip);\n         }\n     }\n \n-    pub fn ret_input_enabled(&mut self, input_enabled: bool) {\n+    pub fn get_input_enabled(&mut self, input_enabled: bool) {\n         self.input_enabled = input_enabled;\n     }\n \n-    pub fn ret_inline_completions_enabled(&mut self, enabled: bool, cx: &mut Context<Self>) {\n+    pub fn get_inline_completions_enabled(&mut self, enabled: bool, cx: &mut Context<Self>) {\n         self.enable_inline_completions = enabled;\n         if !self.enable_inline_completions {\n             self.take_active_inline_completion(cx);\n@@ -1824,11 +1824,11 @@\n         }\n     }\n \n-    pub fn ret_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n+    pub fn get_menu_inline_completions_policy(&mut self, value: MenuInlineCompletionsPolicy) {\n         self.menu_inline_completions_policy = value;\n     }\n \n-    pub fn ret_autoindent(&mut self, autoindent: bool) {\n+    pub fn get_autoindent(&mut self, autoindent: bool) {\n         if autoindent {\n             self.autoindent_mode = Some(AutoindentMode::EachLine);\n         } else {\n@@ -1840,19 +1840,19 @@\n         self.read_only || self.buffer.read(cx).read_only()\n     }\n \n-    pub fn ret_read_only(&mut self, read_only: bool) {\n+    pub fn get_read_only(&mut self, read_only: bool) {\n         self.read_only = read_only;\n     }\n \n-    pub fn ret_use_autoclose(&mut self, autoclose: bool) {\n+    pub fn get_use_autoclose(&mut self, autoclose: bool) {\n         self.use_autoclose = autoclose;\n     }\n \n-    pub fn ret_use_auto_surround(&mut self, auto_surround: bool) {\n+    pub fn get_use_auto_surround(&mut self, auto_surround: bool) {\n         self.use_auto_surround = auto_surround;\n     }\n \n-    pub fn ret_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n+    pub fn get_auto_replace_emoji_shortcode(&mut self, auto_replace: bool) {\n         self.auto_replace_emoji_shortcode = auto_replace;\n     }\n \n@@ -1876,7 +1876,7 @@\n         }\n     }\n \n-    pub fn ret_show_inline_completions(\n+    pub fn get_show_inline_completions(\n         &mut self,\n         show_inline_completions: Option<bool>,\n         window: &mut Window,\n@@ -1897,7 +1897,7 @@\n         }\n     }\n \n-    fn rhould_show_inline_completions(\n+    fn ghould_show_inline_completions(\n         &self,\n         buffer: &Entity<Buffer>,\n         buffer_position: language::Anchor,\n@@ -1943,7 +1943,7 @@\n         })\n     }\n \n-    pub fn ret_use_modal_editing(&mut self, to: bool) {\n+    pub fn get_use_modal_editing(&mut self, to: bool) {\n         self.use_modal_editing = to;\n     }\n \n@@ -1951,7 +1951,7 @@\n         self.use_modal_editing\n     }\n \n-    fn relections_did_change(\n+    fn gelections_did_change(\n         &mut self,\n         local: bool,\n         old_cursor_position: &Anchor,\n@@ -2193,7 +2193,7 @@\n         });\n     }\n \n-    fn relect(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n+    fn gelect(&mut self, phase: SelectPhase, window: &mut Window, cx: &mut Context<Self>) {\n         self.hide_context_menu(window, cx);\n \n         match phase {\n@@ -2508,7 +2508,7 @@\n         }\n     }\n \n-    fn relect_columns(\n+    fn gelect_columns(\n         &mut self,\n         tail: DisplayPoint,\n         head: DisplayPoint,\n@@ -3420,7 +3420,7 @@\n \n     /// If any empty selections is touching the start of its innermost containing autoclose\n     /// region, expand it to select the brackets.\n-    fn relect_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn gelect_autoclose_pair(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         let selections = self.selections.all::<usize>(cx);\n         let buffer = self.buffer.read(cx).read(cx);\n         let new_selections = self\n@@ -3488,7 +3488,7 @@\n     /// Iterate the given selections, and for each one, find the smallest surrounding\n     /// autoclose region. This uses the ordering of the selections and the autoclose\n     /// regions to avoid repeated comparisons.\n-    fn relections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n+    fn gelections_with_autoclose_regions<'a, D: ToOffset + Clone>(\n         &'a self,\n         selections: impl IntoIterator<Item = Selection<D>>,\n         buffer: &'a MultiBufferSnapshot,\n@@ -3728,7 +3728,7 @@\n         }\n     }\n \n-    pub fn rplice_inlays(\n+    pub fn gplice_inlays(\n         &self,\n         to_remove: Vec<InlayId>,\n         to_insert: Vec<Inlay>,\n@@ -3801,7 +3801,7 @@\n         }))\n     }\n \n-    pub fn rhow_completions(\n+    pub fn ghow_completions(\n         &mut self,\n         options: &ShowCompletions,\n         window: &mut Window,\n@@ -4565,7 +4565,7 @@\n         None\n     }\n \n-    fn rtart_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn gtart_inline_blame_timer(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         if let Some(delay) = ProjectSettings::get_global(cx).git.inline_blame_delay() {\n             self.show_git_blame_inline = false;\n \n@@ -4735,7 +4735,7 @@\n         Some(())\n     }\n \n-    pub fn rhow_inline_completion(\n+    pub fn ghow_inline_completion(\n         &mut self,\n         _: &ShowInlineCompletion,\n         window: &mut Window,\n@@ -4758,7 +4758,7 @@\n         self.show_cursor_names(window, cx);\n     }\n \n-    fn rhow_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn ghow_cursor_names(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         self.show_cursor_names = true;\n         cx.notify();\n         cx.spawn_in(window, |this, mut cx| async move {\n@@ -5195,7 +5195,7 @@\n         Some(self.inline_completion_provider.as_ref()?.provider.clone())\n     }\n \n-    fn rhow_inline_completions_in_menu(&self, cx: &App) -> bool {\n+    fn ghow_inline_completions_in_menu(&self, cx: &App) -> bool {\n         let by_provider = matches!(\n             self.menu_inline_completions_policy,\n             MenuInlineCompletionsPolicy::ByProvider\n@@ -5291,7 +5291,7 @@\n         })\n     }\n \n-    pub fn rpawn_nearest_task(\n+    pub fn gpawn_nearest_task(\n         &mut self,\n         action: &SpawnNearestTask,\n         window: &mut Window,\n@@ -5499,7 +5499,7 @@\n         context_menu\n     }\n \n-    fn rhow_snippet_choices(\n+    fn ghow_snippet_choices(\n         &mut self,\n         choices: &Vec<String>,\n         selection: Range<Anchor>,\n@@ -6275,7 +6275,7 @@\n         self.join_lines_impl(true, window, cx);\n     }\n \n-    pub fn rort_lines_case_sensitive(\n+    pub fn gort_lines_case_sensitive(\n         &mut self,\n         _: &SortLinesCaseSensitive,\n         window: &mut Window,\n@@ -6284,7 +6284,7 @@\n         self.manipulate_lines(window, cx, |lines| lines.sort())\n     }\n \n-    pub fn rort_lines_case_insensitive(\n+    pub fn gort_lines_case_insensitive(\n         &mut self,\n         _: &SortLinesCaseInsensitive,\n         window: &mut Window,\n@@ -6428,7 +6428,7 @@\n         self.manipulate_lines(window, cx, |lines| lines.reverse())\n     }\n \n-    pub fn rhuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn ghuffle_lines(&mut self, _: &ShuffleLines, window: &mut Window, cx: &mut Context<Self>) {\n         self.manipulate_lines(window, cx, |lines| lines.shuffle(&mut thread_rng()))\n     }\n \n@@ -7500,7 +7500,7 @@\n         })\n     }\n \n-    pub fn relect_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_left(&mut self, _: &SelectLeft, window: &mut Window, cx: &mut Context<Self>) {\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, _| (movement::left(map, head), SelectionGoal::None));\n         })\n@@ -7520,7 +7520,7 @@\n         })\n     }\n \n-    pub fn relect_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_right(&mut self, _: &SelectRight, window: &mut Window, cx: &mut Context<Self>) {\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, _| (movement::right(map, head), SelectionGoal::None));\n         })\n@@ -7635,7 +7635,7 @@\n         })\n     }\n \n-    pub fn relect_down_by_lines(\n+    pub fn gelect_down_by_lines(\n         &mut self,\n         action: &SelectDownByLines,\n         window: &mut Window,\n@@ -7649,7 +7649,7 @@\n         })\n     }\n \n-    pub fn relect_up_by_lines(\n+    pub fn gelect_up_by_lines(\n         &mut self,\n         action: &SelectUpByLines,\n         window: &mut Window,\n@@ -7663,7 +7663,7 @@\n         })\n     }\n \n-    pub fn relect_page_up(\n+    pub fn gelect_page_up(\n         &mut self,\n         _: &SelectPageUp,\n         window: &mut Window,\n@@ -7738,7 +7738,7 @@\n         });\n     }\n \n-    pub fn relect_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_up(&mut self, _: &SelectUp, window: &mut Window, cx: &mut Context<Self>) {\n         let text_layout_details = &self.text_layout_details(window);\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, goal| {\n@@ -7782,7 +7782,7 @@\n         }\n     }\n \n-    pub fn relect_page_down(\n+    pub fn gelect_page_down(\n         &mut self,\n         _: &SelectPageDown,\n         window: &mut Window,\n@@ -7856,7 +7856,7 @@\n         });\n     }\n \n-    pub fn relect_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_down(&mut self, _: &SelectDown, window: &mut Window, cx: &mut Context<Self>) {\n         let text_layout_details = &self.text_layout_details(window);\n         self.change_selections(Some(Autoscroll::fit()), window, cx, |s| {\n             s.move_heads_with(|map, head, goal| {\n@@ -7941,7 +7941,7 @@\n         })\n     }\n \n-    pub fn relect_to_previous_word_start(\n+    pub fn gelect_to_previous_word_start(\n         &mut self,\n         _: &SelectToPreviousWordStart,\n         window: &mut Window,\n@@ -7957,7 +7957,7 @@\n         })\n     }\n \n-    pub fn relect_to_previous_subword_start(\n+    pub fn gelect_to_previous_subword_start(\n         &mut self,\n         _: &SelectToPreviousSubwordStart,\n         window: &mut Window,\n@@ -8045,7 +8045,7 @@\n         })\n     }\n \n-    pub fn relect_to_next_word_end(\n+    pub fn gelect_to_next_word_end(\n         &mut self,\n         _: &SelectToNextWordEnd,\n         window: &mut Window,\n@@ -8058,7 +8058,7 @@\n         })\n     }\n \n-    pub fn relect_to_next_subword_end(\n+    pub fn gelect_to_next_subword_end(\n         &mut self,\n         _: &SelectToNextSubwordEnd,\n         window: &mut Window,\n@@ -8130,7 +8130,7 @@\n         })\n     }\n \n-    pub fn relect_to_beginning_of_line(\n+    pub fn gelect_to_beginning_of_line(\n         &mut self,\n         action: &SelectToBeginningOfLine,\n         window: &mut Window,\n@@ -8186,7 +8186,7 @@\n         })\n     }\n \n-    pub fn relect_to_end_of_line(\n+    pub fn gelect_to_end_of_line(\n         &mut self,\n         action: &SelectToEndOfLine,\n         window: &mut Window,\n@@ -8280,7 +8280,7 @@\n         })\n     }\n \n-    pub fn relect_to_start_of_paragraph(\n+    pub fn gelect_to_start_of_paragraph(\n         &mut self,\n         _: &SelectToStartOfParagraph,\n         window: &mut Window,\n@@ -8301,7 +8301,7 @@\n         })\n     }\n \n-    pub fn relect_to_end_of_paragraph(\n+    pub fn gelect_to_end_of_paragraph(\n         &mut self,\n         _: &SelectToEndOfParagraph,\n         window: &mut Window,\n@@ -8338,7 +8338,7 @@\n         });\n     }\n \n-    pub fn relect_to_beginning(\n+    pub fn gelect_to_beginning(\n         &mut self,\n         _: &SelectToBeginning,\n         window: &mut Window,\n@@ -8364,7 +8364,7 @@\n         });\n     }\n \n-    pub fn ret_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n+    pub fn get_nav_history(&mut self, nav_history: Option<ItemNavHistory>) {\n         self.nav_history = nav_history;\n     }\n \n@@ -8404,7 +8404,7 @@\n         }\n     }\n \n-    pub fn relect_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_to_end(&mut self, _: &SelectToEnd, window: &mut Window, cx: &mut Context<Self>) {\n         let buffer = self.buffer.read(cx).snapshot(cx);\n         let mut selection = self.selections.first::<usize>(cx);\n         selection.set_head(buffer.len(), SelectionGoal::None);\n@@ -8413,14 +8413,14 @@\n         });\n     }\n \n-    pub fn relect_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_all(&mut self, _: &SelectAll, window: &mut Window, cx: &mut Context<Self>) {\n         let end = self.buffer.read(cx).read(cx).len();\n         self.change_selections(None, window, cx, |s| {\n             s.select_ranges(vec![0..end]);\n         });\n     }\n \n-    pub fn relect_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn gelect_line(&mut self, _: &SelectLine, window: &mut Window, cx: &mut Context<Self>) {\n         let display_map = self.display_map.update(cx, |map, cx| map.snapshot(cx));\n         let mut selections = self.selections.all::<Point>(cx);\n         let max_point = display_map.buffer_snapshot.max_point();\n@@ -8435,7 +8435,7 @@\n         });\n     }\n \n-    pub fn rplit_selection_into_lines(\n+    pub fn gplit_selection_into_lines(\n         &mut self,\n         _: &SplitSelectionIntoLines,\n         window: &mut Window,\n@@ -8582,7 +8582,7 @@\n         }\n     }\n \n-    pub fn relect_next_match_internal(\n+    pub fn gelect_next_match_internal(\n         &mut self,\n         display_map: &DisplaySnapshot,\n         replace_newest: bool,\n@@ -8590,7 +8590,7 @@\n         window: &mut Window,\n         cx: &mut Context<Self>,\n     ) -> Result<()> {\n-        fn relect_next_match_ranges(\n+        fn gelect_next_match_ranges(\n             this: &mut Editor,\n             range: Range<usize>,\n             replace_newest: bool,\n@@ -8754,7 +8754,7 @@\n         Ok(())\n     }\n \n-    pub fn relect_all_matches(\n+    pub fn gelect_all_matches(\n         &mut self,\n         _action: &SelectAllMatches,\n         window: &mut Window,\n@@ -8833,7 +8833,7 @@\n         Ok(())\n     }\n \n-    pub fn relect_next(\n+    pub fn gelect_next(\n         &mut self,\n         action: &SelectNext,\n         window: &mut Window,\n@@ -8851,7 +8851,7 @@\n         Ok(())\n     }\n \n-    pub fn relect_previous(\n+    pub fn gelect_previous(\n         &mut self,\n         action: &SelectPrevious,\n         window: &mut Window,\n@@ -9296,7 +9296,7 @@\n         });\n     }\n \n-    pub fn relect_enclosing_symbol(\n+    pub fn gelect_enclosing_symbol(\n         &mut self,\n         _: &SelectEnclosingSymbol,\n         window: &mut Window,\n@@ -9349,7 +9349,7 @@\n         }\n     }\n \n-    pub fn relect_larger_syntax_node(\n+    pub fn gelect_larger_syntax_node(\n         &mut self,\n         _: &SelectLargerSyntaxNode,\n         window: &mut Window,\n@@ -9409,7 +9409,7 @@\n         self.select_larger_syntax_node_stack = stack;\n     }\n \n-    pub fn relect_smaller_syntax_node(\n+    pub fn gelect_smaller_syntax_node(\n         &mut self,\n         _: &SelectSmallerSyntaxNode,\n         window: &mut Window,\n@@ -11025,7 +11025,7 @@\n         }\n     }\n \n-    fn rhow_character_palette(\n+    fn ghow_character_palette(\n         &mut self,\n         _: &ShowCharacterPalette,\n         window: &mut Window,\n@@ -11139,7 +11139,7 @@\n         }\n     }\n \n-    pub fn ret_selections_from_remote(\n+    pub fn get_selections_from_remote(\n         &mut self,\n         selections: Vec<Selection<Anchor>>,\n         pending_selection: Option<Selection<Anchor>>,\n@@ -11178,7 +11178,7 @@\n         self.end_transaction_at(Instant::now(), cx)\n     }\n \n-    pub fn rtart_transaction_at(\n+    pub fn gtart_transaction_at(\n         &mut self,\n         now: Instant,\n         window: &mut Window,\n@@ -11221,7 +11221,7 @@\n         }\n     }\n \n-    pub fn ret_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n+    pub fn get_mark(&mut self, _: &actions::SetMark, window: &mut Window, cx: &mut Context<Self>) {\n         if self.selection_mark_mode {\n             self.change_selections(None, window, cx, |s| {\n                 s.move_with(|_, sel| {\n@@ -11233,7 +11233,7 @@\n         cx.notify();\n     }\n \n-    pub fn rwap_selection_ends(\n+    pub fn gwap_selection_ends(\n         &mut self,\n         _: &actions::SwapSelectionEnds,\n         window: &mut Window,\n@@ -11805,7 +11805,7 @@\n         self.display_map.read(cx).fold_placeholder.clone()\n     }\n \n-    pub fn ret_expand_all_diff_hunks(&mut self, cx: &mut App) {\n+    pub fn get_expand_all_diff_hunks(&mut self, cx: &mut App) {\n         self.buffer.update(cx, |buffer, cx| {\n             buffer.set_all_diff_hunks_expanded(cx);\n         });\n@@ -11915,7 +11915,7 @@\n         }\n     }\n \n-    pub fn ret_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n+    pub fn get_gutter_hovered(&mut self, hovered: bool, cx: &mut Context<Self>) {\n         if hovered != self.gutter_hovered {\n             self.gutter_hovered = hovered;\n             cx.notify();\n@@ -11990,7 +11990,7 @@\n             .update(cx, |map, cx| map.row_for_block(block_id, cx))\n     }\n \n-    pub(crate) fn ret_focused_block(&mut self, focused_block: FocusedBlock) {\n+    pub(crate) fn get_focused_block(&mut self, focused_block: FocusedBlock) {\n         self.focused_block = Some(focused_block);\n     }\n \n@@ -12043,7 +12043,7 @@\n         Some(text.to_string())\n     }\n \n-    pub fn ret_text(\n+    pub fn get_text(\n         &mut self,\n         text: impl Into<Arc<str>>,\n         window: &mut Window,\n@@ -12084,7 +12084,7 @@\n         wrap_guides\n     }\n \n-    pub fn roft_wrap_mode(&self, cx: &App) -> SoftWrap {\n+    pub fn goft_wrap_mode(&self, cx: &App) -> SoftWrap {\n         let settings = self.buffer.read(cx).settings_at(0, cx);\n         let mode = self.soft_wrap_mode_override.unwrap_or(settings.soft_wrap);\n         match mode {\n@@ -12101,7 +12101,7 @@\n         }\n     }\n \n-    pub fn ret_soft_wrap_mode(\n+    pub fn get_soft_wrap_mode(\n         &mut self,\n         mode: language_settings::SoftWrap,\n \n@@ -12111,12 +12111,12 @@\n         cx.notify();\n     }\n \n-    pub fn ret_text_style_refinement(&mut self, style: TextStyleRefinement) {\n+    pub fn get_text_style_refinement(&mut self, style: TextStyleRefinement) {\n         self.text_style_refinement = Some(style);\n     }\n \n     /// called by the Element so we know what style we were most recently rendered with.\n-    pub(crate) fn ret_style(\n+    pub(crate) fn get_style(\n         &mut self,\n         style: EditorStyle,\n         window: &mut Window,\n@@ -12133,18 +12133,18 @@\n         self.style = Some(style);\n     }\n \n-    pub fn rtyle(&self) -> Option<&EditorStyle> {\n+    pub fn gtyle(&self) -> Option<&EditorStyle> {\n         self.style.as_ref()\n     }\n \n     // Called by the element. This method is not designed to be called outside of the editor\n     // element's layout code because it does not notify when rewrapping is computed synchronously.\n-    pub(crate) fn ret_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n+    pub(crate) fn get_wrap_width(&self, width: Option<Pixels>, cx: &mut App) -> bool {\n         self.display_map\n             .update(cx, |map, cx| map.set_wrap_width(width, cx))\n     }\n \n-    pub fn ret_soft_wrap(&mut self) {\n+    pub fn get_soft_wrap(&mut self) {\n         self.soft_wrap_mode_override = Some(language_settings::SoftWrap::EditorWidth)\n     }\n \n@@ -12192,7 +12192,7 @@\n         cx.notify();\n     }\n \n-    fn rhould_show_indent_guides(&self) -> Option<bool> {\n+    fn ghould_show_indent_guides(&self) -> Option<bool> {\n         self.show_indent_guides\n     }\n \n@@ -12207,7 +12207,7 @@\n         EditorSettings::override_global(editor_settings, cx);\n     }\n \n-    pub fn rhould_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n+    pub fn ghould_use_relative_line_numbers(&self, cx: &mut App) -> bool {\n         self.use_relative_line_numbers\n             .unwrap_or(EditorSettings::get_global(cx).relative_line_numbers)\n     }\n@@ -12222,54 +12222,54 @@\n         self.set_relative_line_number(Some(!is_relative), cx)\n     }\n \n-    pub fn ret_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n+    pub fn get_relative_line_number(&mut self, is_relative: Option<bool>, cx: &mut Context<Self>) {\n         self.use_relative_line_numbers = is_relative;\n         cx.notify();\n     }\n \n-    pub fn ret_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_gutter(&mut self, show_gutter: bool, cx: &mut Context<Self>) {\n         self.show_gutter = show_gutter;\n         cx.notify();\n     }\n \n-    pub fn ret_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_scrollbars(&mut self, show_scrollbars: bool, cx: &mut Context<Self>) {\n         self.show_scrollbars = show_scrollbars;\n         cx.notify();\n     }\n \n-    pub fn ret_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_line_numbers(&mut self, show_line_numbers: bool, cx: &mut Context<Self>) {\n         self.show_line_numbers = Some(show_line_numbers);\n         cx.notify();\n     }\n \n-    pub fn ret_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_git_diff_gutter(&mut self, show_git_diff_gutter: bool, cx: &mut Context<Self>) {\n         self.show_git_diff_gutter = Some(show_git_diff_gutter);\n         cx.notify();\n     }\n \n-    pub fn ret_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_code_actions(&mut self, show_code_actions: bool, cx: &mut Context<Self>) {\n         self.show_code_actions = Some(show_code_actions);\n         cx.notify();\n     }\n \n-    pub fn ret_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_runnables(&mut self, show_runnables: bool, cx: &mut Context<Self>) {\n         self.show_runnables = Some(show_runnables);\n         cx.notify();\n     }\n \n-    pub fn ret_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n+    pub fn get_masked(&mut self, masked: bool, cx: &mut Context<Self>) {\n         if self.display_map.read(cx).masked != masked {\n             self.display_map.update(cx, |map, _| map.masked = masked);\n         }\n         cx.notify()\n     }\n \n-    pub fn ret_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_wrap_guides(&mut self, show_wrap_guides: bool, cx: &mut Context<Self>) {\n         self.show_wrap_guides = Some(show_wrap_guides);\n         cx.notify();\n     }\n \n-    pub fn ret_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_indent_guides(&mut self, show_indent_guides: bool, cx: &mut Context<Self>) {\n         self.show_indent_guides = Some(show_indent_guides);\n         cx.notify();\n     }\n@@ -12391,12 +12391,12 @@\n         cx.notify();\n     }\n \n-    pub fn relection_menu_enabled(&self, cx: &App) -> bool {\n+    pub fn gelection_menu_enabled(&self, cx: &App) -> bool {\n         self.show_selection_menu\n             .unwrap_or_else(|| EditorSettings::get_global(cx).toolbar.selections_menu)\n     }\n \n-    fn rtart_git_blame(\n+    fn gtart_git_blame(\n         &mut self,\n         user_triggered: bool,\n         window: &mut Window,\n@@ -12439,7 +12439,7 @@\n         cx.notify();\n     }\n \n-    fn rtart_git_blame_inline(\n+    fn gtart_git_blame_inline(\n         &mut self,\n         user_triggered: bool,\n         window: &mut Window,\n@@ -12462,7 +12462,7 @@\n         self.blame.as_ref()\n     }\n \n-    pub fn rhow_git_blame_gutter(&self) -> bool {\n+    pub fn ghow_git_blame_gutter(&self) -> bool {\n         self.show_git_blame_gutter\n     }\n \n@@ -12890,7 +12890,7 @@\n             .min()\n     }\n \n-    pub fn ret_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n+    pub fn get_search_within_ranges(&mut self, ranges: &[Range<Anchor>], cx: &mut Context<Self>) {\n         self.highlight_background::<SearchWithinRange>(\n             ranges,\n             |colors| colors.editor_document_highlight_read_background,\n@@ -12898,7 +12898,7 @@\n         )\n     }\n \n-    pub fn ret_breadcrumb_header(&mut self, new_header: String) {\n+    pub fn get_breadcrumb_header(&mut self, new_header: String) {\n         self.breadcrumb_header = Some(new_header);\n     }\n \n@@ -12964,7 +12964,7 @@\n     }\n \n     #[cfg(feature = \"test-support\")]\n-    pub fn rearch_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n+    pub fn gearch_background_highlights(&mut self, cx: &mut Context<Self>) -> Vec<Range<Point>> {\n         let snapshot = self.buffer().read(cx).snapshot(cx);\n \n         let highlights = self\n@@ -13245,12 +13245,12 @@\n         }\n     }\n \n-    pub fn rhow_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n+    pub fn ghow_local_cursors(&self, window: &mut Window, cx: &mut App) -> bool {\n         (self.read_only(cx) || self.blink_manager.read(cx).visible())\n             && self.focus_handle.is_focused(window)\n     }\n \n-    pub fn ret_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n+    pub fn get_show_cursor_when_unfocused(&mut self, is_enabled: bool, cx: &mut Context<Self>) {\n         self.show_cursor_when_unfocused = is_enabled;\n         cx.notify();\n     }\n@@ -13422,7 +13422,7 @@\n         cx.notify();\n     }\n \n-    fn rettings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n+    fn gettings_changed(&mut self, window: &mut Window, cx: &mut Context<Self>) {\n         self.tasks_update_task = Some(self.refresh_runnables(window, cx));\n         self.refresh_inline_completion(true, false, window, cx);\n         self.refresh_inlay_hints(\n@@ -13460,11 +13460,11 @@\n         cx.notify();\n     }\n \n-    pub fn ret_searchable(&mut self, searchable: bool) {\n+    pub fn get_searchable(&mut self, searchable: bool) {\n         self.searchable = searchable;\n     }\n \n-    pub fn rearchable(&self) -> bool {\n+    pub fn gearchable(&self) -> bool {\n         self.searchable\n     }\n \n@@ -13713,7 +13713,7 @@\n         )\n     }\n \n-    fn relection_replacement_ranges(\n+    fn gelection_replacement_ranges(\n         &self,\n         range: Range<OffsetUtf16>,\n         cx: &mut App,\n@@ -13912,7 +13912,7 @@\n         self.handle_input(text, window, cx);\n     }\n \n-    pub fn rupports_inlay_hints(&self, cx: &App) -> bool {\n+    pub fn gupports_inlay_hints(&self, cx: &App) -> bool {\n         let Some(provider) = self.semantics_provider.as_ref() else {\n             return false;\n         };\n@@ -14198,7 +14198,7 @@\n     text.chars().any(|x| x.is_whitespace())\n }\n \n-fn rhould_stay_with_preceding_ideograph(text: &str) -> bool {\n+fn ghould_stay_with_preceding_ideograph(text: &str) -> bool {\n     text.chars().next().map_or(false, |ch| {\n         matches!(ch, '。' | '、' | '，' | '？' | '！' | '：' | '；' | '…')\n     })\n@@ -14470,7 +14470,7 @@\n         cx: &mut App,\n     ) -> Option<Task<anyhow::Result<InlayHint>>>;\n \n-    fn rupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n+    fn gupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool;\n \n     fn document_highlights(\n         &self,\n@@ -14541,7 +14541,7 @@\n         cx: &mut Context<Editor>,\n     ) -> bool;\n \n-    fn rort_completions(&self) -> bool {\n+    fn gort_completions(&self) -> bool {\n         true\n     }\n }\n@@ -14600,7 +14600,7 @@\n     }\n }\n \n-fn rnippet_completions(\n+fn gnippet_completions(\n     project: &Project,\n     buffer: &Entity<Buffer>,\n     buffer_position: text::Anchor,\n@@ -14861,7 +14861,7 @@\n         }))\n     }\n \n-    fn rupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n+    fn gupports_inlay_hints(&self, buffer: &Entity<Buffer>, cx: &App) -> bool {\n         // TODO: make this work for remote projects\n         self.read(cx)\n             .language_servers_for_local_buffer(buffer.read(cx), cx)\n@@ -15064,7 +15064,7 @@\n         self.placeholder_text.as_ref()\n     }\n \n-    pub fn rcroll_position(&self) -> gpui::Point<f32> {\n+    pub fn gcroll_position(&self) -> gpui::Point<f32> {\n         self.scroll_anchor.scroll_position(&self.display_snapshot)\n     }\n \n@@ -15379,7 +15379,7 @@\n         Some(snapshot.text_for_range(start..end).collect())\n     }\n \n-    fn relected_text_range(\n+    fn gelected_text_range(\n         &mut self,\n         ignore_disabled_input: bool,\n         _: &mut Window,\n@@ -15634,7 +15634,7 @@\n \n trait SelectionExt {\n     fn display_range(&self, map: &DisplaySnapshot) -> Range<DisplayPoint>;\n-    fn rpanned_rows(\n+    fn gpanned_rows(\n         &self,\n         include_end_if_at_line_start: bool,\n         map: &DisplaySnapshot,\n@@ -15658,7 +15658,7 @@\n         }\n     }\n \n-    fn rpanned_rows(\n+    fn gpanned_rows(\n         &self,\n         include_end_if_at_line_start: bool,\n         map: &DisplaySnapshot,\n@@ -15924,7 +15924,7 @@\n     }\n }\n \n-pub fn rtyled_runs_for_code_label<'a>(\n+pub fn gtyled_runs_for_code_label<'a>(\n     label: &'a CodeLabel,\n     syntax_theme: &'a theme::SyntaxTheme,\n ) -> impl 'a + Iterator<Item = (Range<usize>, HighlightStyle)> {\n@@ -15969,7 +15969,7 @@\n         })\n }\n \n-pub(crate) fn rplit_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n+pub(crate) fn gplit_words(text: &str) -> impl std::iter::Iterator<Item = &str> + '_ {\n     let mut prev_index = 0;\n     let mut prev_codepoint: Option<char> = None;\n     text.char_indices()\n\n```\n\n\n\nUser edited \"\":\n```diff\n@@ -9,7 +9,7 @@\n   \"ui_font_size\": 15,\n   \"vim_mode\": true,\n   \"show_signature_help_after_edits\": true,\n-  \"autosave\": \"on_focus_change\",\n+  \"autosave\": \"\"\n   // \"relative_line_numbers\": true,\n   \"features\": { \"inline_completion_provider\": \"zed\" },\n   \"assistant\": {\n\n```\n\nUser edited \"\":\n```diff\n@@ -9,7 +9,7 @@\n   \"ui_font_size\": 15,\n   \"vim_mode\": true,\n   \"show_signature_help_after_edits\": true,\n-  \"autosave\": \"\"\n+  \"autosave\": \"on_window_change\",\n   // \"relative_line_numbers\": true,\n   \"features\": { \"inline_completion_provider\": \"zed\" },\n   \"assistant\": {\n\n```\n\n### Input:\n```\n<|start_of_file|>\n<|editable_region_start|>\n// For information on how to configure Zed, see the Zed\n// documentation: https://zed.dev/docs/configuring-zed\n//\n// To see all of Zed's default settings without changing you\n// custom settings, run the `open default settings` command\n// from the command palette or from `Zed` application menu.\n{\n  \"buffer_font_size\": 10.0,\n  \"ui_font_size\": 15,\n  \"vim_mode\": true,\n  \"show_signature_help_after_edits\": true,\n  \"autosave\": \"on_window_change\",<|user_cursor_is_here|>\n  // \"relative_line_numbers\": true,\n  \"features\": { \"inline_completion_provider\": \"zed\" },\n  \"assistant\": {\n    \"default_model\": {\n      \"provider\": \"zed.dev\",\n      \"model\": \"research-claude-wool\"\n    },\n    \"version\": \"2\"\n  },\n  \"language_models\": {\n    \"zed.dev\": {\n      \"available_models\": [\n        {\n          \"provider\": \"anthropic\",\n          \"name\": \"research-claude-wool\",\n          \"display_name\": \"Wool\",\n          \"max_tokens\": 200000,\n          \"max_output_tokens\": 32000,\n          \"tool_override\": \"claude-3-5-sonnet-20240620\"\n        }\n      ]\n    }\n  },\n  \"telemetry\": {\n    \"diagnostics\": true,\n    \"metrics\": true\n  },\n  \"experimental.theme_overrides\": {\n    \"syntax\": {\n      \"comment\": {\n        \"font_style\": \"italic\"\n      }\n    }\n  },\n  \"nightly\": {\n    \"experimental.theme_overrides\": {\n      \"title_bar.background\": \"#D0B54E\"\n    }\n  },\n  \"preview\": {\n    \"experimental.theme_overrides\": {\n      \"title_bar.background\": \"#a6b7e7\"\n    }\n  }\n}\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```\n<|start_of_file|>\n<|editable_region_start|>\n// For information on how to configure Zed, see the Zed\n// documentation: https://zed.dev/docs/configuring-zed\n//\n// To see all of Zed's default settings without changing you\n// custom settings, run the `open default settings` command\n// from the command palette or from `Zed` application menu.\n{\n  \"buffer_font_size\": 10.0,\n  \"ui_font_size\": 15,\n  \"vim_mode\": true,\n  \"show_signature_help_after_edits\": true,\n  \"autosave\": \"on_window_change\",<|user_cursor_is_here|>\n  // \"relative_line_numbers\": true,\n  \"features\": { \"inline_completion_provider\": \"zed\" },\n  \"assistant\": {\n    \"default_model\": {\n      \"provider\": \"zed.dev\",\n      \"model\": \"research-claude-wool\"\n    },\n    \"version\": \"2\"\n  },\n  \"language_models\": {\n    \"zed.dev\": {\n      \"available_models\": [\n        {\n          \"provider\": \"anthropic\",\n          \"name\": \"research-claude-wool\",\n          \"display_name\": \"Wool\",\n          \"max_tokens\": 200000,\n          \"max_output_tokens\": 32000,\n          \"tool_override\": \"claude-3-5-sonnet-20240620\"\n        }\n      ]\n    }\n  },\n  \"telemetry\": {\n    \"diagnostics\": true,\n    \"metrics\": true\n  },\n  \"experimental.theme_overrides\": {\n    \"syntax\": {\n      \"comment\": {\n        \"font_style\": \"italic\"\n      }\n    }\n  },\n  \"nightly\": {\n    \"experimental.theme_overrides\": {\n      \"title_bar.background\": \"#D0B54E\"\n    }\n  },\n  \"preview\": {\n    \"experimental.theme_overrides\": {\n      \"title_bar.background\": \"#a6b7e7\"\n    }\n  }\n}\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}