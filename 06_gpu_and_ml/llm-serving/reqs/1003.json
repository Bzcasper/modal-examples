{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -43,7 +43,7 @@\n     instances: BTreeMap<WorktreeId, ServersForWorktree>,\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n-    _subscriptions: [Subscription; 2],\n+    _subscriptions: Subscription,\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -44,6 +44,7 @@\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n     _subscriptions: Subscription,\n+    _language_sub\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -44,7 +44,6 @@\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n     _subscriptions: Subscription,\n-    _language_sub\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -44,6 +44,7 @@\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n     _subscriptions: Subscription,\n+    _language_subscription\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -44,7 +44,7 @@\n     attach_kind_cache: HashMap<LanguageServerName, Attach>,\n     languages: Arc<LanguageRegistry>,\n     _subscriptions: Subscription,\n-    _language_subscription\n+    _language_subscription: Subscription,\n }\n \n /// A node in language server tree represents either:\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -144,6 +144,7 @@\n         languages: Arc<LanguageRegistry>,\n         cx: &mut App,\n     ) -> Entity<Self> {\n+        \n         cx.new(|cx| Self {\n             _subscriptions: cx.subscribe(\n                 &project_tree,\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -144,7 +144,7 @@\n         languages: Arc<LanguageRegistry>,\n         cx: &mut App,\n     ) -> Entity<Self> {\n-        \n+        let subsc\n         cx.new(|cx| Self {\n             _subscriptions: cx.subscribe(\n                 &project_tree,\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -144,7 +144,14 @@\n         languages: Arc<LanguageRegistry>,\n         cx: &mut App,\n     ) -> Entity<Self> {\n-        let subsc\n+        let _language_subscription = cx.subscribe(\n+            &languages,\n+            |this, _, event, _| {\n+                if event == &LanguageRegistryEvent::Changed {\n+                    this.restart_language_servers(cx);\n+                }\n+            },\n+        );\n         cx.new(|cx| Self {\n             _subscriptions: cx.subscribe(\n                 &project_tree,\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -144,14 +144,7 @@\n         languages: Arc<LanguageRegistry>,\n         cx: &mut App,\n     ) -> Entity<Self> {\n-        let _language_subscription = cx.subscribe(\n-            &languages,\n-            |this, _, event, _| {\n-                if event == &LanguageRegistryEvent::Changed {\n-                    this.restart_language_servers(cx);\n-                }\n-            },\n-        );\n+        let _language_subscription = languages.subscribe();\n         cx.new(|cx| Self {\n             _subscriptions: cx.subscribe(\n                 &project_tree,\n\n```\n\nUser edited \"crates/project/src/project_tree/server_tree.rs\":\n```diff\n@@ -156,6 +156,7 @@\n             instances: Default::default(),\n             attach_kind_cache: Default::default(),\n             languages,\n+            _language_subscription,\n         })\n     }\n     /// Memoize calls to attach_kind on LspAdapter (which might be a WASM extension, thus ~expensive to call).\n\n```\n\n### Input:\n```crates/project/src/project_tree/server_tree.rs\n<|start_of_file|>\n<|editable_region_start|>\n//! This module defines an LSP Tree.\n//!\n//! An LSP Tree is responsible for determining which language servers apply to a given project path.\n//!\n//! ## RPC\n//! LSP Tree is transparent to RPC peers; when clients ask host to spawn a new language server, the host will perform LSP Tree lookup for provided path; it may decide\n//! to reuse existing language server. The client maintains it's own LSP Tree that is a subset of host LSP Tree. Done this way, the client does not need to\n//! ask about suitable language server for each path it interacts with; it can resolve most of the queries locally.\n//! This module defines a Project Tree.\n\nuse std::{\n    collections::{BTreeMap, BTreeSet},\n    path::Path,\n    sync::{Arc, Weak},\n};\n\nuse collections::{HashMap, IndexMap};\nuse gpui::{App, AppContext, Entity, Subscription};\nuse itertools::Itertools;\nuse language::{\n    language_settings::AllLanguageSettings, Attach, LanguageName, LanguageRegistry,\n    LspAdapterDelegate,\n};\nuse lsp::LanguageServerName;\nuse once_cell::sync::OnceCell;\nuse settings::{Settings, SettingsLocation, WorktreeId};\nuse util::maybe;\n\nuse crate::{project_settings::LspSettings, LanguageServerId, ProjectPath};\n\nuse super::{AdapterWrapper, ProjectTree, ProjectTreeEvent};\n\n#[derive(Debug, Default)]\nstruct ServersForWorktree {\n    roots: BTreeMap<\n        Arc<Path>,\n        BTreeMap<LanguageServerName, (Arc<InnerTreeNode>, BTreeSet<LanguageName>)>,\n    >,\n}\n\npub struct LanguageServerTree {\n    project_tree: Entity<ProjectTree>,\n    instances: BTreeMap<WorktreeId, ServersForWorktree>,\n    attach_kind_cache: HashMap<LanguageServerName, Attach>,\n    languages: Arc<LanguageRegistry>,\n    _subscriptions: Subscription,\n    _language_subscription: watch::<|user_cursor_is_here|>,\n}\n\n/// A node in language server tree represents either:\n/// - A language server that has already been initialized/updated for a given project\n/// - A soon-to-be-initialized language server.\n#[derive(Clone)]\npub(crate) struct LanguageServerTreeNode(Weak<InnerTreeNode>);\n\n/// Describes a request to launch a language server.\n#[derive(Debug)]\npub(crate) struct LaunchDisposition<'a> {\n    pub(crate) server_name: &'a LanguageServerName,\n    pub(crate) attach: Attach,\n    pub(crate) path: ProjectPath,\n    pub(crate) settings: Arc<LspSettings>,\n}\n\nimpl<'a> From<&'a InnerTreeNode> for LaunchDisposition<'a> {\n    fn from(value: &'a InnerTreeNode) -> Self {\n        LaunchDisposition {\n            server_name: &value.name,\n            attach: value.attach,\n            path: value.path.clone(),\n            settings: value.settings.clone(),\n        }\n    }\n}\nimpl LanguageServerTreeNode {\n    /// Returns a language server ID for this node if there is one.\n    /// Returns None if this node has not been initialized yet or it is no longer in the tree.\n    pub(crate) fn server_id(&self) -> Option<LanguageServerId> {\n        self.0.upgrade()?.id.get().copied()\n    }\n    /// Returns a language server ID for this node if it has already been initialized; otherwise runs the provided closure to initialize the language server node in a tree.\n    /// May return None if the node no longer belongs to the server tree it was created in.\n    pub(crate) fn server_id_or_init(\n        &self,\n        init: impl FnOnce(LaunchDisposition) -> LanguageServerId,\n    ) -> Option<LanguageServerId> {\n        self.server_id_or_try_init(|disposition| Ok(init(disposition)))\n    }\n    fn server_id_or_try_init(\n        &self,\n        init: impl FnOnce(LaunchDisposition) -> Result<LanguageServerId, ()>,\n    ) -> Option<LanguageServerId> {\n        let this = self.0.upgrade()?;\n        this.id\n            .get_or_try_init(|| init(LaunchDisposition::from(&*this)))\n            .ok()\n            .copied()\n    }\n}\n\nimpl From<Weak<InnerTreeNode>> for LanguageServerTreeNode {\n    fn from(weak: Weak<InnerTreeNode>) -> Self {\n        LanguageServerTreeNode(weak)\n    }\n}\n\n#[derive(Debug)]\nstruct InnerTreeNode {\n    id: OnceCell<LanguageServerId>,\n<|editable_region_end|>\nstruct InnerTreeNode {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/project/src/project_tree/server_tree.rs\n<|start_of_file|>\n<|editable_region_start|>\n//! This module defines an LSP Tree.\n//!\n//! An LSP Tree is responsible for determining which language servers apply to a given project path.\n//!\n//! ## RPC\n//! LSP Tree is transparent to RPC peers; when clients ask host to spawn a new language server, the host will perform LSP Tree lookup for provided path; it may decide\n//! to reuse existing language server. The client maintains it's own LSP Tree that is a subset of host LSP Tree. Done this way, the client does not need to\n//! ask about suitable language server for each path it interacts with; it can resolve most of the queries locally.\n//! This module defines a Project Tree.\n\nuse std::{\n    collections::{BTreeMap, BTreeSet},\n    path::Path,\n    sync::{Arc, Weak},\n};\n\nuse collections::{HashMap, IndexMap};\nuse gpui::{App, AppContext, Entity, Subscription};\nuse itertools::Itertools;\nuse language::{\n    language_settings::AllLanguageSettings, Attach, LanguageName, LanguageRegistry,\n    LspAdapterDelegate,\n};\nuse lsp::LanguageServerName;\nuse once_cell::sync::OnceCell;\nuse settings::{Settings, SettingsLocation, WorktreeId};\nuse util::maybe;\n\nuse crate::{project_settings::LspSettings, LanguageServerId, ProjectPath};\n\nuse super::{AdapterWrapper, ProjectTree, ProjectTreeEvent};\n\n#[derive(Debug, Default)]\nstruct ServersForWorktree {\n    roots: BTreeMap<\n        Arc<Path>,\n        BTreeMap<LanguageServerName, (Arc<InnerTreeNode>, BTreeSet<LanguageName>)>,\n    >,\n}\n\npub struct LanguageServerTree {\n    project_tree: Entity<ProjectTree>,\n    instances: BTreeMap<WorktreeId, ServersForWorktree>,\n    attach_kind_cache: HashMap<LanguageServerName, Attach>,\n    languages: Arc<LanguageRegistry>,\n    _subscriptions: Subscription,\n    _language_subscription: watch::<|user_cursor_is_here|>,\n}\n\n/// A node in language server tree represents either:\n/// - A language server that has already been initialized/updated for a given project\n/// - A soon-to-be-initialized language server.\n#[derive(Clone)]\npub(crate) struct LanguageServerTreeNode(Weak<InnerTreeNode>);\n\n/// Describes a request to launch a language server.\n#[derive(Debug)]\npub(crate) struct LaunchDisposition<'a> {\n    pub(crate) server_name: &'a LanguageServerName,\n    pub(crate) attach: Attach,\n    pub(crate) path: ProjectPath,\n    pub(crate) settings: Arc<LspSettings>,\n}\n\nimpl<'a> From<&'a InnerTreeNode> for LaunchDisposition<'a> {\n    fn from(value: &'a InnerTreeNode) -> Self {\n        LaunchDisposition {\n            server_name: &value.name,\n            attach: value.attach,\n            path: value.path.clone(),\n            settings: value.settings.clone(),\n        }\n    }\n}\nimpl LanguageServerTreeNode {\n    /// Returns a language server ID for this node if there is one.\n    /// Returns None if this node has not been initialized yet or it is no longer in the tree.\n    pub(crate) fn server_id(&self) -> Option<LanguageServerId> {\n        self.0.upgrade()?.id.get().copied()\n    }\n    /// Returns a language server ID for this node if it has already been initialized; otherwise runs the provided closure to initialize the language server node in a tree.\n    /// May return None if the node no longer belongs to the server tree it was created in.\n    pub(crate) fn server_id_or_init(\n        &self,\n        init: impl FnOnce(LaunchDisposition) -> LanguageServerId,\n    ) -> Option<LanguageServerId> {\n        self.server_id_or_try_init(|disposition| Ok(init(disposition)))\n    }\n    fn server_id_or_try_init(\n        &self,\n        init: impl FnOnce(LaunchDisposition) -> Result<LanguageServerId, ()>,\n    ) -> Option<LanguageServerId> {\n        let this = self.0.upgrade()?;\n        this.id\n            .get_or_try_init(|| init(LaunchDisposition::from(&*this)))\n            .ok()\n            .copied()\n    }\n}\n\nimpl From<Weak<InnerTreeNode>> for LanguageServerTreeNode {\n    fn from(weak: Weak<InnerTreeNode>) -> Self {\n        LanguageServerTreeNode(weak)\n    }\n}\n\n#[derive(Debug)]\nstruct InnerTreeNode {\n    id: OnceCell<LanguageServerId>,\n<|editable_region_end|>\nstruct InnerTreeNode {\n```"
  },
  "max_tokens": 1024
}