{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -215,7 +215,7 @@\n                     })\n                 }\n                 CompletionKind::Function => {\n-                    if let Some(label) = format_function(&completion) {\n+                    if let Some(label) = format_function(&completion, true) {\n                         return Some(label);\n                     }\n                 }\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -225,7 +225,7 @@\n                         .as_ref()\n                         .map_or(false, |detail| detail.starts_with(\"fn \"))\n                     {\n-                        if let Some(label) = format_function(&completion) {\n+                        if let Some(label) = format_function(&completion, false) {\n                             return Some(label);\n                         }\n                     }\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -183,7 +183,6 @@\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n-            let start = \"fn \".len() as u32;\n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -183,6 +183,7 @@\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n+            let start = \"fn \".len() as u32;\n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -183,7 +183,7 @@\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n-            let start = \"fn \".len() as u32;\n+            let start = if \"fn \".len() as u32;\n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -183,7 +183,8 @@\n             let details = completion.label_details.as_ref()?;\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n-            let start = if \"fn \".len() as u32;\n+            let start = if add_fn_prefix {\n+                \"fn \".len() as u32;\n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -184,7 +184,10 @@\n             let (detail, description) =\n                 details.detail.as_ref().zip(details.description.as_ref())?;\n             let start = if add_fn_prefix {\n-                \"fn \".len() as u32;\n+                \"fn \".len() as u32\n+            } else {\n+                0\n+            };\n             let (spans, code) = {\n                 let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                 let code_label = format!(\"{}{} {}\", completion.label, detail, description);\n\n```\n\nUser edited \"extensions/zig/src/zig.rs\":\n```diff\n@@ -199,7 +199,7 @@\n                 spans,\n                 filter_range: Range {\n                     0,\n-                    end: completion_len as u32,\n+                    end: start + completion_len as u32,\n                 },\n             });\n         }\n\n```\n\n### Input:\n```extensions/zig/src/zig.rs\n            args,\n<|editable_region_start|>\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion, add_fn_prefix: bool) -> Option<zed_extension_api::CodeLabel> {\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n            let start = if add_fn_prefix {\n                \"fn \".len() as u32\n            } else {\n                0\n            };\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                let code_label = if add_fn_prefix {\n                    \n                } else {<|user_cursor_is_here|>} format!(\"{}{} {}\", completion.label, detail, description);\n                (vec![CodeLabelSpan::literal(code.clone(), None)], code_label)\n            };\n\n            return Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    0,\n                    end: start + completion_len as u32,\n                },\n            });\n        }\n        if let Some(kind) = completion.kind {\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion, true) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Struct => {\n                    if completion\n                        .detail\n                        .as_ref()\n                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                    {\n                        if let Some(label) = format_function(&completion, false) {\n                            return Some(label);\n                        }\n                    }\n                }\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n            spans: vec![],\n            filter_range: Range {\n                start: 0,\n                end: completion_len as u32,\n            },\n        })\n    }\n}\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```extensions/zig/src/zig.rs\n            args,\n<|editable_region_start|>\n            environment,\n        })\n    }\n}\n\nimpl zed::Extension for ZigExtension {\n    fn new() -> Self {\n        Self {\n            cached_binary_path: None,\n        }\n    }\n\n    fn language_server_command(\n        &mut self,\n        language_server_id: &LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<zed::Command> {\n        let zls_binary = self.language_server_binary(language_server_id, worktree)?;\n        Ok(zed::Command {\n            command: zls_binary.path,\n            args: zls_binary.args.unwrap_or_default(),\n            env: zls_binary.environment.unwrap_or_default(),\n        })\n    }\n\n    fn language_server_workspace_configuration(\n        &mut self,\n        _language_server_id: &zed::LanguageServerId,\n        worktree: &zed::Worktree,\n    ) -> Result<Option<serde_json::Value>> {\n        let settings = LspSettings::for_worktree(\"zls\", worktree)\n            .ok()\n            .and_then(|lsp_settings| lsp_settings.settings.clone())\n            .unwrap_or_default();\n        Ok(Some(settings))\n    }\n    fn label_for_completion(\n        &self,\n        _language_server_id: &LanguageServerId,\n        completion: Completion,\n    ) -> Option<zed_extension_api::CodeLabel> {\n        let completion_len = completion.label.len();\n        fn format_function(completion: &Completion, add_fn_prefix: bool) -> Option<zed_extension_api::CodeLabel> {\n            let completion_len = completion.label.len();\n            let details = completion.label_details.as_ref()?;\n            let (detail, description) =\n                details.detail.as_ref().zip(details.description.as_ref())?;\n            let start = if add_fn_prefix {\n                \"fn \".len() as u32\n            } else {\n                0\n            };\n            let (spans, code) = {\n                let code = format!(\"fn {}{} {}\", completion.label, detail, description);\n                let code_label = if add_fn_prefix {\n                    \n                } else {<|user_cursor_is_here|>} format!(\"{}{} {}\", completion.label, detail, description);\n                (vec![CodeLabelSpan::literal(code.clone(), None)], code_label)\n            };\n\n            return Some(zed_extension_api::CodeLabel {\n                code,\n                spans,\n                filter_range: Range {\n                    0,\n                    end: start + completion_len as u32,\n                },\n            });\n        }\n        if let Some(kind) = completion.kind {\n            match kind {\n                CompletionKind::Keyword => {\n                    return Some(zed_extension_api::CodeLabel {\n                        spans: vec![CodeLabelSpan::literal(\n                            completion.label.clone(),\n                            Some(\"keyword\".into()),\n                        )],\n                        code: completion.label,\n                        filter_range: Range {\n                            start: 0,\n                            end: completion_len as u32,\n                        },\n                    })\n                }\n                CompletionKind::Function => {\n                    if let Some(label) = format_function(&completion, true) {\n                        return Some(label);\n                    }\n                }\n                CompletionKind::Struct => {\n                    if completion\n                        .detail\n                        .as_ref()\n                        .map_or(false, |detail| detail.starts_with(\"fn \"))\n                    {\n                        if let Some(label) = format_function(&completion, false) {\n                            return Some(label);\n                        }\n                    }\n                }\n\n                _ => {}\n            }\n        }\n        Some(zed_extension_api::CodeLabel {\n            code: completion.label,\n            spans: vec![],\n            filter_range: Range {\n                start: 0,\n                end: completion_len as u32,\n            },\n        })\n    }\n}\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}