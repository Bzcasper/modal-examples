{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\n\n\n### Input:\n```src/apprt/embedded.zig\n<|editable_region_start|>\n<|user_cursor_is_here|>//! Application runtime for the embedded version of Ghostty. The embedded\n//! version is when Ghostty is embedded within a parent host application,\n//! rather than owning the application lifecycle itself. This is used for\n//! example for the macOS build of Ghostty so that we can use a native\n//! Swift+XCode-based application.\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst assert = std.debug.assert;\nconst Allocator = std.mem.Allocator;\nconst objc = @import(\"objc\");\nconst apprt = @import(\"../apprt.zig\");\nconst font = @import(\"../font/main.zig\");\nconst input = @import(\"../input.zig\");\nconst renderer = @import(\"../renderer.zig\");\nconst terminal = @import(\"../terminal/main.zig\");\nconst CoreApp = @import(\"../App.zig\");\nconst CoreInspector = @import(\"../inspector/main.zig\").Inspector;\nconst CoreSurface = @import(\"../Surface.zig\");\nconst configpkg = @import(\"../config.zig\");\nconst Config = configpkg.Config;\n\nconst log = std.log.scoped(.embedded_window);\n\npub const App = struct {\n    /// Because we only expect the embedding API to be used in embedded\n    /// environments, the options are extern so that we can expose it\n    /// directly to a C callconv and not pay for any translation costs.\n    ///\n    /// C type: ghostty_runtime_config_s\n    pub const Options = extern struct {\n        /// These are just aliases to make the function signatures below\n        /// more obvious what values will be sent.\n        const AppUD = ?*anyopaque;\n        const SurfaceUD = ?*anyopaque;\n\n        /// Userdata that is passed to all the callbacks.\n        userdata: AppUD = null,\n\n        /// True if the selection clipboard is supported.\n        supports_selection_clipboard: bool = false,\n\n        /// Callback called to wakeup the event loop. This should trigger\n        /// a full tick of the app loop.\n        wakeup: *const fn (AppUD) callconv(.C) void,\n\n        /// Callback called to handle an action.\n        action: *const fn (*App, apprt.Target.C, apprt.Action.C) callconv(.C) void,\n\n        /// Read the clipboard value. The return value must be preserved\n        /// by the host until the next call. If there is no valid clipboard\n        /// value then this should return null.\n        read_clipboard: *const fn (SurfaceUD, c_int, *apprt.ClipboardRequest) callconv(.C) void,\n\n        /// This may be called after a read clipboard call to request\n        /// confirmation that the clipboard value is safe to read. The embedder\n        /// must call complete_clipboard_request with the given request.\n        confirm_read_clipboard: *const fn (\n            SurfaceUD,\n            [*:0]const u8,\n            *apprt.ClipboardRequest,\n            apprt.ClipboardRequestType,\n        ) callconv(.C) void,\n\n        /// Write the clipboard value.\n        write_clipboard: *const fn (SurfaceUD, [*:0]const u8, c_int, bool) callconv(.C) void,\n\n        /// Close the current surface given by this function.\n        close_surface: ?*const fn (SurfaceUD, bool) callconv(.C) void = null,\n    };\n\n    /// This is the key event sent for ghostty_surface_key and\n    /// ghostty_app_key.\n    pub const KeyEvent = struct {\n        /// The three below are absolutely required.\n        action: input.Action,\n        mods: input.Mods,\n        keycode: u32,\n\n        /// Optionally, the embedder can handle text translation and send\n        /// the text value here. If text is non-nil, it is assumed that the\n        /// embedder also handles dead key states and sets composing as necessary.\n        text: ?[:0]const u8,\n        composing: bool,\n    };\n\n    core_app: *CoreApp,\n    opts: Options,\n    keymap: input.Keymap,\n\n    /// The configuration for the app. This is owned by this structure.\n    config: Config,\n\n    /// The keymap state is used for global keybinds only. Each surface\n    /// also has its own keymap state for focused keybinds.\n    keymap_state: input.Keymap.State,\n\n    pub fn init(\n        core_app: *CoreApp,\n        config: *const Config,\n        opts: Options,\n<|editable_region_end|>\n        config: *const Config,\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```src/apprt/embedded.zig\n<|editable_region_start|>\n<|user_cursor_is_here|>//! Application runtime for the embedded version of Ghostty. The embedded\n//! version is when Ghostty is embedded within a parent host application,\n//! rather than owning the application lifecycle itself. This is used for\n//! example for the macOS build of Ghostty so that we can use a native\n//! Swift+XCode-based application.\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst assert = std.debug.assert;\nconst Allocator = std.mem.Allocator;\nconst objc = @import(\"objc\");\nconst apprt = @import(\"../apprt.zig\");\nconst font = @import(\"../font/main.zig\");\nconst input = @import(\"../input.zig\");\nconst renderer = @import(\"../renderer.zig\");\nconst terminal = @import(\"../terminal/main.zig\");\nconst CoreApp = @import(\"../App.zig\");\nconst CoreInspector = @import(\"../inspector/main.zig\").Inspector;\nconst CoreSurface = @import(\"../Surface.zig\");\nconst configpkg = @import(\"../config.zig\");\nconst Config = configpkg.Config;\n\nconst log = std.log.scoped(.embedded_window);\n\npub const App = struct {\n    /// Because we only expect the embedding API to be used in embedded\n    /// environments, the options are extern so that we can expose it\n    /// directly to a C callconv and not pay for any translation costs.\n    ///\n    /// C type: ghostty_runtime_config_s\n    pub const Options = extern struct {\n        /// These are just aliases to make the function signatures below\n        /// more obvious what values will be sent.\n        const AppUD = ?*anyopaque;\n        const SurfaceUD = ?*anyopaque;\n\n        /// Userdata that is passed to all the callbacks.\n        userdata: AppUD = null,\n\n        /// True if the selection clipboard is supported.\n        supports_selection_clipboard: bool = false,\n\n        /// Callback called to wakeup the event loop. This should trigger\n        /// a full tick of the app loop.\n        wakeup: *const fn (AppUD) callconv(.C) void,\n\n        /// Callback called to handle an action.\n        action: *const fn (*App, apprt.Target.C, apprt.Action.C) callconv(.C) void,\n\n        /// Read the clipboard value. The return value must be preserved\n        /// by the host until the next call. If there is no valid clipboard\n        /// value then this should return null.\n        read_clipboard: *const fn (SurfaceUD, c_int, *apprt.ClipboardRequest) callconv(.C) void,\n\n        /// This may be called after a read clipboard call to request\n        /// confirmation that the clipboard value is safe to read. The embedder\n        /// must call complete_clipboard_request with the given request.\n        confirm_read_clipboard: *const fn (\n            SurfaceUD,\n            [*:0]const u8,\n            *apprt.ClipboardRequest,\n            apprt.ClipboardRequestType,\n        ) callconv(.C) void,\n\n        /// Write the clipboard value.\n        write_clipboard: *const fn (SurfaceUD, [*:0]const u8, c_int, bool) callconv(.C) void,\n\n        /// Close the current surface given by this function.\n        close_surface: ?*const fn (SurfaceUD, bool) callconv(.C) void = null,\n    };\n\n    /// This is the key event sent for ghostty_surface_key and\n    /// ghostty_app_key.\n    pub const KeyEvent = struct {\n        /// The three below are absolutely required.\n        action: input.Action,\n        mods: input.Mods,\n        keycode: u32,\n\n        /// Optionally, the embedder can handle text translation and send\n        /// the text value here. If text is non-nil, it is assumed that the\n        /// embedder also handles dead key states and sets composing as necessary.\n        text: ?[:0]const u8,\n        composing: bool,\n    };\n\n    core_app: *CoreApp,\n    opts: Options,\n    keymap: input.Keymap,\n\n    /// The configuration for the app. This is owned by this structure.\n    config: Config,\n\n    /// The keymap state is used for global keybinds only. Each surface\n    /// also has its own keymap state for focused keybinds.\n    keymap_state: input.Keymap.State,\n\n    pub fn init(\n        core_app: *CoreApp,\n        config: *const Config,\n        opts: Options,\n<|editable_region_end|>\n        config: *const Config,\n```"
  },
  "max_tokens": 1024
}