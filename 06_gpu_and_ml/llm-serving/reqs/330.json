{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11385,7 +11385,7 @@\n                 assert_eq!(\n                     completions\n                         .iter()\n-                        .map(|completion| dbg!(&completion.label).text)\n+                        .map(|completion| &dbg!(&completion.label).text)\n                         .collect::<Vec<_>>(),\n                     vec![\"method id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11374,6 +11374,7 @@\n         editor.context_menu_next(&Default::default(), window, cx);\n     });\n \n+    dbg!(\"~~~~~~~~~~~~~~~~~\");\n     cx.update_editor(|editor, _, _| {\n         let context_menu = editor.context_menu.borrow_mut();\n         let context_menu = context_menu\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11383,6 +11383,7 @@\n         match context_menu {\n             CodeContextMenu::Completions(completions_menu) => {\n                 let completions = completions_menu.completions.borrow_mut();\n+                dbg!(&completions);\n                 assert_eq!(\n                     completions\n                         .iter()\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11374,7 +11374,6 @@\n         editor.context_menu_next(&Default::default(), window, cx);\n     });\n \n-    dbg!(\"~~~~~~~~~~~~~~~~~\");\n     cx.update_editor(|editor, _, _| {\n         let context_menu = editor.context_menu.borrow_mut();\n         let context_menu = context_menu\n@@ -11383,7 +11382,6 @@\n         match context_menu {\n             CodeContextMenu::Completions(completions_menu) => {\n                 let completions = completions_menu.completions.borrow_mut();\n-                dbg!(&completions);\n                 assert_eq!(\n                     completions\n                         .iter()\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11385,7 +11385,7 @@\n                 assert_eq!(\n                     completions\n                         .iter()\n-                        .map(|completion| &dbg!(&completion.label).text)\n+                        .map(|completion| &completion.label.text)\n                         .collect::<Vec<_>>(),\n                     vec![\"method id()\", \"other\"],\n                     \"Should update first completion label, but not second as the filter text did not match.\"\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1795,7 +1795,6 @@\n         } else {\n             label.clone()\n         };\n-        dbg!((&label, &text));\n         Self {\n             text,\n             runs,\n\n```\n\nUser edited \"crates/project/src/lsp_store.rs\":\n```diff\n@@ -4397,7 +4397,6 @@\n                 language.map(|language| language.as_ref()),\n             )\n         });\n-        dbg!(&new_label);\n         ensure_uniform_list_compatible_label(&mut new_label);\n \n         let mut completions = completions.borrow_mut();\n\n```\n\nUser edited \"crates/editor/src/editor_tests.rs\":\n```diff\n@@ -11282,7 +11282,7 @@\n     cx.simulate_keystroke(\".\");\n \n     let item1 = lsp::CompletionItem {\n-        label: \"id\".to_string(),\n+        label: \"mid\".to_string(),\n         filter_text: Some(\"id\".to_string()),\n         detail: None,\n         documentation: None,\n\n```\n\n### Input:\n```crates/editor/src/editor_tests.rs\n        }]),\n<|editable_region_start|>\n        ..Default::default()\n    };\n\n    let closure_completion_item = completion_item.clone();\n    let mut request = cx.handle_request::<lsp::request::Completion, _, _>(move |_, _, _| {\n        let task_completion_item = closure_completion_item.clone();\n        async move {\n            Ok(Some(lsp::CompletionResponse::Array(vec![\n                task_completion_item,\n            ])))\n        }\n    });\n\n    request.next().await;\n\n    cx.condition(|editor, _| editor.context_menu_visible())\n        .await;\n    let apply_additional_edits = cx.update_editor(|editor, window, cx| {\n        editor\n            .confirm_completion(&ConfirmCompletion::default(), window, cx)\n            .unwrap()\n    });\n    cx.assert_editor_state(indoc! {\"fn main() { let a = 2.Some(2)ˇ; }\"});\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>(move |_, _, _| {\n        let task_completion_item = completion_item.clone();\n        async move { Ok(task_completion_item) }\n    })\n    .next()\n    .await\n    .unwrap();\n    apply_additional_edits.await.unwrap();\n    cx.assert_editor_state(indoc! {\"fn main() { let a = Some(2)ˇ; }\"});\n}\n\n#[gpui::test]\nasync fn test_completions_resolve_updates_labels_if_filter_text_matches(\n    cx: &mut gpui::TestAppContext,\n) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            completion_provider: Some(lsp::CompletionOptions {\n                trigger_characters: Some(vec![\".\".to_string()]),\n                resolve_provider: Some(true),\n                ..Default::default()\n            }),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {\"fn main() { let a = 2ˇ; }\"});\n    cx.simulate_keystroke(\".\");\n\n    let item1 = lsp::CompletionItem {\n        label: \"m<|user_cursor_is_here|>id\".to_string(),\n        filter_text: Some(\"id\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".id\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n\n    let item2 = lsp::CompletionItem {\n        label: \"other\".to_string(),\n        filter_text: Some(\"other\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".other\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n\n    let item1 = item1.clone();\n    cx.handle_request::<lsp::request::Completion, _, _>({\n        let item1 = item1.clone();\n        move |_, _, _| {\n            let item1 = item1.clone();\n            let item2 = item2.clone();\n            async move { Ok(Some(lsp::CompletionResponse::Array(vec![item1, item2]))) }\n        }\n    })\n    .next()\n    .await;\n\n    cx.condition(|editor, _| editor.context_menu_visible())\n        .await;\n    cx.update_editor(|editor, _, _| {\n        let context_menu = editor.context_menu.borrow_mut();\n        let context_menu = context_menu\n            .as_ref()\n            .expect(\"Should have the context menu deployed\");\n        match context_menu {\n            CodeContextMenu::Completions(completions_menu) => {\n                let completions = completions_menu.completions.borrow_mut();\n                assert_eq!(\n                    completions\n                        .iter()\n                        .map(|completion| &completion.label.text)\n                        .collect::<Vec<_>>(),\n                    vec![\"id\", \"other\"]\n                )\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>({\n        let item1 = item1.clone();\n        move |_, item_to_resolve, _| {\n<|editable_region_end|>\n        let item1 = item1.clone();\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/editor/src/editor_tests.rs\n        }]),\n<|editable_region_start|>\n        ..Default::default()\n    };\n\n    let closure_completion_item = completion_item.clone();\n    let mut request = cx.handle_request::<lsp::request::Completion, _, _>(move |_, _, _| {\n        let task_completion_item = closure_completion_item.clone();\n        async move {\n            Ok(Some(lsp::CompletionResponse::Array(vec![\n                task_completion_item,\n            ])))\n        }\n    });\n\n    request.next().await;\n\n    cx.condition(|editor, _| editor.context_menu_visible())\n        .await;\n    let apply_additional_edits = cx.update_editor(|editor, window, cx| {\n        editor\n            .confirm_completion(&ConfirmCompletion::default(), window, cx)\n            .unwrap()\n    });\n    cx.assert_editor_state(indoc! {\"fn main() { let a = 2.Some(2)ˇ; }\"});\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>(move |_, _, _| {\n        let task_completion_item = completion_item.clone();\n        async move { Ok(task_completion_item) }\n    })\n    .next()\n    .await\n    .unwrap();\n    apply_additional_edits.await.unwrap();\n    cx.assert_editor_state(indoc! {\"fn main() { let a = Some(2)ˇ; }\"});\n}\n\n#[gpui::test]\nasync fn test_completions_resolve_updates_labels_if_filter_text_matches(\n    cx: &mut gpui::TestAppContext,\n) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            completion_provider: Some(lsp::CompletionOptions {\n                trigger_characters: Some(vec![\".\".to_string()]),\n                resolve_provider: Some(true),\n                ..Default::default()\n            }),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {\"fn main() { let a = 2ˇ; }\"});\n    cx.simulate_keystroke(\".\");\n\n    let item1 = lsp::CompletionItem {\n        label: \"m<|user_cursor_is_here|>id\".to_string(),\n        filter_text: Some(\"id\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".id\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n\n    let item2 = lsp::CompletionItem {\n        label: \"other\".to_string(),\n        filter_text: Some(\"other\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".other\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n\n    let item1 = item1.clone();\n    cx.handle_request::<lsp::request::Completion, _, _>({\n        let item1 = item1.clone();\n        move |_, _, _| {\n            let item1 = item1.clone();\n            let item2 = item2.clone();\n            async move { Ok(Some(lsp::CompletionResponse::Array(vec![item1, item2]))) }\n        }\n    })\n    .next()\n    .await;\n\n    cx.condition(|editor, _| editor.context_menu_visible())\n        .await;\n    cx.update_editor(|editor, _, _| {\n        let context_menu = editor.context_menu.borrow_mut();\n        let context_menu = context_menu\n            .as_ref()\n            .expect(\"Should have the context menu deployed\");\n        match context_menu {\n            CodeContextMenu::Completions(completions_menu) => {\n                let completions = completions_menu.completions.borrow_mut();\n                assert_eq!(\n                    completions\n                        .iter()\n                        .map(|completion| &completion.label.text)\n                        .collect::<Vec<_>>(),\n                    vec![\"id\", \"other\"]\n                )\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>({\n        let item1 = item1.clone();\n        move |_, item_to_resolve, _| {\n<|editable_region_end|>\n        let item1 = item1.clone();\n```"
  },
  "max_tokens": 1024
}