{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1791,7 +1791,7 @@\n             .as_ref()\n             .and_then(|label_details| label_details.description.as_ref())\n         {\n-            dbg!(descri)\n+            dbg!(description);\n             format!(\"{label} {description}\")\n         } else {\n             label.clone()\n\n```\n\nUser edited \"src/terminal/size.zig\":\n```diff\n@@ -19,6 +19,7 @@\n ///\n /// This is a packed struct so we can attach methods to an int.\n pub fn Offset(comptime T: type) type {\n+    std.\n     return packed struct(OffsetInt) {\n         const Self = @This();\n \n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-\n+Fall back \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,5 @@\n Fall back \n+\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-Fall back \n+Fall back to completions, using more LSP data to generate the labels\n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-Fall back to completions, using more LSP data to generate the labels\n+Use more LSP data when falling back to \n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-Use more LSP data when falling back to \n+Use more LSP data when falling back \n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,5 @@\n-Use more LSP data when falling back \n+Use more LSP data when falling back to regular completions label\n+\n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,6 +1,5 @@\n Use more LSP data when falling back to regular completions label\n \n-\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,3 +1,4 @@\n+Cargo fmt\n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1784,7 +1784,7 @@\n         let runs = highlight_id\n             .map(|highlight_id| vec![(0..label_length, highlight_id)])\n             .unwrap_or_default();\n-        let text = if let Some(detail) = dbg!(&item.detail) {\n+        let text = if let Some(detail) = &item.detail {\n             format!(\"{label} {detail}\")\n         } else if let Some(description) = item\n             .label_details\n\n```\n\nUser edited \"crates/language/src/language.rs\":\n```diff\n@@ -1791,7 +1791,6 @@\n             .as_ref()\n             .and_then(|label_details| label_details.description.as_ref())\n         {\n-            dbg!(description);\n             format!(\"{label} {description}\")\n         } else {\n             label.clone()\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-Cargo fmt\n+Style fixes\n \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n\n```\n\n### Input:\n```crates/editor/src/editor_tests.rs\n                )\n<|editable_region_start|>\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>({\n        let item1 = item1.clone();\n        move |_, item_to_resolve, _| {\n            let item1 = item1.clone();\n            async move {\n                if item1 == item_to_resolve {\n                    Ok(lsp::CompletionItem {\n                        label: \"method id()\".to_string(),\n                        filter_text: Some(\"id\".to_string()),\n                        detail: Some(\"Now resolved!\".to_string()),\n                        documentation: Some(lsp::Documentation::String(\"Docs\".to_string())),\n                        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n                            range: lsp::Range::new(\n                                lsp::Position::new(0, 22),\n                                lsp::Position::new(0, 22),\n                            ),\n                            new_text: \".id\".to_string(),\n                        })),\n                        ..lsp::CompletionItem::default()\n                    })\n                } else {\n                    Ok(item_to_resolve)\n                }\n            }\n        }\n    })\n    .next()\n    .await\n    .unwrap();\n    cx.run_until_parked();\n\n    cx.update_editor(|editor, window, cx| {\n        editor.context_menu_next(&Default::default(), window, cx);\n    });\n\n    cx.update_editor(|editor, _, _| {\n        let context_menu = editor.context_menu.borrow_mut();\n        let context_menu = context_menu\n            .as_ref()\n            .expect(\"Should have the context menu deployed\");\n        match context_menu {\n            CodeContextMenu::Completions(completions_menu) => {\n                let completions = completions_menu.completions.borrow_mut();\n                assert_eq!(\n                    completions\n                        .iter()\n                        .map(|completion| &completion.label.text)\n                        .collect::<Vec<_>>(),\n                    vec![\"id<|user_cursor_is_here|>\", \"other\"],\n                    \"Should update first completion label, but not second as the filter text did not match.\"\n                );\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_completions_resolve_happens_once(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            completion_provider: Some(lsp::CompletionOptions {\n                trigger_characters: Some(vec![\".\".to_string()]),\n                resolve_provider: Some(true),\n                ..Default::default()\n            }),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {\"fn main() { let a = 2ˇ; }\"});\n    cx.simulate_keystroke(\".\");\n\n    let unresolved_item_1 = lsp::CompletionItem {\n        label: \"id\".to_string(),\n        filter_text: Some(\"id\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".id\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n    let resolved_item_1 = lsp::CompletionItem {\n        additional_text_edits: Some(vec![lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 20), lsp::Position::new(0, 22)),\n            new_text: \"!!\".to_string(),\n        }]),\n        ..unresolved_item_1.clone()\n    };\n    let unresolved_item_2 = lsp::CompletionItem {\n        label: \"other\".to_string(),\n        filter_text: Some(\"other\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n<|editable_region_end|>\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/editor/src/editor_tests.rs\n                )\n<|editable_region_start|>\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n\n    cx.handle_request::<lsp::request::ResolveCompletionItem, _, _>({\n        let item1 = item1.clone();\n        move |_, item_to_resolve, _| {\n            let item1 = item1.clone();\n            async move {\n                if item1 == item_to_resolve {\n                    Ok(lsp::CompletionItem {\n                        label: \"method id()\".to_string(),\n                        filter_text: Some(\"id\".to_string()),\n                        detail: Some(\"Now resolved!\".to_string()),\n                        documentation: Some(lsp::Documentation::String(\"Docs\".to_string())),\n                        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n                            range: lsp::Range::new(\n                                lsp::Position::new(0, 22),\n                                lsp::Position::new(0, 22),\n                            ),\n                            new_text: \".id\".to_string(),\n                        })),\n                        ..lsp::CompletionItem::default()\n                    })\n                } else {\n                    Ok(item_to_resolve)\n                }\n            }\n        }\n    })\n    .next()\n    .await\n    .unwrap();\n    cx.run_until_parked();\n\n    cx.update_editor(|editor, window, cx| {\n        editor.context_menu_next(&Default::default(), window, cx);\n    });\n\n    cx.update_editor(|editor, _, _| {\n        let context_menu = editor.context_menu.borrow_mut();\n        let context_menu = context_menu\n            .as_ref()\n            .expect(\"Should have the context menu deployed\");\n        match context_menu {\n            CodeContextMenu::Completions(completions_menu) => {\n                let completions = completions_menu.completions.borrow_mut();\n                assert_eq!(\n                    completions\n                        .iter()\n                        .map(|completion| &completion.label.text)\n                        .collect::<Vec<_>>(),\n                    vec![\"id<|user_cursor_is_here|>\", \"other\"],\n                    \"Should update first completion label, but not second as the filter text did not match.\"\n                );\n            }\n            CodeContextMenu::CodeActions(_) => panic!(\"Should show the completions menu\"),\n        }\n    });\n}\n\n#[gpui::test]\nasync fn test_completions_resolve_happens_once(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorLspTestContext::new_rust(\n        lsp::ServerCapabilities {\n            completion_provider: Some(lsp::CompletionOptions {\n                trigger_characters: Some(vec![\".\".to_string()]),\n                resolve_provider: Some(true),\n                ..Default::default()\n            }),\n            ..Default::default()\n        },\n        cx,\n    )\n    .await;\n\n    cx.set_state(indoc! {\"fn main() { let a = 2ˇ; }\"});\n    cx.simulate_keystroke(\".\");\n\n    let unresolved_item_1 = lsp::CompletionItem {\n        label: \"id\".to_string(),\n        filter_text: Some(\"id\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n            new_text: \".id\".to_string(),\n        })),\n        ..lsp::CompletionItem::default()\n    };\n    let resolved_item_1 = lsp::CompletionItem {\n        additional_text_edits: Some(vec![lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 20), lsp::Position::new(0, 22)),\n            new_text: \"!!\".to_string(),\n        }]),\n        ..unresolved_item_1.clone()\n    };\n    let unresolved_item_2 = lsp::CompletionItem {\n        label: \"other\".to_string(),\n        filter_text: Some(\"other\".to_string()),\n        detail: None,\n        documentation: None,\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n            range: lsp::Range::new(lsp::Position::new(0, 22), lsp::Position::new(0, 22)),\n<|editable_region_end|>\n        text_edit: Some(lsp::CompletionTextEdit::Edit(lsp::TextEdit {\n```"
  },
  "max_tokens": 1024
}