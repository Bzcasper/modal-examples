{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"crates/zeta/src/persistence.rs\":\n```diff\n@@ -10,7 +10,7 @@\n     pub static ref DB: ZetaDb<WorkspaceDb> = &[\n         sql! (\n             CREATE TABLE zeta_preferences(\n-                workree_path BLOB NOT NULL PRIMARY KEY,\n+                workrree_path BLOB NOT NULL PRIMARY KEY,\n                 accepted_data_collection INTEGER\n             ) STRICT;\n         ),\n\n```\n\nUser edited \"crates/zeta/src/persistence.rs\":\n```diff\n@@ -10,7 +10,7 @@\n     pub static ref DB: ZetaDb<WorkspaceDb> = &[\n         sql! (\n             CREATE TABLE zeta_preferences(\n-                workrree_path BLOB NOT NULL PRIMARY KEY,\n+                worktree_path BLOB NOT NULL PRIMARY KEY,\n                 accepted_data_collection INTEGER\n             ) STRICT;\n         ),\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,4 @@\n-\n+Toggle zeta data collection from \n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\nUser edited \".git/COMMIT_EDITMSG\":\n```diff\n@@ -1,4 +1,7 @@\n-Toggle zeta data collection from \n+Toggle zeta data collection from status bar button\n+\n+Co-Authored-By: Danilo <danilo@zed.dev>\n+\n # Please enter the commit message for your changes. Lines starting\n # with '#' will be ignored, and an empty message aborts the commit.\n #\n\n```\n\n\n\n\n\n\n\n\n\nUser edited \"crates/zeta/src/zeta.rs\":\n```diff\n@@ -1564,6 +1564,17 @@\n             return;\n         }\n \n+        if let Some(current_completion) = self.current_completion.as_ref() {\n+            let snapshot = buffer.read(cx).snapshot();\n+            if current_completion\n+                .completion\n+                .interpolate(&snapshot)\n+                .is_some()\n+            {\n+                return;\n+            }\n+        }\n+\n         let pending_completion_id = self.next_pending_completion_id;\n         self.next_pending_completion_id += 1;\n         let can_collect_data = self\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -5,6 +5,7 @@\n use multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\n use std::{num::NonZeroU32, ops::Range, sync::Arc};\n use text::{Point, ToOffset};\n+use \n \n use crate::{\n     editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -5,7 +5,7 @@\n use multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\n use std::{num::NonZeroU32, ops::Range, sync::Arc};\n use text::{Point, ToOffset};\n-use \n+use z\n \n use crate::{\n     editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -5,7 +5,7 @@\n use multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\n use std::{num::NonZeroU32, ops::Range, sync::Arc};\n use text::{Point, ToOffset};\n-use z\n+use \n \n use crate::{\n     editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n\n```\n\nUser edited \"crates/editor/src/inline_completion_tests.rs\":\n```diff\n@@ -5,7 +5,7 @@\n use multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\n use std::{num::NonZeroU32, ops::Range, sync::Arc};\n use text::{Point, ToOffset};\n-use \n+use z\n \n use crate::{\n     editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n\n```\n\n### Input:\n```crates/editor/src/inline_completion_tests.rs\n<|start_of_file|>\n<|editable_region_start|>\nuse gpui::{prelude::*, Entity};\nuse indoc::indoc;\nuse inline_completion::InlineCompletionProvider;\nuse language::{Language, LanguageConfig};\nuse multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\nuse std::{num::NonZeroU32, ops::Range, sync::Arc};\nuse text::{Point, ToOffset};\nuse z<|user_cursor_is_here|>\n\nuse crate::{\n    editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n};\n\n#[gpui::test]\nasync fn test_inline_completion_insert(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let absolute_zero_celsius = ˇ;\");\n\n    propose_edits(&provider, vec![(28..28, \"-273.15\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"-273.15\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let absolute_zero_celsius = -273.15ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_modification(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let pi = ˇ\\\"foo\\\";\");\n\n    propose_edits(&provider, vec![(9..14, \"3.14159\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"3.14159\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let pi = 3.14159ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_jump_button(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n\n    // Cursor is 2+ lines above the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line ˇ1\n        line 2\n        line 3\n        line\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(4, 3)..Point::new(4, 3), \" 4\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(4, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        line 1\n        line 2\n        line 3\n        linˇe\n    \"});\n\n    // Cursor is 2+ lines below the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line\n        line 2\n        line 3\n        line ˇ4\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(1, 3)..Point::new(1, 3), \" 1\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(1, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        linˇe\n        line 2\n        line 3\n        line 4\n    \"});\n}\n\n#[gpui::test]\nasync fn test_indentation(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/editor/src/inline_completion_tests.rs\n<|start_of_file|>\n<|editable_region_start|>\nuse gpui::{prelude::*, Entity};\nuse indoc::indoc;\nuse inline_completion::InlineCompletionProvider;\nuse language::{Language, LanguageConfig};\nuse multi_buffer::{Anchor, MultiBufferSnapshot, ToPoint};\nuse std::{num::NonZeroU32, ops::Range, sync::Arc};\nuse text::{Point, ToOffset};\nuse z<|user_cursor_is_here|>\n\nuse crate::{\n    editor_tests::init_test, test::editor_test_context::EditorTestContext, InlineCompletion,\n};\n\n#[gpui::test]\nasync fn test_inline_completion_insert(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let absolute_zero_celsius = ˇ;\");\n\n    propose_edits(&provider, vec![(28..28, \"-273.15\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"-273.15\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let absolute_zero_celsius = -273.15ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_modification(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n    cx.set_state(\"let pi = ˇ\\\"foo\\\";\");\n\n    propose_edits(&provider, vec![(9..14, \"3.14159\")], &mut cx);\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n\n    assert_editor_active_edit_completion(&mut cx, |_, edits| {\n        assert_eq!(edits.len(), 1);\n        assert_eq!(edits[0].1.as_str(), \"3.14159\");\n    });\n\n    accept_completion(&mut cx);\n\n    cx.assert_editor_state(\"let pi = 3.14159ˇ;\")\n}\n\n#[gpui::test]\nasync fn test_inline_completion_jump_button(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |_| {});\n\n    let mut cx = EditorTestContext::new(cx).await;\n    let provider = cx.new(|_| FakeInlineCompletionProvider::default());\n    assign_editor_completion_provider(provider.clone(), &mut cx);\n\n    // Cursor is 2+ lines above the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line ˇ1\n        line 2\n        line 3\n        line\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(4, 3)..Point::new(4, 3), \" 4\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(4, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        line 1\n        line 2\n        line 3\n        linˇe\n    \"});\n\n    // Cursor is 2+ lines below the proposed edit\n    cx.set_state(indoc! {\"\n        line 0\n        line\n        line 2\n        line 3\n        line ˇ4\n    \"});\n\n    propose_edits(\n        &provider,\n        vec![(Point::new(1, 3)..Point::new(1, 3), \" 1\")],\n        &mut cx,\n    );\n\n    cx.update_editor(|editor, window, cx| editor.update_visible_inline_completion(window, cx));\n    assert_editor_active_move_completion(&mut cx, |snapshot, move_target| {\n        assert_eq!(move_target.to_point(&snapshot), Point::new(1, 3));\n    });\n\n    // When accepting, cursor is moved to the proposed location\n    accept_completion(&mut cx);\n    cx.assert_editor_state(indoc! {\"\n        line 0\n        linˇe\n        line 2\n        line 3\n        line 4\n    \"});\n}\n\n#[gpui::test]\nasync fn test_indentation(cx: &mut gpui::TestAppContext) {\n    init_test(cx, |settings| {\n        settings.defaults.tab_size = NonZeroU32::new(4)\n    });\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}