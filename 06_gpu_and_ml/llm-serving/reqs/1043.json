{
  "temperature": 0,
  "prompt": "## Task\nBelow is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\n\n### Instruction:\nYou are a code completion assistant and your task is to analyze user edits and then rewrite an excerpt that the user provides, suggesting the appropriate edits within the excerpt, taking into account the cursor location.\n\n### Events:\nUser edited \"untitled\":\n```diff\n@@ -47,6 +47,7 @@\n   \n - Enhancements:\n   - Thanks for the idea! This is likely something we should talk through in the discussions. \n+  Thanks for the idea! It shouldn't be too hard if you want to send a PR, or I'm happy to pair on this https://cal.com/conradirwin/pairing\n   - Nice, a few people have requested something like this. We're tracking all the things we could pull from [Sublime] in a discussion,\n     (list of possible discussions, inlcuding editor specific ones: https://github.com/zed-industries/zed/discussions)\n   - This would be great! That said, I think we should hold off until we have better extension support and build it as an extension.\n\n```\n\nUser edited \"untitled\":\n```diff\n@@ -47,7 +47,7 @@\n   \n - Enhancements:\n   - Thanks for the idea! This is likely something we should talk through in the discussions. \n-  Thanks for the idea! It shouldn't be too hard if you want to send a PR, or I'm happy to pair on this https://cal.com/conradirwin/pairing\n+  - Thanks for the idea! It shouldn't be too hard if you want to send a PR, or I'm happy to pair on this https://cal.com/conradirwin/pairing\n   - Nice, a few people have requested something like this. We're tracking all the things we could pull from [Sublime] in a discussion,\n     (list of possible discussions, inlcuding editor specific ones: https://github.com/zed-industries/zed/discussions)\n   - This would be great! That said, I think we should hold off until we have better extension support and build it as an extension.\n\n```\n\n\n\n\n\nUser edited \"untitled\":\n```diff\n@@ -147,7 +147,7 @@\n - [ ] [ ] [2024 Week 52](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2024-12-29%20created%3A%3C2025-01-05%20no%3Atype)\n - [ ] [ ] [2025 Week 01](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-05%20created%3A%3C2025-01-12%20no%3Atype)\n - [ ] [ ] [2025 Week 02](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-12%20created%3A%3C2025-01-19%20no%3Atype)\n-- [ ] [@michael] [2025 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-19%20created%3A%3C2025-01-26%20no%3Atype)\n+- [ ] [@michael @ben] [2025 Week 03](https://github.com/zed-industries/zed/issues?q=state%3Aopen%20created%3A%3E%3D2025-01-19%20created%3A%3C2025-01-26%20no%3Atype)\n \n \n  \n\n```\n\n### Input:\n```crates/collab/src/tests/editor_tests.rs\n<|editable_region_start|>\n<|user_cursor_is_here|>use crate::{\n    rpc::RECONNECT_TIMEOUT,\n    tests::{rust_lang, TestServer},\n};\nuse call::ActiveCall;\nuse collections::HashMap;\nuse editor::{\n    actions::{\n        ConfirmCodeAction, ConfirmCompletion, ConfirmRename, ContextMenuFirst, Redo, Rename,\n        ToggleCodeActions, Undo,\n    },\n    test::editor_test_context::{AssertionContextManager, EditorTestContext},\n    Editor, RowInfo,\n};\nuse fs::Fs;\nuse futures::StreamExt;\nuse gpui::{TestAppContext, UpdateGlobal, VisualContext, VisualTestContext};\nuse indoc::indoc;\nuse language::{\n    language_settings::{AllLanguageSettings, InlayHintSettings},\n    FakeLspAdapter,\n};\nuse project::{\n    project_settings::{InlineBlameSettings, ProjectSettings},\n    SERVER_PROGRESS_THROTTLE_TIMEOUT,\n};\nuse recent_projects::disconnected_overlay::DisconnectedOverlay;\nuse rpc::RECEIVE_TIMEOUT;\nuse serde_json::json;\nuse settings::SettingsStore;\nuse std::{\n    ops::Range,\n    path::{Path, PathBuf},\n    sync::{\n        atomic::{self, AtomicBool, AtomicUsize},\n        Arc,\n    },\n};\nuse text::Point;\nuse workspace::{CloseIntent, Workspace};\n\n#[gpui::test(iterations = 10)]\nasync fn test_host_disconnect(\n    cx_a: &mut TestAppContext,\n    cx_b: &mut TestAppContext,\n    cx_c: &mut TestAppContext,\n) {\n    let mut server = TestServer::start(cx_a.executor()).await;\n    let client_a = server.create_client(cx_a, \"user_a\").await;\n    let client_b = server.create_client(cx_b, \"user_b\").await;\n    let client_c = server.create_client(cx_c, \"user_c\").await;\n    server\n        .create_room(&mut [(&client_a, cx_a), (&client_b, cx_b), (&client_c, cx_c)])\n        .await;\n\n    cx_b.update(editor::init);\n    cx_b.update(recent_projects::init);\n\n    client_a\n        .fs()\n        .insert_tree(\n            \"/a\",\n            json!({\n                \"a.txt\": \"a-contents\",\n                \"b.txt\": \"b-contents\",\n            }),\n        )\n        .await;\n\n    let active_call_a = cx_a.read(ActiveCall::global);\n    let (project_a, worktree_id) = client_a.build_local_project(\"/a\", cx_a).await;\n\n    let worktree_a = project_a.read_with(cx_a, |project, cx| project.worktrees(cx).next().unwrap());\n    let project_id = active_call_a\n        .update(cx_a, |call, cx| call.share_project(project_a.clone(), cx))\n        .await\n        .unwrap();\n\n    let project_b = client_b.join_remote_project(project_id, cx_b).await;\n    cx_a.background_executor.run_until_parked();\n\n    assert!(worktree_a.read_with(cx_a, |tree, _| tree.has_update_observer()));\n\n    let workspace_b = cx_b.add_window(|window, cx| {\n        Workspace::new(\n            None,\n            project_b.clone(),\n            client_b.app_state.clone(),\n            window,\n            cx,\n        )\n    });\n    let cx_b = &mut VisualTestContext::from_window(*workspace_b, cx_b);\n    let workspace_b_view = workspace_b.root(cx_b).unwrap();\n\n    let editor_b = workspace_b\n        .update(cx_b, |workspace, window, cx| {\n            workspace.open_path((worktree_id, \"b.txt\"), None, true, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n\n    //TODO: focus\n    assert!(cx_b.update_window_entity(&editor_b, |editor, window, _| editor.is_focused(window)));\n    editor_b.update_in(cx_b, |editor, window, cx| editor.insert(\"X\", window, cx));\n\n    cx_b.update(|_, cx| {\n        assert!(workspace_b_view.read(cx).is_edited());\n    });\n\n    // Drop client A's connection. Collaborators should disappear and the project should not be shown as shared.\n    server.forbid_connections();\n    server.disconnect_client(client_a.peer_id().unwrap());\n    cx_a.background_executor\n        .advance_clock(RECEIVE_TIMEOUT + RECONNECT_TIMEOUT);\n\n    project_a.read_with(cx_a, |project, _| project.collaborators().is_empty());\n\n    project_a.read_with(cx_a, |project, _| assert!(!project.is_shared()));\n\n    project_b.read_with(cx_b, |project, cx| project.is_read_only(cx));\n\n<|editable_region_end|>\n```\n\n### Response\n\n",
  "rewrite_speculation": true,
  "prediction": {
    "content": "```crates/collab/src/tests/editor_tests.rs\n<|editable_region_start|>\n<|user_cursor_is_here|>use crate::{\n    rpc::RECONNECT_TIMEOUT,\n    tests::{rust_lang, TestServer},\n};\nuse call::ActiveCall;\nuse collections::HashMap;\nuse editor::{\n    actions::{\n        ConfirmCodeAction, ConfirmCompletion, ConfirmRename, ContextMenuFirst, Redo, Rename,\n        ToggleCodeActions, Undo,\n    },\n    test::editor_test_context::{AssertionContextManager, EditorTestContext},\n    Editor, RowInfo,\n};\nuse fs::Fs;\nuse futures::StreamExt;\nuse gpui::{TestAppContext, UpdateGlobal, VisualContext, VisualTestContext};\nuse indoc::indoc;\nuse language::{\n    language_settings::{AllLanguageSettings, InlayHintSettings},\n    FakeLspAdapter,\n};\nuse project::{\n    project_settings::{InlineBlameSettings, ProjectSettings},\n    SERVER_PROGRESS_THROTTLE_TIMEOUT,\n};\nuse recent_projects::disconnected_overlay::DisconnectedOverlay;\nuse rpc::RECEIVE_TIMEOUT;\nuse serde_json::json;\nuse settings::SettingsStore;\nuse std::{\n    ops::Range,\n    path::{Path, PathBuf},\n    sync::{\n        atomic::{self, AtomicBool, AtomicUsize},\n        Arc,\n    },\n};\nuse text::Point;\nuse workspace::{CloseIntent, Workspace};\n\n#[gpui::test(iterations = 10)]\nasync fn test_host_disconnect(\n    cx_a: &mut TestAppContext,\n    cx_b: &mut TestAppContext,\n    cx_c: &mut TestAppContext,\n) {\n    let mut server = TestServer::start(cx_a.executor()).await;\n    let client_a = server.create_client(cx_a, \"user_a\").await;\n    let client_b = server.create_client(cx_b, \"user_b\").await;\n    let client_c = server.create_client(cx_c, \"user_c\").await;\n    server\n        .create_room(&mut [(&client_a, cx_a), (&client_b, cx_b), (&client_c, cx_c)])\n        .await;\n\n    cx_b.update(editor::init);\n    cx_b.update(recent_projects::init);\n\n    client_a\n        .fs()\n        .insert_tree(\n            \"/a\",\n            json!({\n                \"a.txt\": \"a-contents\",\n                \"b.txt\": \"b-contents\",\n            }),\n        )\n        .await;\n\n    let active_call_a = cx_a.read(ActiveCall::global);\n    let (project_a, worktree_id) = client_a.build_local_project(\"/a\", cx_a).await;\n\n    let worktree_a = project_a.read_with(cx_a, |project, cx| project.worktrees(cx).next().unwrap());\n    let project_id = active_call_a\n        .update(cx_a, |call, cx| call.share_project(project_a.clone(), cx))\n        .await\n        .unwrap();\n\n    let project_b = client_b.join_remote_project(project_id, cx_b).await;\n    cx_a.background_executor.run_until_parked();\n\n    assert!(worktree_a.read_with(cx_a, |tree, _| tree.has_update_observer()));\n\n    let workspace_b = cx_b.add_window(|window, cx| {\n        Workspace::new(\n            None,\n            project_b.clone(),\n            client_b.app_state.clone(),\n            window,\n            cx,\n        )\n    });\n    let cx_b = &mut VisualTestContext::from_window(*workspace_b, cx_b);\n    let workspace_b_view = workspace_b.root(cx_b).unwrap();\n\n    let editor_b = workspace_b\n        .update(cx_b, |workspace, window, cx| {\n            workspace.open_path((worktree_id, \"b.txt\"), None, true, window, cx)\n        })\n        .unwrap()\n        .await\n        .unwrap()\n        .downcast::<Editor>()\n        .unwrap();\n\n    //TODO: focus\n    assert!(cx_b.update_window_entity(&editor_b, |editor, window, _| editor.is_focused(window)));\n    editor_b.update_in(cx_b, |editor, window, cx| editor.insert(\"X\", window, cx));\n\n    cx_b.update(|_, cx| {\n        assert!(workspace_b_view.read(cx).is_edited());\n    });\n\n    // Drop client A's connection. Collaborators should disappear and the project should not be shown as shared.\n    server.forbid_connections();\n    server.disconnect_client(client_a.peer_id().unwrap());\n    cx_a.background_executor\n        .advance_clock(RECEIVE_TIMEOUT + RECONNECT_TIMEOUT);\n\n    project_a.read_with(cx_a, |project, _| project.collaborators().is_empty());\n\n    project_a.read_with(cx_a, |project, _| assert!(!project.is_shared()));\n\n    project_b.read_with(cx_b, |project, cx| project.is_read_only(cx));\n\n<|editable_region_end|>\n```"
  },
  "max_tokens": 1024
}